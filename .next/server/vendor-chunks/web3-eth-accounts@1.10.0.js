"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/web3-eth-accounts@1.10.0";
exports.ids = ["vendor-chunks/web3-eth-accounts@1.10.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/web3-eth-accounts@1.10.0/node_modules/web3-eth-accounts/lib/index.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/web3-eth-accounts@1.10.0/node_modules/web3-eth-accounts/lib/index.js ***!
  \*************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */\n/**\n * @file accounts.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\nvar core = __webpack_require__(/*! web3-core */ \"(ssr)/./node_modules/.pnpm/web3-core@1.10.0/node_modules/web3-core/lib/index.js\");\nvar Method = __webpack_require__(/*! web3-core-method */ \"(ssr)/./node_modules/.pnpm/web3-core-method@1.10.0/node_modules/web3-core-method/lib/index.js\");\nvar Account = __webpack_require__(/*! eth-lib/lib/account */ \"(ssr)/./node_modules/.pnpm/eth-lib@0.2.8/node_modules/eth-lib/lib/account.js\");\nvar cryp = __webpack_require__(/*! crypto */ \"crypto\");\nvar scrypt = __webpack_require__(/*! scrypt-js */ \"(ssr)/./node_modules/.pnpm/scrypt-js@3.0.1/node_modules/scrypt-js/scrypt.js\");\nvar uuid = __webpack_require__(/*! uuid */ \"(ssr)/./node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-node/index.js\");\nvar utils = __webpack_require__(/*! web3-utils */ \"(ssr)/./node_modules/.pnpm/web3-utils@1.10.0/node_modules/web3-utils/lib/index.js\");\nvar helpers = __webpack_require__(/*! web3-core-helpers */ \"(ssr)/./node_modules/.pnpm/web3-core-helpers@1.10.0/node_modules/web3-core-helpers/lib/index.js\");\nvar { TransactionFactory } = __webpack_require__(/*! @ethereumjs/tx */ \"(ssr)/./node_modules/.pnpm/@ethereumjs+tx@3.3.2/node_modules/@ethereumjs/tx/dist/index.js\");\nvar Common = (__webpack_require__(/*! @ethereumjs/common */ \"(ssr)/./node_modules/.pnpm/@ethereumjs+common@2.5.0/node_modules/@ethereumjs/common/dist/index.js\")[\"default\"]);\nvar HardForks = (__webpack_require__(/*! @ethereumjs/common */ \"(ssr)/./node_modules/.pnpm/@ethereumjs+common@2.5.0/node_modules/@ethereumjs/common/dist/index.js\").Hardfork);\nvar ethereumjsUtil = __webpack_require__(/*! ethereumjs-util */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/index.js\");\nvar isNot = function (value) {\n    return (typeof value === 'undefined') || value === null;\n};\nvar isExist = function (value) {\n    return (typeof value !== 'undefined') && value !== null;\n};\nvar Accounts = function Accounts() {\n    var _this = this;\n    // sets _requestmanager\n    core.packageInit(this, arguments);\n    // remove unecessary core functions\n    delete this.BatchRequest;\n    delete this.extend;\n    var _ethereumCall = [\n        new Method({\n            name: 'getNetworkId',\n            call: 'net_version',\n            params: 0,\n            outputFormatter: parseInt\n        }),\n        new Method({\n            name: 'getChainId',\n            call: 'eth_chainId',\n            params: 0,\n            outputFormatter: utils.hexToNumber\n        }),\n        new Method({\n            name: 'getGasPrice',\n            call: 'eth_gasPrice',\n            params: 0\n        }),\n        new Method({\n            name: 'getTransactionCount',\n            call: 'eth_getTransactionCount',\n            params: 2,\n            inputFormatter: [function (address) {\n                    if (utils.isAddress(address)) {\n                        return address;\n                    }\n                    else {\n                        throw new Error('Address ' + address + ' is not a valid address to get the \"transactionCount\".');\n                    }\n                }, function () {\n                    return 'latest';\n                }]\n        }),\n        new Method({\n            name: 'getBlockByNumber',\n            call: 'eth_getBlockByNumber',\n            params: 2,\n            inputFormatter: [function (blockNumber) {\n                    return blockNumber ? utils.toHex(blockNumber) : 'latest';\n                }, function () {\n                    return false;\n                }]\n        }),\n    ];\n    // attach methods to this._ethereumCall\n    this._ethereumCall = {};\n    _ethereumCall.forEach((method) => {\n        method.attachToObject(_this._ethereumCall);\n        method.setRequestManager(_this._requestManager);\n    });\n    this.wallet = new Wallet(this);\n};\nAccounts.prototype._addAccountFunctions = function (account) {\n    var _this = this;\n    // add sign functions\n    account.signTransaction = function signTransaction(tx, callback) {\n        return _this.signTransaction(tx, account.privateKey, callback);\n    };\n    account.sign = function sign(data) {\n        return _this.sign(data, account.privateKey);\n    };\n    account.encrypt = function encrypt(password, options) {\n        return _this.encrypt(account.privateKey, password, options);\n    };\n    return account;\n};\nAccounts.prototype.create = function create(entropy) {\n    return this._addAccountFunctions(Account.create(entropy || utils.randomHex(32)));\n};\nAccounts.prototype.privateKeyToAccount = function privateKeyToAccount(privateKey, ignoreLength) {\n    if (!privateKey.startsWith('0x')) {\n        privateKey = '0x' + privateKey;\n    }\n    // 64 hex characters + hex-prefix\n    if (!ignoreLength && privateKey.length !== 66) {\n        throw new Error(\"Private key must be 32 bytes long\");\n    }\n    return this._addAccountFunctions(Account.fromPrivate(privateKey));\n};\nAccounts.prototype.signTransaction = function signTransaction(tx, privateKey, callback) {\n    var _this = this, error = false, transactionOptions = {}, hasTxSigningOptions = !!(tx && ((tx.chain && tx.hardfork) || tx.common));\n    callback = callback || function () { };\n    if (!tx) {\n        error = new Error('No transaction object given!');\n        callback(error);\n        return Promise.reject(error);\n    }\n    if (isExist(tx.common) && isNot(tx.common.customChain)) {\n        error = new Error('If tx.common is provided it must have tx.common.customChain');\n        callback(error);\n        return Promise.reject(error);\n    }\n    if (isExist(tx.common) && isNot(tx.common.customChain.chainId)) {\n        error = new Error('If tx.common is provided it must have tx.common.customChain and tx.common.customChain.chainId');\n        callback(error);\n        return Promise.reject(error);\n    }\n    if (isExist(tx.common) && isExist(tx.common.customChain.chainId) && isExist(tx.chainId) && tx.chainId !== tx.common.customChain.chainId) {\n        error = new Error('Chain Id doesnt match in tx.chainId tx.common.customChain.chainId');\n        callback(error);\n        return Promise.reject(error);\n    }\n    function signed(tx) {\n        const error = _validateTransactionForSigning(tx);\n        if (error) {\n            callback(error);\n            return Promise.reject(error);\n        }\n        try {\n            var transaction = helpers.formatters.inputCallFormatter(Object.assign({}, tx));\n            transaction.data = transaction.data || '0x';\n            transaction.value = transaction.value || '0x';\n            transaction.gasLimit = transaction.gasLimit || transaction.gas;\n            if (transaction.type === '0x1' && transaction.accessList === undefined)\n                transaction.accessList = [];\n            // Because tx has no @ethereumjs/tx signing options we use fetched vals.\n            if (!hasTxSigningOptions) {\n                transactionOptions.common = Common.forCustomChain('mainnet', {\n                    name: 'custom-network',\n                    networkId: transaction.networkId,\n                    chainId: transaction.chainId\n                }, transaction.hardfork || HardForks.London);\n                delete transaction.networkId;\n            }\n            else {\n                if (transaction.common) {\n                    transactionOptions.common = Common.forCustomChain(transaction.common.baseChain || 'mainnet', {\n                        name: transaction.common.customChain.name || 'custom-network',\n                        networkId: transaction.common.customChain.networkId,\n                        chainId: transaction.common.customChain.chainId\n                    }, transaction.common.hardfork || HardForks.London);\n                    delete transaction.common;\n                }\n                if (transaction.chain) {\n                    transactionOptions.chain = transaction.chain;\n                    delete transaction.chain;\n                }\n                if (transaction.hardfork) {\n                    transactionOptions.hardfork = transaction.hardfork;\n                    delete transaction.hardfork;\n                }\n            }\n            if (privateKey.startsWith('0x')) {\n                privateKey = privateKey.substring(2);\n            }\n            var ethTx = TransactionFactory.fromTxData(transaction, transactionOptions);\n            var signedTx = ethTx.sign(Buffer.from(privateKey, 'hex'));\n            var validationErrors = signedTx.validate(true);\n            if (validationErrors.length > 0) {\n                let errorString = 'Signer Error: ';\n                for (const validationError of validationErrors) {\n                    errorString += `${errorString} ${validationError}.`;\n                }\n                throw new Error(errorString);\n            }\n            var rlpEncoded = signedTx.serialize().toString('hex');\n            var rawTransaction = '0x' + rlpEncoded;\n            var transactionHash = utils.keccak256(rawTransaction);\n            var result = {\n                messageHash: '0x' + Buffer.from(signedTx.getMessageToSign(true)).toString('hex'),\n                v: '0x' + signedTx.v.toString('hex'),\n                r: '0x' + signedTx.r.toString('hex'),\n                s: '0x' + signedTx.s.toString('hex'),\n                rawTransaction: rawTransaction,\n                transactionHash: transactionHash\n            };\n            callback(null, result);\n            return result;\n        }\n        catch (e) {\n            callback(e);\n            return Promise.reject(e);\n        }\n    }\n    tx.type = _handleTxType(tx);\n    // Resolve immediately if nonce, chainId, price and signing options are provided\n    if (tx.nonce !== undefined &&\n        tx.chainId !== undefined &&\n        (tx.gasPrice !== undefined ||\n            (tx.maxFeePerGas !== undefined &&\n                tx.maxPriorityFeePerGas !== undefined)) &&\n        hasTxSigningOptions) {\n        return Promise.resolve(signed(tx));\n    }\n    // Otherwise, get the missing info from the Ethereum Node\n    return Promise.all([\n        ((isNot(tx.common) || isNot(tx.common.customChain.chainId)) ? //tx.common.customChain.chainId is not optional inside tx.common if tx.common is provided\n            (isNot(tx.chainId) ? _this._ethereumCall.getChainId() : tx.chainId)\n            : undefined),\n        isNot(tx.nonce) ? _this._ethereumCall.getTransactionCount(_this.privateKeyToAccount(privateKey).address) : tx.nonce,\n        isNot(hasTxSigningOptions) ? _this._ethereumCall.getNetworkId() : 1,\n        _handleTxPricing(_this, tx)\n    ]).then(function (args) {\n        const [txchainId, txnonce, txnetworkId, txgasInfo] = args;\n        if ((isNot(txchainId) && isNot(tx.common) && isNot(tx.common.customChain.chainId)) || isNot(txnonce) || isNot(txnetworkId) || isNot(txgasInfo)) {\n            throw new Error('One of the values \"chainId\", \"networkId\", \"gasPrice\", or \"nonce\" couldn\\'t be fetched: ' + JSON.stringify(args));\n        }\n        return signed({\n            ...tx,\n            ...((isNot(tx.common) || isNot(tx.common.customChain.chainId)) ? { chainId: txchainId } : {}),\n            nonce: txnonce,\n            networkId: txnetworkId,\n            ...txgasInfo // Will either be gasPrice or maxFeePerGas and maxPriorityFeePerGas\n        });\n    });\n};\nfunction _validateTransactionForSigning(tx) {\n    if (tx.common && (tx.chain && tx.hardfork)) {\n        return new Error('Please provide the @ethereumjs/common object or the chain and hardfork property but not all together.');\n    }\n    if ((tx.chain && !tx.hardfork) || (tx.hardfork && !tx.chain)) {\n        return new Error('When specifying chain and hardfork, both values must be defined. ' +\n            'Received \"chain\": ' + tx.chain + ', \"hardfork\": ' + tx.hardfork);\n    }\n    if ((!tx.gas && !tx.gasLimit) &&\n        (!tx.maxPriorityFeePerGas && !tx.maxFeePerGas)) {\n        return new Error('\"gas\" is missing');\n    }\n    if (tx.gas && tx.gasPrice) {\n        if (tx.gas < 0 || tx.gasPrice < 0) {\n            return new Error('Gas or gasPrice is lower than 0');\n        }\n    }\n    else {\n        if (tx.maxPriorityFeePerGas < 0 || tx.maxFeePerGas < 0) {\n            return new Error('maxPriorityFeePerGas or maxFeePerGas is lower than 0');\n        }\n    }\n    if (tx.nonce < 0 || tx.chainId < 0) {\n        return new Error('Nonce or chainId is lower than 0');\n    }\n    return;\n}\nfunction _handleTxType(tx) {\n    // Taken from https://github.com/ethers-io/ethers.js/blob/2a7ce0e72a1e0c9469e10392b0329e75e341cf18/packages/abstract-signer/src.ts/index.ts#L215\n    const hasEip1559 = (tx.maxFeePerGas !== undefined || tx.maxPriorityFeePerGas !== undefined);\n    let txType;\n    if (tx.type !== undefined) {\n        txType = utils.toHex(tx.type);\n    }\n    else if (tx.type === undefined && hasEip1559) {\n        txType = '0x2';\n    }\n    if (tx.gasPrice !== undefined && (txType === '0x2' || hasEip1559))\n        throw Error(\"eip-1559 transactions don't support gasPrice\");\n    if ((txType === '0x1' || txType === '0x0') && hasEip1559)\n        throw Error(\"pre-eip-1559 transaction don't support maxFeePerGas/maxPriorityFeePerGas\");\n    if (hasEip1559 ||\n        ((tx.common && tx.common.hardfork && tx.common.hardfork.toLowerCase() === HardForks.London) ||\n            (tx.hardfork && tx.hardfork.toLowerCase() === HardForks.London))) {\n        txType = '0x2';\n    }\n    else if (tx.accessList ||\n        ((tx.common && tx.common.hardfork && tx.common.hardfork.toLowerCase() === HardForks.Berlin) ||\n            (tx.hardfork && tx.hardfork.toLowerCase() === HardForks.Berlin))) {\n        txType = '0x1';\n    }\n    return txType;\n}\nfunction _handleTxPricing(_this, tx) {\n    return new Promise((resolve, reject) => {\n        try {\n            if ((tx.type === undefined || tx.type < '0x2')\n                && tx.gasPrice !== undefined) {\n                // Legacy transaction, return provided gasPrice\n                resolve({ gasPrice: tx.gasPrice });\n            }\n            else if (tx.type === '0x2' && tx.maxFeePerGas && tx.maxPriorityFeePerGas) {\n                // EIP-1559 transaction, return provided maxFeePerGas and maxPriorityFeePerGas\n                resolve({ maxFeePerGas: tx.maxFeePerGas, maxPriorityFeePerGas: tx.maxPriorityFeePerGas });\n            }\n            else {\n                Promise.all([\n                    _this._ethereumCall.getBlockByNumber(),\n                    _this._ethereumCall.getGasPrice()\n                ]).then(responses => {\n                    const [block, gasPrice] = responses;\n                    if ((tx.type === '0x2') &&\n                        block && block.baseFeePerGas) {\n                        // The network supports EIP-1559\n                        // Taken from https://github.com/ethers-io/ethers.js/blob/ba6854bdd5a912fe873d5da494cb5c62c190adde/packages/abstract-provider/src.ts/index.ts#L230\n                        let maxPriorityFeePerGas, maxFeePerGas;\n                        if (tx.gasPrice) {\n                            // Using legacy gasPrice property on an eip-1559 network,\n                            // so use gasPrice as both fee properties\n                            maxPriorityFeePerGas = tx.gasPrice;\n                            maxFeePerGas = tx.gasPrice;\n                            delete tx.gasPrice;\n                        }\n                        else {\n                            maxPriorityFeePerGas = tx.maxPriorityFeePerGas || '0x9502F900'; // 2.5 Gwei\n                            maxFeePerGas = tx.maxFeePerGas ||\n                                utils.toHex(utils.toBN(block.baseFeePerGas)\n                                    .mul(utils.toBN(2))\n                                    .add(utils.toBN(maxPriorityFeePerGas)));\n                        }\n                        resolve({ maxFeePerGas, maxPriorityFeePerGas });\n                    }\n                    else {\n                        if (tx.maxPriorityFeePerGas || tx.maxFeePerGas)\n                            throw Error(\"Network doesn't support eip-1559\");\n                        resolve({ gasPrice });\n                    }\n                }).catch((error) => {\n                    reject(error);\n                });\n            }\n        }\n        catch (error) {\n            reject(error);\n        }\n    });\n}\n/* jshint ignore:start */\nAccounts.prototype.recoverTransaction = function recoverTransaction(rawTx, txOptions = {}) {\n    // Rely on EthereumJs/tx to determine the type of transaction\n    const data = Buffer.from(rawTx.slice(2), \"hex\");\n    const tx = TransactionFactory.fromSerializedData(data);\n    //update checksum\n    return utils.toChecksumAddress(tx.getSenderAddress().toString(\"hex\"));\n};\n/* jshint ignore:end */\nAccounts.prototype.hashMessage = function hashMessage(data) {\n    var messageHex = utils.isHexStrict(data) ? data : utils.utf8ToHex(data);\n    var messageBytes = utils.hexToBytes(messageHex);\n    var messageBuffer = Buffer.from(messageBytes);\n    var preamble = '\\x19Ethereum Signed Message:\\n' + messageBytes.length;\n    var preambleBuffer = Buffer.from(preamble);\n    var ethMessage = Buffer.concat([preambleBuffer, messageBuffer]);\n    return ethereumjsUtil.bufferToHex(ethereumjsUtil.keccak256(ethMessage));\n};\nAccounts.prototype.sign = function sign(data, privateKey) {\n    if (!privateKey.startsWith('0x')) {\n        privateKey = '0x' + privateKey;\n    }\n    // 64 hex characters + hex-prefix\n    if (privateKey.length !== 66) {\n        throw new Error(\"Private key must be 32 bytes long\");\n    }\n    var hash = this.hashMessage(data);\n    var signature = Account.sign(hash, privateKey);\n    var vrs = Account.decodeSignature(signature);\n    return {\n        message: data,\n        messageHash: hash,\n        v: vrs[0],\n        r: vrs[1],\n        s: vrs[2],\n        signature: signature\n    };\n};\nAccounts.prototype.recover = function recover(message, signature, preFixed) {\n    var args = [].slice.apply(arguments);\n    if (!!message && typeof message === 'object') {\n        return this.recover(message.messageHash, Account.encodeSignature([message.v, message.r, message.s]), true);\n    }\n    if (!preFixed) {\n        message = this.hashMessage(message);\n    }\n    if (args.length >= 4) {\n        preFixed = args.slice(-1)[0];\n        preFixed = typeof preFixed === 'boolean' ? !!preFixed : false;\n        return this.recover(message, Account.encodeSignature(args.slice(1, 4)), preFixed); // v, r, s\n    }\n    return Account.recover(message, signature);\n};\n// Taken from https://github.com/ethereumjs/ethereumjs-wallet\nAccounts.prototype.decrypt = function (v3Keystore, password, nonStrict) {\n    /* jshint maxcomplexity: 10 */\n    if (!(typeof password === 'string')) {\n        throw new Error('No password given.');\n    }\n    var json = (!!v3Keystore && typeof v3Keystore === 'object') ? v3Keystore : JSON.parse(nonStrict ? v3Keystore.toLowerCase() : v3Keystore);\n    if (json.version !== 3) {\n        throw new Error('Not a valid V3 wallet');\n    }\n    var derivedKey;\n    var kdfparams;\n    if (json.crypto.kdf === 'scrypt') {\n        kdfparams = json.crypto.kdfparams;\n        // FIXME: support progress reporting callback\n        derivedKey = scrypt.syncScrypt(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);\n    }\n    else if (json.crypto.kdf === 'pbkdf2') {\n        kdfparams = json.crypto.kdfparams;\n        if (kdfparams.prf !== 'hmac-sha256') {\n            throw new Error('Unsupported parameters to PBKDF2');\n        }\n        derivedKey = cryp.pbkdf2Sync(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.c, kdfparams.dklen, 'sha256');\n    }\n    else {\n        throw new Error('Unsupported key derivation scheme');\n    }\n    var ciphertext = Buffer.from(json.crypto.ciphertext, 'hex');\n    var mac = utils.sha3(Buffer.from([...derivedKey.slice(16, 32), ...ciphertext])).replace('0x', '');\n    if (mac !== json.crypto.mac) {\n        throw new Error('Key derivation failed - possibly wrong password');\n    }\n    var decipher = cryp.createDecipheriv(json.crypto.cipher, derivedKey.slice(0, 16), Buffer.from(json.crypto.cipherparams.iv, 'hex'));\n    var seed = '0x' + Buffer.from([...decipher.update(ciphertext), ...decipher.final()]).toString('hex');\n    return this.privateKeyToAccount(seed, true);\n};\nAccounts.prototype.encrypt = function (privateKey, password, options) {\n    /* jshint maxcomplexity: 20 */\n    var account = this.privateKeyToAccount(privateKey, true);\n    options = options || {};\n    var salt = options.salt || cryp.randomBytes(32);\n    var iv = options.iv || cryp.randomBytes(16);\n    var derivedKey;\n    var kdf = options.kdf || 'scrypt';\n    var kdfparams = {\n        dklen: options.dklen || 32,\n        salt: salt.toString('hex')\n    };\n    if (kdf === 'pbkdf2') {\n        kdfparams.c = options.c || 262144;\n        kdfparams.prf = 'hmac-sha256';\n        derivedKey = cryp.pbkdf2Sync(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.c, kdfparams.dklen, 'sha256');\n    }\n    else if (kdf === 'scrypt') {\n        // FIXME: support progress reporting callback\n        kdfparams.n = options.n || 8192; // 2048 4096 8192 16384\n        kdfparams.r = options.r || 8;\n        kdfparams.p = options.p || 1;\n        derivedKey = scrypt.syncScrypt(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);\n    }\n    else {\n        throw new Error('Unsupported kdf');\n    }\n    var cipher = cryp.createCipheriv(options.cipher || 'aes-128-ctr', derivedKey.slice(0, 16), iv);\n    if (!cipher) {\n        throw new Error('Unsupported cipher');\n    }\n    var ciphertext = Buffer.from([\n        ...cipher.update(Buffer.from(account.privateKey.replace('0x', ''), 'hex')),\n        ...cipher.final()\n    ]);\n    var mac = utils.sha3(Buffer.from([...derivedKey.slice(16, 32), ...ciphertext])).replace('0x', '');\n    return {\n        version: 3,\n        id: uuid.v4({ random: options.uuid || cryp.randomBytes(16) }),\n        address: account.address.toLowerCase().replace('0x', ''),\n        crypto: {\n            ciphertext: ciphertext.toString('hex'),\n            cipherparams: {\n                iv: iv.toString('hex')\n            },\n            cipher: options.cipher || 'aes-128-ctr',\n            kdf: kdf,\n            kdfparams: kdfparams,\n            mac: mac.toString('hex')\n        }\n    };\n};\n// Note: this is trying to follow closely the specs on\n// http://web3js.readthedocs.io/en/1.0/web3-eth-accounts.html\nfunction Wallet(accounts) {\n    this._accounts = accounts;\n    this.length = 0;\n    this.defaultKeyName = 'web3js_wallet';\n}\nWallet.prototype._findSafeIndex = function (pointer) {\n    pointer = pointer || 0;\n    if (this.hasOwnProperty(pointer)) {\n        return this._findSafeIndex(pointer + 1);\n    }\n    else {\n        return pointer;\n    }\n};\nWallet.prototype._currentIndexes = function () {\n    var keys = Object.keys(this);\n    var indexes = keys\n        .map(function (key) {\n        return parseInt(key);\n    })\n        .filter(function (n) {\n        return (n < 9e20);\n    });\n    return indexes;\n};\nWallet.prototype.create = function (numberOfAccounts, entropy) {\n    for (var i = 0; i < numberOfAccounts; ++i) {\n        this.add(this._accounts.create(entropy).privateKey);\n    }\n    return this;\n};\nWallet.prototype.add = function (account) {\n    if (typeof account === 'string') {\n        account = this._accounts.privateKeyToAccount(account);\n    }\n    if (!this[account.address]) {\n        account = this._accounts.privateKeyToAccount(account.privateKey);\n        account.index = this._findSafeIndex();\n        this[account.index] = account;\n        this[account.address] = account;\n        this[account.address.toLowerCase()] = account;\n        this.length++;\n        return account;\n    }\n    else {\n        return this[account.address];\n    }\n};\nWallet.prototype.remove = function (addressOrIndex) {\n    var account = this[addressOrIndex];\n    if (account && account.address) {\n        // address\n        this[account.address].privateKey = null;\n        delete this[account.address];\n        // address lowercase\n        if (this[account.address.toLowerCase()]) {\n            this[account.address.toLowerCase()].privateKey = null;\n            delete this[account.address.toLowerCase()];\n        }\n        // index\n        this[account.index].privateKey = null;\n        delete this[account.index];\n        this.length--;\n        return true;\n    }\n    else {\n        return false;\n    }\n};\nWallet.prototype.clear = function () {\n    var _this = this;\n    var indexes = this._currentIndexes();\n    indexes.forEach(function (index) {\n        _this.remove(index);\n    });\n    return this;\n};\nWallet.prototype.encrypt = function (password, options) {\n    var _this = this;\n    var indexes = this._currentIndexes();\n    var accounts = indexes.map(function (index) {\n        return _this[index].encrypt(password, options);\n    });\n    return accounts;\n};\nWallet.prototype.decrypt = function (encryptedWallet, password) {\n    var _this = this;\n    encryptedWallet.forEach(function (keystore) {\n        var account = _this._accounts.decrypt(keystore, password);\n        if (account) {\n            _this.add(account);\n        }\n        else {\n            throw new Error('Couldn\\'t decrypt accounts. Password wrong?');\n        }\n    });\n    return this;\n};\nWallet.prototype.save = function (password, keyName) {\n    localStorage.setItem(keyName || this.defaultKeyName, JSON.stringify(this.encrypt(password)));\n    return true;\n};\nWallet.prototype.load = function (password, keyName) {\n    var keystore = localStorage.getItem(keyName || this.defaultKeyName);\n    if (keystore) {\n        try {\n            keystore = JSON.parse(keystore);\n        }\n        catch (e) {\n        }\n    }\n    return this.decrypt(keystore || [], password);\n};\nif (!storageAvailable('localStorage')) {\n    delete Wallet.prototype.save;\n    delete Wallet.prototype.load;\n}\n/**\n * Checks whether a storage type is available or not\n * For more info on how this works, please refer to MDN documentation\n * https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API#Feature-detecting_localStorage\n *\n * @method storageAvailable\n * @param {String} type the type of storage ('localStorage', 'sessionStorage')\n * @returns {Boolean} a boolean indicating whether the specified storage is available or not\n */\nfunction storageAvailable(type) {\n    var storage;\n    try {\n        storage = self[type];\n        var x = '__storage_test__';\n        storage.setItem(x, x);\n        storage.removeItem(x);\n        return true;\n    }\n    catch (e) {\n        return e && (\n        // everything except Firefox\n        e.code === 22 ||\n            // Firefox\n            e.code === 1014 ||\n            // test name field too, because code might not be present\n            // everything except Firefox\n            e.name === 'QuotaExceededError' ||\n            // Firefox\n            e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&\n            // acknowledge QuotaExceededError only if there's something already stored\n            (storage && storage.length !== 0);\n    }\n}\nmodule.exports = Accounts;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViMy1ldGgtYWNjb3VudHNAMS4xMC4wL25vZGVfbW9kdWxlcy93ZWIzLWV0aC1hY2NvdW50cy9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUNiLFdBQVcsbUJBQU8sQ0FBQyxrR0FBVztBQUM5QixhQUFhLG1CQUFPLENBQUMsdUhBQWtCO0FBQ3ZDLGNBQWMsbUJBQU8sQ0FBQyx5R0FBcUI7QUFDM0MsV0FBVyxtQkFBTyxDQUFDLHNCQUFRO0FBQzNCLGFBQWEsbUJBQU8sQ0FBQyw4RkFBVztBQUNoQyxXQUFXLG1CQUFPLENBQUMsNEZBQU07QUFDekIsWUFBWSxtQkFBTyxDQUFDLHFHQUFZO0FBQ2hDLGNBQWMsbUJBQU8sQ0FBQywwSEFBbUI7QUFDekMsTUFBTSxxQkFBcUIsRUFBRSxtQkFBTyxDQUFDLGlIQUFnQjtBQUNyRCxhQUFhLCtKQUFxQztBQUNsRCxnQkFBZ0IsNkpBQXNDO0FBQ3RELHFCQUFxQixtQkFBTyxDQUFDLG9IQUFpQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxhQUFhLEVBQUUsZ0JBQWdCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UscUJBQXFCLElBQUk7QUFDeEc7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdUJBQXVCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4RUFBOEU7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9DQUFvQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxVQUFVO0FBQzVDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHlGQUF5RjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw4Q0FBOEM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8va2lja3N0YXJ0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL3dlYjMtZXRoLWFjY291bnRzQDEuMTAuMC9ub2RlX21vZHVsZXMvd2ViMy1ldGgtYWNjb3VudHMvbGliL2luZGV4LmpzP2ZjNWUiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuICovXG4vKipcbiAqIEBmaWxlIGFjY291bnRzLmpzXG4gKiBAYXV0aG9yIEZhYmlhbiBWb2dlbHN0ZWxsZXIgPGZhYmlhbkBldGhlcmV1bS5vcmc+XG4gKiBAZGF0ZSAyMDE3XG4gKi9cbid1c2Ugc3RyaWN0JztcbnZhciBjb3JlID0gcmVxdWlyZSgnd2ViMy1jb3JlJyk7XG52YXIgTWV0aG9kID0gcmVxdWlyZSgnd2ViMy1jb3JlLW1ldGhvZCcpO1xudmFyIEFjY291bnQgPSByZXF1aXJlKCdldGgtbGliL2xpYi9hY2NvdW50Jyk7XG52YXIgY3J5cCA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIHNjcnlwdCA9IHJlcXVpcmUoJ3NjcnlwdC1qcycpO1xudmFyIHV1aWQgPSByZXF1aXJlKCd1dWlkJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCd3ZWIzLXV0aWxzJyk7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoJ3dlYjMtY29yZS1oZWxwZXJzJyk7XG52YXIgeyBUcmFuc2FjdGlvbkZhY3RvcnkgfSA9IHJlcXVpcmUoJ0BldGhlcmV1bWpzL3R4Jyk7XG52YXIgQ29tbW9uID0gcmVxdWlyZSgnQGV0aGVyZXVtanMvY29tbW9uJykuZGVmYXVsdDtcbnZhciBIYXJkRm9ya3MgPSByZXF1aXJlKCdAZXRoZXJldW1qcy9jb21tb24nKS5IYXJkZm9yaztcbnZhciBldGhlcmV1bWpzVXRpbCA9IHJlcXVpcmUoJ2V0aGVyZXVtanMtdXRpbCcpO1xudmFyIGlzTm90ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB8fCB2YWx1ZSA9PT0gbnVsbDtcbn07XG52YXIgaXNFeGlzdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykgJiYgdmFsdWUgIT09IG51bGw7XG59O1xudmFyIEFjY291bnRzID0gZnVuY3Rpb24gQWNjb3VudHMoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAvLyBzZXRzIF9yZXF1ZXN0bWFuYWdlclxuICAgIGNvcmUucGFja2FnZUluaXQodGhpcywgYXJndW1lbnRzKTtcbiAgICAvLyByZW1vdmUgdW5lY2Vzc2FyeSBjb3JlIGZ1bmN0aW9uc1xuICAgIGRlbGV0ZSB0aGlzLkJhdGNoUmVxdWVzdDtcbiAgICBkZWxldGUgdGhpcy5leHRlbmQ7XG4gICAgdmFyIF9ldGhlcmV1bUNhbGwgPSBbXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2dldE5ldHdvcmtJZCcsXG4gICAgICAgICAgICBjYWxsOiAnbmV0X3ZlcnNpb24nLFxuICAgICAgICAgICAgcGFyYW1zOiAwLFxuICAgICAgICAgICAgb3V0cHV0Rm9ybWF0dGVyOiBwYXJzZUludFxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZ2V0Q2hhaW5JZCcsXG4gICAgICAgICAgICBjYWxsOiAnZXRoX2NoYWluSWQnLFxuICAgICAgICAgICAgcGFyYW1zOiAwLFxuICAgICAgICAgICAgb3V0cHV0Rm9ybWF0dGVyOiB1dGlscy5oZXhUb051bWJlclxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZ2V0R2FzUHJpY2UnLFxuICAgICAgICAgICAgY2FsbDogJ2V0aF9nYXNQcmljZScsXG4gICAgICAgICAgICBwYXJhbXM6IDBcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2dldFRyYW5zYWN0aW9uQ291bnQnLFxuICAgICAgICAgICAgY2FsbDogJ2V0aF9nZXRUcmFuc2FjdGlvbkNvdW50JyxcbiAgICAgICAgICAgIHBhcmFtczogMixcbiAgICAgICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHV0aWxzLmlzQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FkZHJlc3MgJyArIGFkZHJlc3MgKyAnIGlzIG5vdCBhIHZhbGlkIGFkZHJlc3MgdG8gZ2V0IHRoZSBcInRyYW5zYWN0aW9uQ291bnRcIi4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdsYXRlc3QnO1xuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdnZXRCbG9ja0J5TnVtYmVyJyxcbiAgICAgICAgICAgIGNhbGw6ICdldGhfZ2V0QmxvY2tCeU51bWJlcicsXG4gICAgICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Z1bmN0aW9uIChibG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmxvY2tOdW1iZXIgPyB1dGlscy50b0hleChibG9ja051bWJlcikgOiAnbGF0ZXN0JztcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9KSxcbiAgICBdO1xuICAgIC8vIGF0dGFjaCBtZXRob2RzIHRvIHRoaXMuX2V0aGVyZXVtQ2FsbFxuICAgIHRoaXMuX2V0aGVyZXVtQ2FsbCA9IHt9O1xuICAgIF9ldGhlcmV1bUNhbGwuZm9yRWFjaCgobWV0aG9kKSA9PiB7XG4gICAgICAgIG1ldGhvZC5hdHRhY2hUb09iamVjdChfdGhpcy5fZXRoZXJldW1DYWxsKTtcbiAgICAgICAgbWV0aG9kLnNldFJlcXVlc3RNYW5hZ2VyKF90aGlzLl9yZXF1ZXN0TWFuYWdlcik7XG4gICAgfSk7XG4gICAgdGhpcy53YWxsZXQgPSBuZXcgV2FsbGV0KHRoaXMpO1xufTtcbkFjY291bnRzLnByb3RvdHlwZS5fYWRkQWNjb3VudEZ1bmN0aW9ucyA9IGZ1bmN0aW9uIChhY2NvdW50KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAvLyBhZGQgc2lnbiBmdW5jdGlvbnNcbiAgICBhY2NvdW50LnNpZ25UcmFuc2FjdGlvbiA9IGZ1bmN0aW9uIHNpZ25UcmFuc2FjdGlvbih0eCwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnNpZ25UcmFuc2FjdGlvbih0eCwgYWNjb3VudC5wcml2YXRlS2V5LCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBhY2NvdW50LnNpZ24gPSBmdW5jdGlvbiBzaWduKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnNpZ24oZGF0YSwgYWNjb3VudC5wcml2YXRlS2V5KTtcbiAgICB9O1xuICAgIGFjY291bnQuZW5jcnlwdCA9IGZ1bmN0aW9uIGVuY3J5cHQocGFzc3dvcmQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmVuY3J5cHQoYWNjb3VudC5wcml2YXRlS2V5LCBwYXNzd29yZCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICByZXR1cm4gYWNjb3VudDtcbn07XG5BY2NvdW50cy5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGVudHJvcHkpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQWNjb3VudEZ1bmN0aW9ucyhBY2NvdW50LmNyZWF0ZShlbnRyb3B5IHx8IHV0aWxzLnJhbmRvbUhleCgzMikpKTtcbn07XG5BY2NvdW50cy5wcm90b3R5cGUucHJpdmF0ZUtleVRvQWNjb3VudCA9IGZ1bmN0aW9uIHByaXZhdGVLZXlUb0FjY291bnQocHJpdmF0ZUtleSwgaWdub3JlTGVuZ3RoKSB7XG4gICAgaWYgKCFwcml2YXRlS2V5LnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgcHJpdmF0ZUtleSA9ICcweCcgKyBwcml2YXRlS2V5O1xuICAgIH1cbiAgICAvLyA2NCBoZXggY2hhcmFjdGVycyArIGhleC1wcmVmaXhcbiAgICBpZiAoIWlnbm9yZUxlbmd0aCAmJiBwcml2YXRlS2V5Lmxlbmd0aCAhPT0gNjYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJpdmF0ZSBrZXkgbXVzdCBiZSAzMiBieXRlcyBsb25nXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYWRkQWNjb3VudEZ1bmN0aW9ucyhBY2NvdW50LmZyb21Qcml2YXRlKHByaXZhdGVLZXkpKTtcbn07XG5BY2NvdW50cy5wcm90b3R5cGUuc2lnblRyYW5zYWN0aW9uID0gZnVuY3Rpb24gc2lnblRyYW5zYWN0aW9uKHR4LCBwcml2YXRlS2V5LCBjYWxsYmFjaykge1xuICAgIHZhciBfdGhpcyA9IHRoaXMsIGVycm9yID0gZmFsc2UsIHRyYW5zYWN0aW9uT3B0aW9ucyA9IHt9LCBoYXNUeFNpZ25pbmdPcHRpb25zID0gISEodHggJiYgKCh0eC5jaGFpbiAmJiB0eC5oYXJkZm9yaykgfHwgdHguY29tbW9uKSk7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7IH07XG4gICAgaWYgKCF0eCkge1xuICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignTm8gdHJhbnNhY3Rpb24gb2JqZWN0IGdpdmVuIScpO1xuICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuICAgIGlmIChpc0V4aXN0KHR4LmNvbW1vbikgJiYgaXNOb3QodHguY29tbW9uLmN1c3RvbUNoYWluKSkge1xuICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignSWYgdHguY29tbW9uIGlzIHByb3ZpZGVkIGl0IG11c3QgaGF2ZSB0eC5jb21tb24uY3VzdG9tQ2hhaW4nKTtcbiAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cbiAgICBpZiAoaXNFeGlzdCh0eC5jb21tb24pICYmIGlzTm90KHR4LmNvbW1vbi5jdXN0b21DaGFpbi5jaGFpbklkKSkge1xuICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignSWYgdHguY29tbW9uIGlzIHByb3ZpZGVkIGl0IG11c3QgaGF2ZSB0eC5jb21tb24uY3VzdG9tQ2hhaW4gYW5kIHR4LmNvbW1vbi5jdXN0b21DaGFpbi5jaGFpbklkJyk7XG4gICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG4gICAgaWYgKGlzRXhpc3QodHguY29tbW9uKSAmJiBpc0V4aXN0KHR4LmNvbW1vbi5jdXN0b21DaGFpbi5jaGFpbklkKSAmJiBpc0V4aXN0KHR4LmNoYWluSWQpICYmIHR4LmNoYWluSWQgIT09IHR4LmNvbW1vbi5jdXN0b21DaGFpbi5jaGFpbklkKSB7XG4gICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdDaGFpbiBJZCBkb2VzbnQgbWF0Y2ggaW4gdHguY2hhaW5JZCB0eC5jb21tb24uY3VzdG9tQ2hhaW4uY2hhaW5JZCcpO1xuICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNpZ25lZCh0eCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IF92YWxpZGF0ZVRyYW5zYWN0aW9uRm9yU2lnbmluZyh0eCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0gaGVscGVycy5mb3JtYXR0ZXJzLmlucHV0Q2FsbEZvcm1hdHRlcihPYmplY3QuYXNzaWduKHt9LCB0eCkpO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24uZGF0YSA9IHRyYW5zYWN0aW9uLmRhdGEgfHwgJzB4JztcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLnZhbHVlID0gdHJhbnNhY3Rpb24udmFsdWUgfHwgJzB4JztcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmdhc0xpbWl0ID0gdHJhbnNhY3Rpb24uZ2FzTGltaXQgfHwgdHJhbnNhY3Rpb24uZ2FzO1xuICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnR5cGUgPT09ICcweDEnICYmIHRyYW5zYWN0aW9uLmFjY2Vzc0xpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0ID0gW107XG4gICAgICAgICAgICAvLyBCZWNhdXNlIHR4IGhhcyBubyBAZXRoZXJldW1qcy90eCBzaWduaW5nIG9wdGlvbnMgd2UgdXNlIGZldGNoZWQgdmFscy5cbiAgICAgICAgICAgIGlmICghaGFzVHhTaWduaW5nT3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uT3B0aW9ucy5jb21tb24gPSBDb21tb24uZm9yQ3VzdG9tQ2hhaW4oJ21haW5uZXQnLCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdjdXN0b20tbmV0d29yaycsXG4gICAgICAgICAgICAgICAgICAgIG5ldHdvcmtJZDogdHJhbnNhY3Rpb24ubmV0d29ya0lkLFxuICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiB0cmFuc2FjdGlvbi5jaGFpbklkXG4gICAgICAgICAgICAgICAgfSwgdHJhbnNhY3Rpb24uaGFyZGZvcmsgfHwgSGFyZEZvcmtzLkxvbmRvbik7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRyYW5zYWN0aW9uLm5ldHdvcmtJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi5jb21tb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25PcHRpb25zLmNvbW1vbiA9IENvbW1vbi5mb3JDdXN0b21DaGFpbih0cmFuc2FjdGlvbi5jb21tb24uYmFzZUNoYWluIHx8ICdtYWlubmV0Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdHJhbnNhY3Rpb24uY29tbW9uLmN1c3RvbUNoYWluLm5hbWUgfHwgJ2N1c3RvbS1uZXR3b3JrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmtJZDogdHJhbnNhY3Rpb24uY29tbW9uLmN1c3RvbUNoYWluLm5ldHdvcmtJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IHRyYW5zYWN0aW9uLmNvbW1vbi5jdXN0b21DaGFpbi5jaGFpbklkXG4gICAgICAgICAgICAgICAgICAgIH0sIHRyYW5zYWN0aW9uLmNvbW1vbi5oYXJkZm9yayB8fCBIYXJkRm9ya3MuTG9uZG9uKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRyYW5zYWN0aW9uLmNvbW1vbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmNoYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uT3B0aW9ucy5jaGFpbiA9IHRyYW5zYWN0aW9uLmNoYWluO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdHJhbnNhY3Rpb24uY2hhaW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi5oYXJkZm9yaykge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbk9wdGlvbnMuaGFyZGZvcmsgPSB0cmFuc2FjdGlvbi5oYXJkZm9yaztcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRyYW5zYWN0aW9uLmhhcmRmb3JrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcml2YXRlS2V5LnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgICAgICAgICBwcml2YXRlS2V5ID0gcHJpdmF0ZUtleS5zdWJzdHJpbmcoMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZXRoVHggPSBUcmFuc2FjdGlvbkZhY3RvcnkuZnJvbVR4RGF0YSh0cmFuc2FjdGlvbiwgdHJhbnNhY3Rpb25PcHRpb25zKTtcbiAgICAgICAgICAgIHZhciBzaWduZWRUeCA9IGV0aFR4LnNpZ24oQnVmZmVyLmZyb20ocHJpdmF0ZUtleSwgJ2hleCcpKTtcbiAgICAgICAgICAgIHZhciB2YWxpZGF0aW9uRXJyb3JzID0gc2lnbmVkVHgudmFsaWRhdGUodHJ1ZSk7XG4gICAgICAgICAgICBpZiAodmFsaWRhdGlvbkVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVycm9yU3RyaW5nID0gJ1NpZ25lciBFcnJvcjogJztcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHZhbGlkYXRpb25FcnJvciBvZiB2YWxpZGF0aW9uRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yU3RyaW5nICs9IGAke2Vycm9yU3RyaW5nfSAke3ZhbGlkYXRpb25FcnJvcn0uYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yU3RyaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBybHBFbmNvZGVkID0gc2lnbmVkVHguc2VyaWFsaXplKCkudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICAgICAgdmFyIHJhd1RyYW5zYWN0aW9uID0gJzB4JyArIHJscEVuY29kZWQ7XG4gICAgICAgICAgICB2YXIgdHJhbnNhY3Rpb25IYXNoID0gdXRpbHMua2VjY2FrMjU2KHJhd1RyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZUhhc2g6ICcweCcgKyBCdWZmZXIuZnJvbShzaWduZWRUeC5nZXRNZXNzYWdlVG9TaWduKHRydWUpKS50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgICAgICAgdjogJzB4JyArIHNpZ25lZFR4LnYudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgICAgICAgIHI6ICcweCcgKyBzaWduZWRUeC5yLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgICAgICAgICBzOiAnMHgnICsgc2lnbmVkVHgucy50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgICAgICAgcmF3VHJhbnNhY3Rpb246IHJhd1RyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogdHJhbnNhY3Rpb25IYXNoXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHR4LnR5cGUgPSBfaGFuZGxlVHhUeXBlKHR4KTtcbiAgICAvLyBSZXNvbHZlIGltbWVkaWF0ZWx5IGlmIG5vbmNlLCBjaGFpbklkLCBwcmljZSBhbmQgc2lnbmluZyBvcHRpb25zIGFyZSBwcm92aWRlZFxuICAgIGlmICh0eC5ub25jZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHR4LmNoYWluSWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAodHguZ2FzUHJpY2UgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgKHR4Lm1heEZlZVBlckdhcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT09IHVuZGVmaW5lZCkpICYmXG4gICAgICAgIGhhc1R4U2lnbmluZ09wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzaWduZWQodHgpKTtcbiAgICB9XG4gICAgLy8gT3RoZXJ3aXNlLCBnZXQgdGhlIG1pc3NpbmcgaW5mbyBmcm9tIHRoZSBFdGhlcmV1bSBOb2RlXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgKChpc05vdCh0eC5jb21tb24pIHx8IGlzTm90KHR4LmNvbW1vbi5jdXN0b21DaGFpbi5jaGFpbklkKSkgPyAvL3R4LmNvbW1vbi5jdXN0b21DaGFpbi5jaGFpbklkIGlzIG5vdCBvcHRpb25hbCBpbnNpZGUgdHguY29tbW9uIGlmIHR4LmNvbW1vbiBpcyBwcm92aWRlZFxuICAgICAgICAgICAgKGlzTm90KHR4LmNoYWluSWQpID8gX3RoaXMuX2V0aGVyZXVtQ2FsbC5nZXRDaGFpbklkKCkgOiB0eC5jaGFpbklkKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQpLFxuICAgICAgICBpc05vdCh0eC5ub25jZSkgPyBfdGhpcy5fZXRoZXJldW1DYWxsLmdldFRyYW5zYWN0aW9uQ291bnQoX3RoaXMucHJpdmF0ZUtleVRvQWNjb3VudChwcml2YXRlS2V5KS5hZGRyZXNzKSA6IHR4Lm5vbmNlLFxuICAgICAgICBpc05vdChoYXNUeFNpZ25pbmdPcHRpb25zKSA/IF90aGlzLl9ldGhlcmV1bUNhbGwuZ2V0TmV0d29ya0lkKCkgOiAxLFxuICAgICAgICBfaGFuZGxlVHhQcmljaW5nKF90aGlzLCB0eClcbiAgICBdKS50aGVuKGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIGNvbnN0IFt0eGNoYWluSWQsIHR4bm9uY2UsIHR4bmV0d29ya0lkLCB0eGdhc0luZm9dID0gYXJncztcbiAgICAgICAgaWYgKChpc05vdCh0eGNoYWluSWQpICYmIGlzTm90KHR4LmNvbW1vbikgJiYgaXNOb3QodHguY29tbW9uLmN1c3RvbUNoYWluLmNoYWluSWQpKSB8fCBpc05vdCh0eG5vbmNlKSB8fCBpc05vdCh0eG5ldHdvcmtJZCkgfHwgaXNOb3QodHhnYXNJbmZvKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmUgb2YgdGhlIHZhbHVlcyBcImNoYWluSWRcIiwgXCJuZXR3b3JrSWRcIiwgXCJnYXNQcmljZVwiLCBvciBcIm5vbmNlXCIgY291bGRuXFwndCBiZSBmZXRjaGVkOiAnICsgSlNPTi5zdHJpbmdpZnkoYXJncykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaWduZWQoe1xuICAgICAgICAgICAgLi4udHgsXG4gICAgICAgICAgICAuLi4oKGlzTm90KHR4LmNvbW1vbikgfHwgaXNOb3QodHguY29tbW9uLmN1c3RvbUNoYWluLmNoYWluSWQpKSA/IHsgY2hhaW5JZDogdHhjaGFpbklkIH0gOiB7fSksXG4gICAgICAgICAgICBub25jZTogdHhub25jZSxcbiAgICAgICAgICAgIG5ldHdvcmtJZDogdHhuZXR3b3JrSWQsXG4gICAgICAgICAgICAuLi50eGdhc0luZm8gLy8gV2lsbCBlaXRoZXIgYmUgZ2FzUHJpY2Ugb3IgbWF4RmVlUGVyR2FzIGFuZCBtYXhQcmlvcml0eUZlZVBlckdhc1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBfdmFsaWRhdGVUcmFuc2FjdGlvbkZvclNpZ25pbmcodHgpIHtcbiAgICBpZiAodHguY29tbW9uICYmICh0eC5jaGFpbiAmJiB0eC5oYXJkZm9yaykpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignUGxlYXNlIHByb3ZpZGUgdGhlIEBldGhlcmV1bWpzL2NvbW1vbiBvYmplY3Qgb3IgdGhlIGNoYWluIGFuZCBoYXJkZm9yayBwcm9wZXJ0eSBidXQgbm90IGFsbCB0b2dldGhlci4nKTtcbiAgICB9XG4gICAgaWYgKCh0eC5jaGFpbiAmJiAhdHguaGFyZGZvcmspIHx8ICh0eC5oYXJkZm9yayAmJiAhdHguY2hhaW4pKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1doZW4gc3BlY2lmeWluZyBjaGFpbiBhbmQgaGFyZGZvcmssIGJvdGggdmFsdWVzIG11c3QgYmUgZGVmaW5lZC4gJyArXG4gICAgICAgICAgICAnUmVjZWl2ZWQgXCJjaGFpblwiOiAnICsgdHguY2hhaW4gKyAnLCBcImhhcmRmb3JrXCI6ICcgKyB0eC5oYXJkZm9yayk7XG4gICAgfVxuICAgIGlmICgoIXR4LmdhcyAmJiAhdHguZ2FzTGltaXQpICYmXG4gICAgICAgICghdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgJiYgIXR4Lm1heEZlZVBlckdhcykpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignXCJnYXNcIiBpcyBtaXNzaW5nJyk7XG4gICAgfVxuICAgIGlmICh0eC5nYXMgJiYgdHguZ2FzUHJpY2UpIHtcbiAgICAgICAgaWYgKHR4LmdhcyA8IDAgfHwgdHguZ2FzUHJpY2UgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdHYXMgb3IgZ2FzUHJpY2UgaXMgbG93ZXIgdGhhbiAwJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICh0eC5tYXhQcmlvcml0eUZlZVBlckdhcyA8IDAgfHwgdHgubWF4RmVlUGVyR2FzIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignbWF4UHJpb3JpdHlGZWVQZXJHYXMgb3IgbWF4RmVlUGVyR2FzIGlzIGxvd2VyIHRoYW4gMCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eC5ub25jZSA8IDAgfHwgdHguY2hhaW5JZCA8IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignTm9uY2Ugb3IgY2hhaW5JZCBpcyBsb3dlciB0aGFuIDAnKTtcbiAgICB9XG4gICAgcmV0dXJuO1xufVxuZnVuY3Rpb24gX2hhbmRsZVR4VHlwZSh0eCkge1xuICAgIC8vIFRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2V0aGVycy1pby9ldGhlcnMuanMvYmxvYi8yYTdjZTBlNzJhMWUwYzk0NjllMTAzOTJiMDMyOWU3NWUzNDFjZjE4L3BhY2thZ2VzL2Fic3RyYWN0LXNpZ25lci9zcmMudHMvaW5kZXgudHMjTDIxNVxuICAgIGNvbnN0IGhhc0VpcDE1NTkgPSAodHgubWF4RmVlUGVyR2FzICE9PSB1bmRlZmluZWQgfHwgdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT09IHVuZGVmaW5lZCk7XG4gICAgbGV0IHR4VHlwZTtcbiAgICBpZiAodHgudHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHR4VHlwZSA9IHV0aWxzLnRvSGV4KHR4LnR5cGUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eC50eXBlID09PSB1bmRlZmluZWQgJiYgaGFzRWlwMTU1OSkge1xuICAgICAgICB0eFR5cGUgPSAnMHgyJztcbiAgICB9XG4gICAgaWYgKHR4Lmdhc1ByaWNlICE9PSB1bmRlZmluZWQgJiYgKHR4VHlwZSA9PT0gJzB4MicgfHwgaGFzRWlwMTU1OSkpXG4gICAgICAgIHRocm93IEVycm9yKFwiZWlwLTE1NTkgdHJhbnNhY3Rpb25zIGRvbid0IHN1cHBvcnQgZ2FzUHJpY2VcIik7XG4gICAgaWYgKCh0eFR5cGUgPT09ICcweDEnIHx8IHR4VHlwZSA9PT0gJzB4MCcpICYmIGhhc0VpcDE1NTkpXG4gICAgICAgIHRocm93IEVycm9yKFwicHJlLWVpcC0xNTU5IHRyYW5zYWN0aW9uIGRvbid0IHN1cHBvcnQgbWF4RmVlUGVyR2FzL21heFByaW9yaXR5RmVlUGVyR2FzXCIpO1xuICAgIGlmIChoYXNFaXAxNTU5IHx8XG4gICAgICAgICgodHguY29tbW9uICYmIHR4LmNvbW1vbi5oYXJkZm9yayAmJiB0eC5jb21tb24uaGFyZGZvcmsudG9Mb3dlckNhc2UoKSA9PT0gSGFyZEZvcmtzLkxvbmRvbikgfHxcbiAgICAgICAgICAgICh0eC5oYXJkZm9yayAmJiB0eC5oYXJkZm9yay50b0xvd2VyQ2FzZSgpID09PSBIYXJkRm9ya3MuTG9uZG9uKSkpIHtcbiAgICAgICAgdHhUeXBlID0gJzB4Mic7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR4LmFjY2Vzc0xpc3QgfHxcbiAgICAgICAgKCh0eC5jb21tb24gJiYgdHguY29tbW9uLmhhcmRmb3JrICYmIHR4LmNvbW1vbi5oYXJkZm9yay50b0xvd2VyQ2FzZSgpID09PSBIYXJkRm9ya3MuQmVybGluKSB8fFxuICAgICAgICAgICAgKHR4LmhhcmRmb3JrICYmIHR4LmhhcmRmb3JrLnRvTG93ZXJDYXNlKCkgPT09IEhhcmRGb3Jrcy5CZXJsaW4pKSkge1xuICAgICAgICB0eFR5cGUgPSAnMHgxJztcbiAgICB9XG4gICAgcmV0dXJuIHR4VHlwZTtcbn1cbmZ1bmN0aW9uIF9oYW5kbGVUeFByaWNpbmcoX3RoaXMsIHR4KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICgodHgudHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR4LnR5cGUgPCAnMHgyJylcbiAgICAgICAgICAgICAgICAmJiB0eC5nYXNQcmljZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gTGVnYWN5IHRyYW5zYWN0aW9uLCByZXR1cm4gcHJvdmlkZWQgZ2FzUHJpY2VcbiAgICAgICAgICAgICAgICByZXNvbHZlKHsgZ2FzUHJpY2U6IHR4Lmdhc1ByaWNlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHgudHlwZSA9PT0gJzB4MicgJiYgdHgubWF4RmVlUGVyR2FzICYmIHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzKSB7XG4gICAgICAgICAgICAgICAgLy8gRUlQLTE1NTkgdHJhbnNhY3Rpb24sIHJldHVybiBwcm92aWRlZCBtYXhGZWVQZXJHYXMgYW5kIG1heFByaW9yaXR5RmVlUGVyR2FzXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh7IG1heEZlZVBlckdhczogdHgubWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhczogdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9ldGhlcmV1bUNhbGwuZ2V0QmxvY2tCeU51bWJlcigpLFxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZXRoZXJldW1DYWxsLmdldEdhc1ByaWNlKClcbiAgICAgICAgICAgICAgICBdKS50aGVuKHJlc3BvbnNlcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtibG9jaywgZ2FzUHJpY2VdID0gcmVzcG9uc2VzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHR4LnR5cGUgPT09ICcweDInKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2sgJiYgYmxvY2suYmFzZUZlZVBlckdhcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG5ldHdvcmsgc3VwcG9ydHMgRUlQLTE1NTlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2V0aGVycy1pby9ldGhlcnMuanMvYmxvYi9iYTY4NTRiZGQ1YTkxMmZlODczZDVkYTQ5NGNiNWM2MmMxOTBhZGRlL3BhY2thZ2VzL2Fic3RyYWN0LXByb3ZpZGVyL3NyYy50cy9pbmRleC50cyNMMjMwXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWF4UHJpb3JpdHlGZWVQZXJHYXMsIG1heEZlZVBlckdhcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5nYXNQcmljZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzaW5nIGxlZ2FjeSBnYXNQcmljZSBwcm9wZXJ0eSBvbiBhbiBlaXAtMTU1OSBuZXR3b3JrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIHVzZSBnYXNQcmljZSBhcyBib3RoIGZlZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXMgPSB0eC5nYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhGZWVQZXJHYXMgPSB0eC5nYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdHguZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyA9IHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzIHx8ICcweDk1MDJGOTAwJzsgLy8gMi41IEd3ZWlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhGZWVQZXJHYXMgPSB0eC5tYXhGZWVQZXJHYXMgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbHMudG9IZXgodXRpbHMudG9CTihibG9jay5iYXNlRmVlUGVyR2FzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm11bCh1dGlscy50b0JOKDIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZCh1dGlscy50b0JOKG1heFByaW9yaXR5RmVlUGVyR2FzKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IG1heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXMgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgfHwgdHgubWF4RmVlUGVyR2FzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiTmV0d29yayBkb2Vzbid0IHN1cHBvcnQgZWlwLTE1NTlcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHsgZ2FzUHJpY2UgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbkFjY291bnRzLnByb3RvdHlwZS5yZWNvdmVyVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiByZWNvdmVyVHJhbnNhY3Rpb24ocmF3VHgsIHR4T3B0aW9ucyA9IHt9KSB7XG4gICAgLy8gUmVseSBvbiBFdGhlcmV1bUpzL3R4IHRvIGRldGVybWluZSB0aGUgdHlwZSBvZiB0cmFuc2FjdGlvblxuICAgIGNvbnN0IGRhdGEgPSBCdWZmZXIuZnJvbShyYXdUeC5zbGljZSgyKSwgXCJoZXhcIik7XG4gICAgY29uc3QgdHggPSBUcmFuc2FjdGlvbkZhY3RvcnkuZnJvbVNlcmlhbGl6ZWREYXRhKGRhdGEpO1xuICAgIC8vdXBkYXRlIGNoZWNrc3VtXG4gICAgcmV0dXJuIHV0aWxzLnRvQ2hlY2tzdW1BZGRyZXNzKHR4LmdldFNlbmRlckFkZHJlc3MoKS50b1N0cmluZyhcImhleFwiKSk7XG59O1xuLyoganNoaW50IGlnbm9yZTplbmQgKi9cbkFjY291bnRzLnByb3RvdHlwZS5oYXNoTWVzc2FnZSA9IGZ1bmN0aW9uIGhhc2hNZXNzYWdlKGRhdGEpIHtcbiAgICB2YXIgbWVzc2FnZUhleCA9IHV0aWxzLmlzSGV4U3RyaWN0KGRhdGEpID8gZGF0YSA6IHV0aWxzLnV0ZjhUb0hleChkYXRhKTtcbiAgICB2YXIgbWVzc2FnZUJ5dGVzID0gdXRpbHMuaGV4VG9CeXRlcyhtZXNzYWdlSGV4KTtcbiAgICB2YXIgbWVzc2FnZUJ1ZmZlciA9IEJ1ZmZlci5mcm9tKG1lc3NhZ2VCeXRlcyk7XG4gICAgdmFyIHByZWFtYmxlID0gJ1xceDE5RXRoZXJldW0gU2lnbmVkIE1lc3NhZ2U6XFxuJyArIG1lc3NhZ2VCeXRlcy5sZW5ndGg7XG4gICAgdmFyIHByZWFtYmxlQnVmZmVyID0gQnVmZmVyLmZyb20ocHJlYW1ibGUpO1xuICAgIHZhciBldGhNZXNzYWdlID0gQnVmZmVyLmNvbmNhdChbcHJlYW1ibGVCdWZmZXIsIG1lc3NhZ2VCdWZmZXJdKTtcbiAgICByZXR1cm4gZXRoZXJldW1qc1V0aWwuYnVmZmVyVG9IZXgoZXRoZXJldW1qc1V0aWwua2VjY2FrMjU2KGV0aE1lc3NhZ2UpKTtcbn07XG5BY2NvdW50cy5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uIHNpZ24oZGF0YSwgcHJpdmF0ZUtleSkge1xuICAgIGlmICghcHJpdmF0ZUtleS5zdGFydHNXaXRoKCcweCcpKSB7XG4gICAgICAgIHByaXZhdGVLZXkgPSAnMHgnICsgcHJpdmF0ZUtleTtcbiAgICB9XG4gICAgLy8gNjQgaGV4IGNoYXJhY3RlcnMgKyBoZXgtcHJlZml4XG4gICAgaWYgKHByaXZhdGVLZXkubGVuZ3RoICE9PSA2Nikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcml2YXRlIGtleSBtdXN0IGJlIDMyIGJ5dGVzIGxvbmdcIik7XG4gICAgfVxuICAgIHZhciBoYXNoID0gdGhpcy5oYXNoTWVzc2FnZShkYXRhKTtcbiAgICB2YXIgc2lnbmF0dXJlID0gQWNjb3VudC5zaWduKGhhc2gsIHByaXZhdGVLZXkpO1xuICAgIHZhciB2cnMgPSBBY2NvdW50LmRlY29kZVNpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG1lc3NhZ2U6IGRhdGEsXG4gICAgICAgIG1lc3NhZ2VIYXNoOiBoYXNoLFxuICAgICAgICB2OiB2cnNbMF0sXG4gICAgICAgIHI6IHZyc1sxXSxcbiAgICAgICAgczogdnJzWzJdLFxuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVxuICAgIH07XG59O1xuQWNjb3VudHMucHJvdG90eXBlLnJlY292ZXIgPSBmdW5jdGlvbiByZWNvdmVyKG1lc3NhZ2UsIHNpZ25hdHVyZSwgcHJlRml4ZWQpIHtcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmFwcGx5KGFyZ3VtZW50cyk7XG4gICAgaWYgKCEhbWVzc2FnZSAmJiB0eXBlb2YgbWVzc2FnZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjb3ZlcihtZXNzYWdlLm1lc3NhZ2VIYXNoLCBBY2NvdW50LmVuY29kZVNpZ25hdHVyZShbbWVzc2FnZS52LCBtZXNzYWdlLnIsIG1lc3NhZ2Uuc10pLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKCFwcmVGaXhlZCkge1xuICAgICAgICBtZXNzYWdlID0gdGhpcy5oYXNoTWVzc2FnZShtZXNzYWdlKTtcbiAgICB9XG4gICAgaWYgKGFyZ3MubGVuZ3RoID49IDQpIHtcbiAgICAgICAgcHJlRml4ZWQgPSBhcmdzLnNsaWNlKC0xKVswXTtcbiAgICAgICAgcHJlRml4ZWQgPSB0eXBlb2YgcHJlRml4ZWQgPT09ICdib29sZWFuJyA/ICEhcHJlRml4ZWQgOiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjb3ZlcihtZXNzYWdlLCBBY2NvdW50LmVuY29kZVNpZ25hdHVyZShhcmdzLnNsaWNlKDEsIDQpKSwgcHJlRml4ZWQpOyAvLyB2LCByLCBzXG4gICAgfVxuICAgIHJldHVybiBBY2NvdW50LnJlY292ZXIobWVzc2FnZSwgc2lnbmF0dXJlKTtcbn07XG4vLyBUYWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bWpzL2V0aGVyZXVtanMtd2FsbGV0XG5BY2NvdW50cy5wcm90b3R5cGUuZGVjcnlwdCA9IGZ1bmN0aW9uICh2M0tleXN0b3JlLCBwYXNzd29yZCwgbm9uU3RyaWN0KSB7XG4gICAgLyoganNoaW50IG1heGNvbXBsZXhpdHk6IDEwICovXG4gICAgaWYgKCEodHlwZW9mIHBhc3N3b3JkID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwYXNzd29yZCBnaXZlbi4nKTtcbiAgICB9XG4gICAgdmFyIGpzb24gPSAoISF2M0tleXN0b3JlICYmIHR5cGVvZiB2M0tleXN0b3JlID09PSAnb2JqZWN0JykgPyB2M0tleXN0b3JlIDogSlNPTi5wYXJzZShub25TdHJpY3QgPyB2M0tleXN0b3JlLnRvTG93ZXJDYXNlKCkgOiB2M0tleXN0b3JlKTtcbiAgICBpZiAoanNvbi52ZXJzaW9uICE9PSAzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGEgdmFsaWQgVjMgd2FsbGV0Jyk7XG4gICAgfVxuICAgIHZhciBkZXJpdmVkS2V5O1xuICAgIHZhciBrZGZwYXJhbXM7XG4gICAgaWYgKGpzb24uY3J5cHRvLmtkZiA9PT0gJ3NjcnlwdCcpIHtcbiAgICAgICAga2RmcGFyYW1zID0ganNvbi5jcnlwdG8ua2RmcGFyYW1zO1xuICAgICAgICAvLyBGSVhNRTogc3VwcG9ydCBwcm9ncmVzcyByZXBvcnRpbmcgY2FsbGJhY2tcbiAgICAgICAgZGVyaXZlZEtleSA9IHNjcnlwdC5zeW5jU2NyeXB0KEJ1ZmZlci5mcm9tKHBhc3N3b3JkKSwgQnVmZmVyLmZyb20oa2RmcGFyYW1zLnNhbHQsICdoZXgnKSwga2RmcGFyYW1zLm4sIGtkZnBhcmFtcy5yLCBrZGZwYXJhbXMucCwga2RmcGFyYW1zLmRrbGVuKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoanNvbi5jcnlwdG8ua2RmID09PSAncGJrZGYyJykge1xuICAgICAgICBrZGZwYXJhbXMgPSBqc29uLmNyeXB0by5rZGZwYXJhbXM7XG4gICAgICAgIGlmIChrZGZwYXJhbXMucHJmICE9PSAnaG1hYy1zaGEyNTYnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHBhcmFtZXRlcnMgdG8gUEJLREYyJyk7XG4gICAgICAgIH1cbiAgICAgICAgZGVyaXZlZEtleSA9IGNyeXAucGJrZGYyU3luYyhCdWZmZXIuZnJvbShwYXNzd29yZCksIEJ1ZmZlci5mcm9tKGtkZnBhcmFtcy5zYWx0LCAnaGV4JyksIGtkZnBhcmFtcy5jLCBrZGZwYXJhbXMuZGtsZW4sICdzaGEyNTYnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQga2V5IGRlcml2YXRpb24gc2NoZW1lJyk7XG4gICAgfVxuICAgIHZhciBjaXBoZXJ0ZXh0ID0gQnVmZmVyLmZyb20oanNvbi5jcnlwdG8uY2lwaGVydGV4dCwgJ2hleCcpO1xuICAgIHZhciBtYWMgPSB1dGlscy5zaGEzKEJ1ZmZlci5mcm9tKFsuLi5kZXJpdmVkS2V5LnNsaWNlKDE2LCAzMiksIC4uLmNpcGhlcnRleHRdKSkucmVwbGFjZSgnMHgnLCAnJyk7XG4gICAgaWYgKG1hYyAhPT0ganNvbi5jcnlwdG8ubWFjKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignS2V5IGRlcml2YXRpb24gZmFpbGVkIC0gcG9zc2libHkgd3JvbmcgcGFzc3dvcmQnKTtcbiAgICB9XG4gICAgdmFyIGRlY2lwaGVyID0gY3J5cC5jcmVhdGVEZWNpcGhlcml2KGpzb24uY3J5cHRvLmNpcGhlciwgZGVyaXZlZEtleS5zbGljZSgwLCAxNiksIEJ1ZmZlci5mcm9tKGpzb24uY3J5cHRvLmNpcGhlcnBhcmFtcy5pdiwgJ2hleCcpKTtcbiAgICB2YXIgc2VlZCA9ICcweCcgKyBCdWZmZXIuZnJvbShbLi4uZGVjaXBoZXIudXBkYXRlKGNpcGhlcnRleHQpLCAuLi5kZWNpcGhlci5maW5hbCgpXSkudG9TdHJpbmcoJ2hleCcpO1xuICAgIHJldHVybiB0aGlzLnByaXZhdGVLZXlUb0FjY291bnQoc2VlZCwgdHJ1ZSk7XG59O1xuQWNjb3VudHMucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSwgcGFzc3dvcmQsIG9wdGlvbnMpIHtcbiAgICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eTogMjAgKi9cbiAgICB2YXIgYWNjb3VudCA9IHRoaXMucHJpdmF0ZUtleVRvQWNjb3VudChwcml2YXRlS2V5LCB0cnVlKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgc2FsdCA9IG9wdGlvbnMuc2FsdCB8fCBjcnlwLnJhbmRvbUJ5dGVzKDMyKTtcbiAgICB2YXIgaXYgPSBvcHRpb25zLml2IHx8IGNyeXAucmFuZG9tQnl0ZXMoMTYpO1xuICAgIHZhciBkZXJpdmVkS2V5O1xuICAgIHZhciBrZGYgPSBvcHRpb25zLmtkZiB8fCAnc2NyeXB0JztcbiAgICB2YXIga2RmcGFyYW1zID0ge1xuICAgICAgICBka2xlbjogb3B0aW9ucy5ka2xlbiB8fCAzMixcbiAgICAgICAgc2FsdDogc2FsdC50b1N0cmluZygnaGV4JylcbiAgICB9O1xuICAgIGlmIChrZGYgPT09ICdwYmtkZjInKSB7XG4gICAgICAgIGtkZnBhcmFtcy5jID0gb3B0aW9ucy5jIHx8IDI2MjE0NDtcbiAgICAgICAga2RmcGFyYW1zLnByZiA9ICdobWFjLXNoYTI1Nic7XG4gICAgICAgIGRlcml2ZWRLZXkgPSBjcnlwLnBia2RmMlN5bmMoQnVmZmVyLmZyb20ocGFzc3dvcmQpLCBCdWZmZXIuZnJvbShrZGZwYXJhbXMuc2FsdCwgJ2hleCcpLCBrZGZwYXJhbXMuYywga2RmcGFyYW1zLmRrbGVuLCAnc2hhMjU2Jyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtkZiA9PT0gJ3NjcnlwdCcpIHtcbiAgICAgICAgLy8gRklYTUU6IHN1cHBvcnQgcHJvZ3Jlc3MgcmVwb3J0aW5nIGNhbGxiYWNrXG4gICAgICAgIGtkZnBhcmFtcy5uID0gb3B0aW9ucy5uIHx8IDgxOTI7IC8vIDIwNDggNDA5NiA4MTkyIDE2Mzg0XG4gICAgICAgIGtkZnBhcmFtcy5yID0gb3B0aW9ucy5yIHx8IDg7XG4gICAgICAgIGtkZnBhcmFtcy5wID0gb3B0aW9ucy5wIHx8IDE7XG4gICAgICAgIGRlcml2ZWRLZXkgPSBzY3J5cHQuc3luY1NjcnlwdChCdWZmZXIuZnJvbShwYXNzd29yZCksIEJ1ZmZlci5mcm9tKGtkZnBhcmFtcy5zYWx0LCAnaGV4JyksIGtkZnBhcmFtcy5uLCBrZGZwYXJhbXMuciwga2RmcGFyYW1zLnAsIGtkZnBhcmFtcy5ka2xlbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGtkZicpO1xuICAgIH1cbiAgICB2YXIgY2lwaGVyID0gY3J5cC5jcmVhdGVDaXBoZXJpdihvcHRpb25zLmNpcGhlciB8fCAnYWVzLTEyOC1jdHInLCBkZXJpdmVkS2V5LnNsaWNlKDAsIDE2KSwgaXYpO1xuICAgIGlmICghY2lwaGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgY2lwaGVyJyk7XG4gICAgfVxuICAgIHZhciBjaXBoZXJ0ZXh0ID0gQnVmZmVyLmZyb20oW1xuICAgICAgICAuLi5jaXBoZXIudXBkYXRlKEJ1ZmZlci5mcm9tKGFjY291bnQucHJpdmF0ZUtleS5yZXBsYWNlKCcweCcsICcnKSwgJ2hleCcpKSxcbiAgICAgICAgLi4uY2lwaGVyLmZpbmFsKClcbiAgICBdKTtcbiAgICB2YXIgbWFjID0gdXRpbHMuc2hhMyhCdWZmZXIuZnJvbShbLi4uZGVyaXZlZEtleS5zbGljZSgxNiwgMzIpLCAuLi5jaXBoZXJ0ZXh0XSkpLnJlcGxhY2UoJzB4JywgJycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHZlcnNpb246IDMsXG4gICAgICAgIGlkOiB1dWlkLnY0KHsgcmFuZG9tOiBvcHRpb25zLnV1aWQgfHwgY3J5cC5yYW5kb21CeXRlcygxNikgfSksXG4gICAgICAgIGFkZHJlc3M6IGFjY291bnQuYWRkcmVzcy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJzB4JywgJycpLFxuICAgICAgICBjcnlwdG86IHtcbiAgICAgICAgICAgIGNpcGhlcnRleHQ6IGNpcGhlcnRleHQudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgICAgY2lwaGVycGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgaXY6IGl2LnRvU3RyaW5nKCdoZXgnKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNpcGhlcjogb3B0aW9ucy5jaXBoZXIgfHwgJ2Flcy0xMjgtY3RyJyxcbiAgICAgICAgICAgIGtkZjoga2RmLFxuICAgICAgICAgICAga2RmcGFyYW1zOiBrZGZwYXJhbXMsXG4gICAgICAgICAgICBtYWM6IG1hYy50b1N0cmluZygnaGV4JylcbiAgICAgICAgfVxuICAgIH07XG59O1xuLy8gTm90ZTogdGhpcyBpcyB0cnlpbmcgdG8gZm9sbG93IGNsb3NlbHkgdGhlIHNwZWNzIG9uXG4vLyBodHRwOi8vd2ViM2pzLnJlYWR0aGVkb2NzLmlvL2VuLzEuMC93ZWIzLWV0aC1hY2NvdW50cy5odG1sXG5mdW5jdGlvbiBXYWxsZXQoYWNjb3VudHMpIHtcbiAgICB0aGlzLl9hY2NvdW50cyA9IGFjY291bnRzO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLmRlZmF1bHRLZXlOYW1lID0gJ3dlYjNqc193YWxsZXQnO1xufVxuV2FsbGV0LnByb3RvdHlwZS5fZmluZFNhZmVJbmRleCA9IGZ1bmN0aW9uIChwb2ludGVyKSB7XG4gICAgcG9pbnRlciA9IHBvaW50ZXIgfHwgMDtcbiAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShwb2ludGVyKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmluZFNhZmVJbmRleChwb2ludGVyICsgMSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcG9pbnRlcjtcbiAgICB9XG59O1xuV2FsbGV0LnByb3RvdHlwZS5fY3VycmVudEluZGV4ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgICB2YXIgaW5kZXhlcyA9IGtleXNcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChrZXkpO1xuICAgIH0pXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIChuIDwgOWUyMCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGluZGV4ZXM7XG59O1xuV2FsbGV0LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAobnVtYmVyT2ZBY2NvdW50cywgZW50cm9weSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtYmVyT2ZBY2NvdW50czsgKytpKSB7XG4gICAgICAgIHRoaXMuYWRkKHRoaXMuX2FjY291bnRzLmNyZWF0ZShlbnRyb3B5KS5wcml2YXRlS2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuV2FsbGV0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoYWNjb3VudCkge1xuICAgIGlmICh0eXBlb2YgYWNjb3VudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYWNjb3VudCA9IHRoaXMuX2FjY291bnRzLnByaXZhdGVLZXlUb0FjY291bnQoYWNjb3VudCk7XG4gICAgfVxuICAgIGlmICghdGhpc1thY2NvdW50LmFkZHJlc3NdKSB7XG4gICAgICAgIGFjY291bnQgPSB0aGlzLl9hY2NvdW50cy5wcml2YXRlS2V5VG9BY2NvdW50KGFjY291bnQucHJpdmF0ZUtleSk7XG4gICAgICAgIGFjY291bnQuaW5kZXggPSB0aGlzLl9maW5kU2FmZUluZGV4KCk7XG4gICAgICAgIHRoaXNbYWNjb3VudC5pbmRleF0gPSBhY2NvdW50O1xuICAgICAgICB0aGlzW2FjY291bnQuYWRkcmVzc10gPSBhY2NvdW50O1xuICAgICAgICB0aGlzW2FjY291bnQuYWRkcmVzcy50b0xvd2VyQ2FzZSgpXSA9IGFjY291bnQ7XG4gICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgICAgIHJldHVybiBhY2NvdW50O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbYWNjb3VudC5hZGRyZXNzXTtcbiAgICB9XG59O1xuV2FsbGV0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoYWRkcmVzc09ySW5kZXgpIHtcbiAgICB2YXIgYWNjb3VudCA9IHRoaXNbYWRkcmVzc09ySW5kZXhdO1xuICAgIGlmIChhY2NvdW50ICYmIGFjY291bnQuYWRkcmVzcykge1xuICAgICAgICAvLyBhZGRyZXNzXG4gICAgICAgIHRoaXNbYWNjb3VudC5hZGRyZXNzXS5wcml2YXRlS2V5ID0gbnVsbDtcbiAgICAgICAgZGVsZXRlIHRoaXNbYWNjb3VudC5hZGRyZXNzXTtcbiAgICAgICAgLy8gYWRkcmVzcyBsb3dlcmNhc2VcbiAgICAgICAgaWYgKHRoaXNbYWNjb3VudC5hZGRyZXNzLnRvTG93ZXJDYXNlKCldKSB7XG4gICAgICAgICAgICB0aGlzW2FjY291bnQuYWRkcmVzcy50b0xvd2VyQ2FzZSgpXS5wcml2YXRlS2V5ID0gbnVsbDtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzW2FjY291bnQuYWRkcmVzcy50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbmRleFxuICAgICAgICB0aGlzW2FjY291bnQuaW5kZXhdLnByaXZhdGVLZXkgPSBudWxsO1xuICAgICAgICBkZWxldGUgdGhpc1thY2NvdW50LmluZGV4XTtcbiAgICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbldhbGxldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgaW5kZXhlcyA9IHRoaXMuX2N1cnJlbnRJbmRleGVzKCk7XG4gICAgaW5kZXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBfdGhpcy5yZW1vdmUoaW5kZXgpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xufTtcbldhbGxldC5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uIChwYXNzd29yZCwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGluZGV4ZXMgPSB0aGlzLl9jdXJyZW50SW5kZXhlcygpO1xuICAgIHZhciBhY2NvdW50cyA9IGluZGV4ZXMubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICByZXR1cm4gX3RoaXNbaW5kZXhdLmVuY3J5cHQocGFzc3dvcmQsIG9wdGlvbnMpO1xuICAgIH0pO1xuICAgIHJldHVybiBhY2NvdW50cztcbn07XG5XYWxsZXQucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbiAoZW5jcnlwdGVkV2FsbGV0LCBwYXNzd29yZCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgZW5jcnlwdGVkV2FsbGV0LmZvckVhY2goZnVuY3Rpb24gKGtleXN0b3JlKSB7XG4gICAgICAgIHZhciBhY2NvdW50ID0gX3RoaXMuX2FjY291bnRzLmRlY3J5cHQoa2V5c3RvcmUsIHBhc3N3b3JkKTtcbiAgICAgICAgaWYgKGFjY291bnQpIHtcbiAgICAgICAgICAgIF90aGlzLmFkZChhY2NvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGRuXFwndCBkZWNyeXB0IGFjY291bnRzLiBQYXNzd29yZCB3cm9uZz8nKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xufTtcbldhbGxldC5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uIChwYXNzd29yZCwga2V5TmFtZSkge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleU5hbWUgfHwgdGhpcy5kZWZhdWx0S2V5TmFtZSwgSlNPTi5zdHJpbmdpZnkodGhpcy5lbmNyeXB0KHBhc3N3b3JkKSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbldhbGxldC5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChwYXNzd29yZCwga2V5TmFtZSkge1xuICAgIHZhciBrZXlzdG9yZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleU5hbWUgfHwgdGhpcy5kZWZhdWx0S2V5TmFtZSk7XG4gICAgaWYgKGtleXN0b3JlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBrZXlzdG9yZSA9IEpTT04ucGFyc2Uoa2V5c3RvcmUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGVjcnlwdChrZXlzdG9yZSB8fCBbXSwgcGFzc3dvcmQpO1xufTtcbmlmICghc3RvcmFnZUF2YWlsYWJsZSgnbG9jYWxTdG9yYWdlJykpIHtcbiAgICBkZWxldGUgV2FsbGV0LnByb3RvdHlwZS5zYXZlO1xuICAgIGRlbGV0ZSBXYWxsZXQucHJvdG90eXBlLmxvYWQ7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgc3RvcmFnZSB0eXBlIGlzIGF2YWlsYWJsZSBvciBub3RcbiAqIEZvciBtb3JlIGluZm8gb24gaG93IHRoaXMgd29ya3MsIHBsZWFzZSByZWZlciB0byBNRE4gZG9jdW1lbnRhdGlvblxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYl9TdG9yYWdlX0FQSS9Vc2luZ190aGVfV2ViX1N0b3JhZ2VfQVBJI0ZlYXR1cmUtZGV0ZWN0aW5nX2xvY2FsU3RvcmFnZVxuICpcbiAqIEBtZXRob2Qgc3RvcmFnZUF2YWlsYWJsZVxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgb2Ygc3RvcmFnZSAoJ2xvY2FsU3RvcmFnZScsICdzZXNzaW9uU3RvcmFnZScpXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgc3BlY2lmaWVkIHN0b3JhZ2UgaXMgYXZhaWxhYmxlIG9yIG5vdFxuICovXG5mdW5jdGlvbiBzdG9yYWdlQXZhaWxhYmxlKHR5cGUpIHtcbiAgICB2YXIgc3RvcmFnZTtcbiAgICB0cnkge1xuICAgICAgICBzdG9yYWdlID0gc2VsZlt0eXBlXTtcbiAgICAgICAgdmFyIHggPSAnX19zdG9yYWdlX3Rlc3RfXyc7XG4gICAgICAgIHN0b3JhZ2Uuc2V0SXRlbSh4LCB4KTtcbiAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKHgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGUgJiYgKFxuICAgICAgICAvLyBldmVyeXRoaW5nIGV4Y2VwdCBGaXJlZm94XG4gICAgICAgIGUuY29kZSA9PT0gMjIgfHxcbiAgICAgICAgICAgIC8vIEZpcmVmb3hcbiAgICAgICAgICAgIGUuY29kZSA9PT0gMTAxNCB8fFxuICAgICAgICAgICAgLy8gdGVzdCBuYW1lIGZpZWxkIHRvbywgYmVjYXVzZSBjb2RlIG1pZ2h0IG5vdCBiZSBwcmVzZW50XG4gICAgICAgICAgICAvLyBldmVyeXRoaW5nIGV4Y2VwdCBGaXJlZm94XG4gICAgICAgICAgICBlLm5hbWUgPT09ICdRdW90YUV4Y2VlZGVkRXJyb3InIHx8XG4gICAgICAgICAgICAvLyBGaXJlZm94XG4gICAgICAgICAgICBlLm5hbWUgPT09ICdOU19FUlJPUl9ET01fUVVPVEFfUkVBQ0hFRCcpICYmXG4gICAgICAgICAgICAvLyBhY2tub3dsZWRnZSBRdW90YUV4Y2VlZGVkRXJyb3Igb25seSBpZiB0aGVyZSdzIHNvbWV0aGluZyBhbHJlYWR5IHN0b3JlZFxuICAgICAgICAgICAgKHN0b3JhZ2UgJiYgc3RvcmFnZS5sZW5ndGggIT09IDApO1xuICAgIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gQWNjb3VudHM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/web3-eth-accounts@1.10.0/node_modules/web3-eth-accounts/lib/index.js\n");

/***/ })

};
;