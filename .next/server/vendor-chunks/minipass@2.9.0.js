"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/minipass@2.9.0";
exports.ids = ["vendor-chunks/minipass@2.9.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/minipass@2.9.0/node_modules/minipass/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/.pnpm/minipass@2.9.0/node_modules/minipass/index.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst EE = __webpack_require__(/*! events */ \"events\")\nconst Yallist = __webpack_require__(/*! yallist */ \"(ssr)/./node_modules/.pnpm/yallist@3.1.1/node_modules/yallist/yallist.js\")\nconst SD = (__webpack_require__(/*! string_decoder */ \"string_decoder\").StringDecoder)\n\nconst EOF = Symbol('EOF')\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd')\nconst EMITTED_END = Symbol('emittedEnd')\nconst EMITTING_END = Symbol('emittingEnd')\nconst CLOSED = Symbol('closed')\nconst READ = Symbol('read')\nconst FLUSH = Symbol('flush')\nconst FLUSHCHUNK = Symbol('flushChunk')\nconst ENCODING = Symbol('encoding')\nconst DECODER = Symbol('decoder')\nconst FLOWING = Symbol('flowing')\nconst PAUSED = Symbol('paused')\nconst RESUME = Symbol('resume')\nconst BUFFERLENGTH = Symbol('bufferLength')\nconst BUFFERPUSH = Symbol('bufferPush')\nconst BUFFERSHIFT = Symbol('bufferShift')\nconst OBJECTMODE = Symbol('objectMode')\nconst DESTROYED = Symbol('destroyed')\n\n// TODO remove when Node v8 support drops\nconst doIter = global._MP_NO_ITERATOR_SYMBOLS_  !== '1'\nconst ASYNCITERATOR = doIter && Symbol.asyncIterator\n  || Symbol('asyncIterator not implemented')\nconst ITERATOR = doIter && Symbol.iterator\n  || Symbol('iterator not implemented')\n\n// Buffer in node 4.x < 4.5.0 doesn't have working Buffer.from\n// or Buffer.alloc, and Buffer in node 10 deprecated the ctor.\n// .M, this is fine .\\^/M..\nconst B = Buffer.alloc ? Buffer\n  : /* istanbul ignore next */ (__webpack_require__(/*! safe-buffer */ \"(ssr)/./node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js\").Buffer)\n\n// events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\nconst isEndish = ev =>\n  ev === 'end' ||\n  ev === 'finish' ||\n  ev === 'prefinish'\n\nconst isArrayBuffer = b => b instanceof ArrayBuffer ||\n  typeof b === 'object' &&\n  b.constructor &&\n  b.constructor.name === 'ArrayBuffer' &&\n  b.byteLength >= 0\n\nconst isArrayBufferView = b => !B.isBuffer(b) && ArrayBuffer.isView(b)\n\nmodule.exports = class Minipass extends EE {\n  constructor (options) {\n    super()\n    this[FLOWING] = false\n    // whether we're explicitly paused\n    this[PAUSED] = false\n    this.pipes = new Yallist()\n    this.buffer = new Yallist()\n    this[OBJECTMODE] = options && options.objectMode || false\n    if (this[OBJECTMODE])\n      this[ENCODING] = null\n    else\n      this[ENCODING] = options && options.encoding || null\n    if (this[ENCODING] === 'buffer')\n      this[ENCODING] = null\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null\n    this[EOF] = false\n    this[EMITTED_END] = false\n    this[EMITTING_END] = false\n    this[CLOSED] = false\n    this.writable = true\n    this.readable = true\n    this[BUFFERLENGTH] = 0\n    this[DESTROYED] = false\n  }\n\n  get bufferLength () { return this[BUFFERLENGTH] }\n\n  get encoding () { return this[ENCODING] }\n  set encoding (enc) {\n    if (this[OBJECTMODE])\n      throw new Error('cannot set encoding in objectMode')\n\n    if (this[ENCODING] && enc !== this[ENCODING] &&\n        (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))\n      throw new Error('cannot change encoding')\n\n    if (this[ENCODING] !== enc) {\n      this[DECODER] = enc ? new SD(enc) : null\n      if (this.buffer.length)\n        this.buffer = this.buffer.map(chunk => this[DECODER].write(chunk))\n    }\n\n    this[ENCODING] = enc\n  }\n\n  setEncoding (enc) {\n    this.encoding = enc\n  }\n\n  get objectMode () { return this[OBJECTMODE] }\n  set objectMode (ॐ ) { this[OBJECTMODE] = this[OBJECTMODE] || !!ॐ  }\n\n  write (chunk, encoding, cb) {\n    if (this[EOF])\n      throw new Error('write after end')\n\n    if (this[DESTROYED]) {\n      this.emit('error', Object.assign(\n        new Error('Cannot call write after a stream was destroyed'),\n        { code: 'ERR_STREAM_DESTROYED' }\n      ))\n      return true\n    }\n\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (!encoding)\n      encoding = 'utf8'\n\n    // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything else switches us into object mode\n    if (!this[OBJECTMODE] && !B.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk))\n        chunk = B.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)\n      else if (isArrayBuffer(chunk))\n        chunk = B.from(chunk)\n      else if (typeof chunk !== 'string')\n        // use the setter so we throw if we have encoding set\n        this.objectMode = true\n    }\n\n    // this ensures at this point that the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n    if (!this.objectMode && !chunk.length) {\n      const ret = this.flowing\n      if (this[BUFFERLENGTH] !== 0)\n        this.emit('readable')\n      if (cb)\n        cb()\n      return ret\n    }\n\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (typeof chunk === 'string' && !this[OBJECTMODE] &&\n        // unless it is a string already ready for us to use\n        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {\n      chunk = B.from(chunk, encoding)\n    }\n\n    if (B.isBuffer(chunk) && this[ENCODING])\n      chunk = this[DECODER].write(chunk)\n\n    try {\n      return this.flowing\n        ? (this.emit('data', chunk), this.flowing)\n        : (this[BUFFERPUSH](chunk), false)\n    } finally {\n      if (this[BUFFERLENGTH] !== 0)\n        this.emit('readable')\n      if (cb)\n        cb()\n    }\n  }\n\n  read (n) {\n    if (this[DESTROYED])\n      return null\n\n    try {\n      if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH])\n        return null\n\n      if (this[OBJECTMODE])\n        n = null\n\n      if (this.buffer.length > 1 && !this[OBJECTMODE]) {\n        if (this.encoding)\n          this.buffer = new Yallist([\n            Array.from(this.buffer).join('')\n          ])\n        else\n          this.buffer = new Yallist([\n            B.concat(Array.from(this.buffer), this[BUFFERLENGTH])\n          ])\n      }\n\n      return this[READ](n || null, this.buffer.head.value)\n    } finally {\n      this[MAYBE_EMIT_END]()\n    }\n  }\n\n  [READ] (n, chunk) {\n    if (n === chunk.length || n === null)\n      this[BUFFERSHIFT]()\n    else {\n      this.buffer.head.value = chunk.slice(n)\n      chunk = chunk.slice(0, n)\n      this[BUFFERLENGTH] -= n\n    }\n\n    this.emit('data', chunk)\n\n    if (!this.buffer.length && !this[EOF])\n      this.emit('drain')\n\n    return chunk\n  }\n\n  end (chunk, encoding, cb) {\n    if (typeof chunk === 'function')\n      cb = chunk, chunk = null\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n    if (chunk)\n      this.write(chunk, encoding)\n    if (cb)\n      this.once('end', cb)\n    this[EOF] = true\n    this.writable = false\n\n    // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n    if (this.flowing || !this[PAUSED])\n      this[MAYBE_EMIT_END]()\n    return this\n  }\n\n  // don't let the internal resume be overwritten\n  [RESUME] () {\n    if (this[DESTROYED])\n      return\n\n    this[PAUSED] = false\n    this[FLOWING] = true\n    this.emit('resume')\n    if (this.buffer.length)\n      this[FLUSH]()\n    else if (this[EOF])\n      this[MAYBE_EMIT_END]()\n    else\n      this.emit('drain')\n  }\n\n  resume () {\n    return this[RESUME]()\n  }\n\n  pause () {\n    this[FLOWING] = false\n    this[PAUSED] = true\n  }\n\n  get destroyed () {\n    return this[DESTROYED]\n  }\n\n  get flowing () {\n    return this[FLOWING]\n  }\n\n  get paused () {\n    return this[PAUSED]\n  }\n\n  [BUFFERPUSH] (chunk) {\n    if (this[OBJECTMODE])\n      this[BUFFERLENGTH] += 1\n    else\n      this[BUFFERLENGTH] += chunk.length\n    return this.buffer.push(chunk)\n  }\n\n  [BUFFERSHIFT] () {\n    if (this.buffer.length) {\n      if (this[OBJECTMODE])\n        this[BUFFERLENGTH] -= 1\n      else\n        this[BUFFERLENGTH] -= this.buffer.head.value.length\n    }\n    return this.buffer.shift()\n  }\n\n  [FLUSH] () {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()))\n\n    if (!this.buffer.length && !this[EOF])\n      this.emit('drain')\n  }\n\n  [FLUSHCHUNK] (chunk) {\n    return chunk ? (this.emit('data', chunk), this.flowing) : false\n  }\n\n  pipe (dest, opts) {\n    if (this[DESTROYED])\n      return\n\n    const ended = this[EMITTED_END]\n    opts = opts || {}\n    if (dest === process.stdout || dest === process.stderr)\n      opts.end = false\n    else\n      opts.end = opts.end !== false\n\n    const p = { dest: dest, opts: opts, ondrain: _ => this[RESUME]() }\n    this.pipes.push(p)\n\n    dest.on('drain', p.ondrain)\n    this[RESUME]()\n    // piping an ended stream ends immediately\n    if (ended && p.opts.end)\n      p.dest.end()\n    return dest\n  }\n\n  addListener (ev, fn) {\n    return this.on(ev, fn)\n  }\n\n  on (ev, fn) {\n    try {\n      return super.on(ev, fn)\n    } finally {\n      if (ev === 'data' && !this.pipes.length && !this.flowing)\n        this[RESUME]()\n      else if (isEndish(ev) && this[EMITTED_END]) {\n        super.emit(ev)\n        this.removeAllListeners(ev)\n      }\n    }\n  }\n\n  get emittedEnd () {\n    return this[EMITTED_END]\n  }\n\n  [MAYBE_EMIT_END] () {\n    if (!this[EMITTING_END] &&\n        !this[EMITTED_END] &&\n        !this[DESTROYED] &&\n        this.buffer.length === 0 &&\n        this[EOF]) {\n      this[EMITTING_END] = true\n      this.emit('end')\n      this.emit('prefinish')\n      this.emit('finish')\n      if (this[CLOSED])\n        this.emit('close')\n      this[EMITTING_END] = false\n    }\n  }\n\n  emit (ev, data) {\n    // error and close are only events allowed after calling destroy()\n    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED])\n      return\n    else if (ev === 'data') {\n      if (!data)\n        return\n\n      if (this.pipes.length)\n        this.pipes.forEach(p =>\n          p.dest.write(data) === false && this.pause())\n    } else if (ev === 'end') {\n      // only actual end gets this treatment\n      if (this[EMITTED_END] === true)\n        return\n\n      this[EMITTED_END] = true\n      this.readable = false\n\n      if (this[DECODER]) {\n        data = this[DECODER].end()\n        if (data) {\n          this.pipes.forEach(p => p.dest.write(data))\n          super.emit('data', data)\n        }\n      }\n\n      this.pipes.forEach(p => {\n        p.dest.removeListener('drain', p.ondrain)\n        if (p.opts.end)\n          p.dest.end()\n      })\n    } else if (ev === 'close') {\n      this[CLOSED] = true\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END] && !this[DESTROYED])\n        return\n    }\n\n    // TODO: replace with a spread operator when Node v4 support drops\n    const args = new Array(arguments.length)\n    args[0] = ev\n    args[1] = data\n    if (arguments.length > 2) {\n      for (let i = 2; i < arguments.length; i++) {\n        args[i] = arguments[i]\n      }\n    }\n\n    try {\n      return super.emit.apply(this, args)\n    } finally {\n      if (!isEndish(ev))\n        this[MAYBE_EMIT_END]()\n      else\n        this.removeAllListeners(ev)\n    }\n  }\n\n  // const all = await stream.collect()\n  collect () {\n    const buf = []\n    buf.dataLength = 0\n    this.on('data', c => {\n      buf.push(c)\n      buf.dataLength += c.length\n    })\n    return this.promise().then(() => buf)\n  }\n\n  // const data = await stream.concat()\n  concat () {\n    return this[OBJECTMODE]\n      ? Promise.reject(new Error('cannot concat in objectMode'))\n      : this.collect().then(buf =>\n          this[OBJECTMODE]\n            ? Promise.reject(new Error('cannot concat in objectMode'))\n            : this[ENCODING] ? buf.join('') : B.concat(buf, buf.dataLength))\n  }\n\n  // stream.promise().then(() => done, er => emitted error)\n  promise () {\n    return new Promise((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')))\n      this.on('end', () => resolve())\n      this.on('error', er => reject(er))\n    })\n  }\n\n  // for await (let chunk of stream)\n  [ASYNCITERATOR] () {\n    const next = () => {\n      const res = this.read()\n      if (res !== null)\n        return Promise.resolve({ done: false, value: res })\n\n      if (this[EOF])\n        return Promise.resolve({ done: true })\n\n      let resolve = null\n      let reject = null\n      const onerr = er => {\n        this.removeListener('data', ondata)\n        this.removeListener('end', onend)\n        reject(er)\n      }\n      const ondata = value => {\n        this.removeListener('error', onerr)\n        this.removeListener('end', onend)\n        this.pause()\n        resolve({ value: value, done: !!this[EOF] })\n      }\n      const onend = () => {\n        this.removeListener('error', onerr)\n        this.removeListener('data', ondata)\n        resolve({ done: true })\n      }\n      const ondestroy = () => onerr(new Error('stream destroyed'))\n      return new Promise((res, rej) => {\n        reject = rej\n        resolve = res\n        this.once(DESTROYED, ondestroy)\n        this.once('error', onerr)\n        this.once('end', onend)\n        this.once('data', ondata)\n      })\n    }\n\n    return { next }\n  }\n\n  // for (let chunk of stream)\n  [ITERATOR] () {\n    const next = () => {\n      const value = this.read()\n      const done = value === null\n      return { value, done }\n    }\n    return { next }\n  }\n\n  destroy (er) {\n    if (this[DESTROYED]) {\n      if (er)\n        this.emit('error', er)\n      else\n        this.emit(DESTROYED)\n      return this\n    }\n\n    this[DESTROYED] = true\n\n    // throw away all buffered data, it's never coming out\n    this.buffer = new Yallist()\n    this[BUFFERLENGTH] = 0\n\n    if (typeof this.close === 'function' && !this[CLOSED])\n      this.close()\n\n    if (er)\n      this.emit('error', er)\n    else // if no error to emit, still reject pending promises\n      this.emit(DESTROYED)\n\n    return this\n  }\n\n  static isStream (s) {\n    return !!s && (s instanceof Minipass || s instanceof EE && (\n      typeof s.pipe === 'function' || // readable\n      (typeof s.write === 'function' && typeof s.end === 'function') // writable\n    ))\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vbWluaXBhc3NAMi45LjAvbm9kZV9tb2R1bGVzL21pbmlwYXNzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1osV0FBVyxtQkFBTyxDQUFDLHNCQUFRO0FBQzNCLGdCQUFnQixtQkFBTyxDQUFDLHlGQUFTO0FBQ2pDLFdBQVcsMkVBQXVDOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlJQUE2Qjs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7O0FBRXhCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx5QkFBeUI7O0FBRTFEO0FBQ0EsaUNBQWlDLFlBQVk7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUNBQWlDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2tpY2tzdGFydC8uL25vZGVfbW9kdWxlcy8ucG5wbS9taW5pcGFzc0AyLjkuMC9ub2RlX21vZHVsZXMvbWluaXBhc3MvaW5kZXguanM/YjBmMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbmNvbnN0IEVFID0gcmVxdWlyZSgnZXZlbnRzJylcbmNvbnN0IFlhbGxpc3QgPSByZXF1aXJlKCd5YWxsaXN0JylcbmNvbnN0IFNEID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXInKS5TdHJpbmdEZWNvZGVyXG5cbmNvbnN0IEVPRiA9IFN5bWJvbCgnRU9GJylcbmNvbnN0IE1BWUJFX0VNSVRfRU5EID0gU3ltYm9sKCdtYXliZUVtaXRFbmQnKVxuY29uc3QgRU1JVFRFRF9FTkQgPSBTeW1ib2woJ2VtaXR0ZWRFbmQnKVxuY29uc3QgRU1JVFRJTkdfRU5EID0gU3ltYm9sKCdlbWl0dGluZ0VuZCcpXG5jb25zdCBDTE9TRUQgPSBTeW1ib2woJ2Nsb3NlZCcpXG5jb25zdCBSRUFEID0gU3ltYm9sKCdyZWFkJylcbmNvbnN0IEZMVVNIID0gU3ltYm9sKCdmbHVzaCcpXG5jb25zdCBGTFVTSENIVU5LID0gU3ltYm9sKCdmbHVzaENodW5rJylcbmNvbnN0IEVOQ09ESU5HID0gU3ltYm9sKCdlbmNvZGluZycpXG5jb25zdCBERUNPREVSID0gU3ltYm9sKCdkZWNvZGVyJylcbmNvbnN0IEZMT1dJTkcgPSBTeW1ib2woJ2Zsb3dpbmcnKVxuY29uc3QgUEFVU0VEID0gU3ltYm9sKCdwYXVzZWQnKVxuY29uc3QgUkVTVU1FID0gU3ltYm9sKCdyZXN1bWUnKVxuY29uc3QgQlVGRkVSTEVOR1RIID0gU3ltYm9sKCdidWZmZXJMZW5ndGgnKVxuY29uc3QgQlVGRkVSUFVTSCA9IFN5bWJvbCgnYnVmZmVyUHVzaCcpXG5jb25zdCBCVUZGRVJTSElGVCA9IFN5bWJvbCgnYnVmZmVyU2hpZnQnKVxuY29uc3QgT0JKRUNUTU9ERSA9IFN5bWJvbCgnb2JqZWN0TW9kZScpXG5jb25zdCBERVNUUk9ZRUQgPSBTeW1ib2woJ2Rlc3Ryb3llZCcpXG5cbi8vIFRPRE8gcmVtb3ZlIHdoZW4gTm9kZSB2OCBzdXBwb3J0IGRyb3BzXG5jb25zdCBkb0l0ZXIgPSBnbG9iYWwuX01QX05PX0lURVJBVE9SX1NZTUJPTFNfICAhPT0gJzEnXG5jb25zdCBBU1lOQ0lURVJBVE9SID0gZG9JdGVyICYmIFN5bWJvbC5hc3luY0l0ZXJhdG9yXG4gIHx8IFN5bWJvbCgnYXN5bmNJdGVyYXRvciBub3QgaW1wbGVtZW50ZWQnKVxuY29uc3QgSVRFUkFUT1IgPSBkb0l0ZXIgJiYgU3ltYm9sLml0ZXJhdG9yXG4gIHx8IFN5bWJvbCgnaXRlcmF0b3Igbm90IGltcGxlbWVudGVkJylcblxuLy8gQnVmZmVyIGluIG5vZGUgNC54IDwgNC41LjAgZG9lc24ndCBoYXZlIHdvcmtpbmcgQnVmZmVyLmZyb21cbi8vIG9yIEJ1ZmZlci5hbGxvYywgYW5kIEJ1ZmZlciBpbiBub2RlIDEwIGRlcHJlY2F0ZWQgdGhlIGN0b3IuXG4vLyAuTSwgdGhpcyBpcyBmaW5lIC5cXF4vTS4uXG5jb25zdCBCID0gQnVmZmVyLmFsbG9jID8gQnVmZmVyXG4gIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxuLy8gZXZlbnRzIHRoYXQgbWVhbiAndGhlIHN0cmVhbSBpcyBvdmVyJ1xuLy8gdGhlc2UgYXJlIHRyZWF0ZWQgc3BlY2lhbGx5LCBhbmQgcmUtZW1pdHRlZFxuLy8gaWYgdGhleSBhcmUgbGlzdGVuZWQgZm9yIGFmdGVyIGVtaXR0aW5nLlxuY29uc3QgaXNFbmRpc2ggPSBldiA9PlxuICBldiA9PT0gJ2VuZCcgfHxcbiAgZXYgPT09ICdmaW5pc2gnIHx8XG4gIGV2ID09PSAncHJlZmluaXNoJ1xuXG5jb25zdCBpc0FycmF5QnVmZmVyID0gYiA9PiBiIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHxcbiAgdHlwZW9mIGIgPT09ICdvYmplY3QnICYmXG4gIGIuY29uc3RydWN0b3IgJiZcbiAgYi5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQXJyYXlCdWZmZXInICYmXG4gIGIuYnl0ZUxlbmd0aCA+PSAwXG5cbmNvbnN0IGlzQXJyYXlCdWZmZXJWaWV3ID0gYiA9PiAhQi5pc0J1ZmZlcihiKSAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcoYilcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBNaW5pcGFzcyBleHRlbmRzIEVFIHtcbiAgY29uc3RydWN0b3IgKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpc1tGTE9XSU5HXSA9IGZhbHNlXG4gICAgLy8gd2hldGhlciB3ZSdyZSBleHBsaWNpdGx5IHBhdXNlZFxuICAgIHRoaXNbUEFVU0VEXSA9IGZhbHNlXG4gICAgdGhpcy5waXBlcyA9IG5ldyBZYWxsaXN0KClcbiAgICB0aGlzLmJ1ZmZlciA9IG5ldyBZYWxsaXN0KClcbiAgICB0aGlzW09CSkVDVE1PREVdID0gb3B0aW9ucyAmJiBvcHRpb25zLm9iamVjdE1vZGUgfHwgZmFsc2VcbiAgICBpZiAodGhpc1tPQkpFQ1RNT0RFXSlcbiAgICAgIHRoaXNbRU5DT0RJTkddID0gbnVsbFxuICAgIGVsc2VcbiAgICAgIHRoaXNbRU5DT0RJTkddID0gb3B0aW9ucyAmJiBvcHRpb25zLmVuY29kaW5nIHx8IG51bGxcbiAgICBpZiAodGhpc1tFTkNPRElOR10gPT09ICdidWZmZXInKVxuICAgICAgdGhpc1tFTkNPRElOR10gPSBudWxsXG4gICAgdGhpc1tERUNPREVSXSA9IHRoaXNbRU5DT0RJTkddID8gbmV3IFNEKHRoaXNbRU5DT0RJTkddKSA6IG51bGxcbiAgICB0aGlzW0VPRl0gPSBmYWxzZVxuICAgIHRoaXNbRU1JVFRFRF9FTkRdID0gZmFsc2VcbiAgICB0aGlzW0VNSVRUSU5HX0VORF0gPSBmYWxzZVxuICAgIHRoaXNbQ0xPU0VEXSA9IGZhbHNlXG4gICAgdGhpcy53cml0YWJsZSA9IHRydWVcbiAgICB0aGlzLnJlYWRhYmxlID0gdHJ1ZVxuICAgIHRoaXNbQlVGRkVSTEVOR1RIXSA9IDBcbiAgICB0aGlzW0RFU1RST1lFRF0gPSBmYWxzZVxuICB9XG5cbiAgZ2V0IGJ1ZmZlckxlbmd0aCAoKSB7IHJldHVybiB0aGlzW0JVRkZFUkxFTkdUSF0gfVxuXG4gIGdldCBlbmNvZGluZyAoKSB7IHJldHVybiB0aGlzW0VOQ09ESU5HXSB9XG4gIHNldCBlbmNvZGluZyAoZW5jKSB7XG4gICAgaWYgKHRoaXNbT0JKRUNUTU9ERV0pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBzZXQgZW5jb2RpbmcgaW4gb2JqZWN0TW9kZScpXG5cbiAgICBpZiAodGhpc1tFTkNPRElOR10gJiYgZW5jICE9PSB0aGlzW0VOQ09ESU5HXSAmJlxuICAgICAgICAodGhpc1tERUNPREVSXSAmJiB0aGlzW0RFQ09ERVJdLmxhc3ROZWVkIHx8IHRoaXNbQlVGRkVSTEVOR1RIXSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBjaGFuZ2UgZW5jb2RpbmcnKVxuXG4gICAgaWYgKHRoaXNbRU5DT0RJTkddICE9PSBlbmMpIHtcbiAgICAgIHRoaXNbREVDT0RFUl0gPSBlbmMgPyBuZXcgU0QoZW5jKSA6IG51bGxcbiAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGgpXG4gICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIubWFwKGNodW5rID0+IHRoaXNbREVDT0RFUl0ud3JpdGUoY2h1bmspKVxuICAgIH1cblxuICAgIHRoaXNbRU5DT0RJTkddID0gZW5jXG4gIH1cblxuICBzZXRFbmNvZGluZyAoZW5jKSB7XG4gICAgdGhpcy5lbmNvZGluZyA9IGVuY1xuICB9XG5cbiAgZ2V0IG9iamVjdE1vZGUgKCkgeyByZXR1cm4gdGhpc1tPQkpFQ1RNT0RFXSB9XG4gIHNldCBvYmplY3RNb2RlICjgpZAgKSB7IHRoaXNbT0JKRUNUTU9ERV0gPSB0aGlzW09CSkVDVE1PREVdIHx8ICEh4KWQICB9XG5cbiAgd3JpdGUgKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICBpZiAodGhpc1tFT0ZdKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKVxuXG4gICAgaWYgKHRoaXNbREVTVFJPWUVEXSkge1xuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIE9iamVjdC5hc3NpZ24oXG4gICAgICAgIG5ldyBFcnJvcignQ2Fubm90IGNhbGwgd3JpdGUgYWZ0ZXIgYSBzdHJlYW0gd2FzIGRlc3Ryb3llZCcpLFxuICAgICAgICB7IGNvZGU6ICdFUlJfU1RSRUFNX0RFU1RST1lFRCcgfVxuICAgICAgKSlcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNiID0gZW5jb2RpbmcsIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgICBpZiAoIWVuY29kaW5nKVxuICAgICAgZW5jb2RpbmcgPSAndXRmOCdcblxuICAgIC8vIGNvbnZlcnQgYXJyYXkgYnVmZmVycyBhbmQgdHlwZWQgYXJyYXkgdmlld3MgaW50byBidWZmZXJzXG4gICAgLy8gYXQgc29tZSBwb2ludCBpbiB0aGUgZnV0dXJlLCB3ZSBtYXkgd2FudCB0byBkbyB0aGUgb3Bwb3NpdGUhXG4gICAgLy8gbGVhdmUgc3RyaW5ncyBhbmQgYnVmZmVycyBhcy1pc1xuICAgIC8vIGFueXRoaW5nIGVsc2Ugc3dpdGNoZXMgdXMgaW50byBvYmplY3QgbW9kZVxuICAgIGlmICghdGhpc1tPQkpFQ1RNT0RFXSAmJiAhQi5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICAgIGlmIChpc0FycmF5QnVmZmVyVmlldyhjaHVuaykpXG4gICAgICAgIGNodW5rID0gQi5mcm9tKGNodW5rLmJ1ZmZlciwgY2h1bmsuYnl0ZU9mZnNldCwgY2h1bmsuYnl0ZUxlbmd0aClcbiAgICAgIGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIoY2h1bmspKVxuICAgICAgICBjaHVuayA9IEIuZnJvbShjaHVuaylcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycpXG4gICAgICAgIC8vIHVzZSB0aGUgc2V0dGVyIHNvIHdlIHRocm93IGlmIHdlIGhhdmUgZW5jb2Rpbmcgc2V0XG4gICAgICAgIHRoaXMub2JqZWN0TW9kZSA9IHRydWVcbiAgICB9XG5cbiAgICAvLyB0aGlzIGVuc3VyZXMgYXQgdGhpcyBwb2ludCB0aGF0IHRoZSBjaHVuayBpcyBhIGJ1ZmZlciBvciBzdHJpbmdcbiAgICAvLyBkb24ndCBidWZmZXIgaXQgdXAgb3Igc2VuZCBpdCB0byB0aGUgZGVjb2RlclxuICAgIGlmICghdGhpcy5vYmplY3RNb2RlICYmICFjaHVuay5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHJldCA9IHRoaXMuZmxvd2luZ1xuICAgICAgaWYgKHRoaXNbQlVGRkVSTEVOR1RIXSAhPT0gMClcbiAgICAgICAgdGhpcy5lbWl0KCdyZWFkYWJsZScpXG4gICAgICBpZiAoY2IpXG4gICAgICAgIGNiKClcbiAgICAgIHJldHVybiByZXRcbiAgICB9XG5cbiAgICAvLyBmYXN0LXBhdGggd3JpdGluZyBzdHJpbmdzIG9mIHNhbWUgZW5jb2RpbmcgdG8gYSBzdHJlYW0gd2l0aFxuICAgIC8vIGFuIGVtcHR5IGJ1ZmZlciwgc2tpcHBpbmcgdGhlIGJ1ZmZlci9kZWNvZGVyIGRhbmNlXG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycgJiYgIXRoaXNbT0JKRUNUTU9ERV0gJiZcbiAgICAgICAgLy8gdW5sZXNzIGl0IGlzIGEgc3RyaW5nIGFscmVhZHkgcmVhZHkgZm9yIHVzIHRvIHVzZVxuICAgICAgICAhKGVuY29kaW5nID09PSB0aGlzW0VOQ09ESU5HXSAmJiAhdGhpc1tERUNPREVSXS5sYXN0TmVlZCkpIHtcbiAgICAgIGNodW5rID0gQi5mcm9tKGNodW5rLCBlbmNvZGluZylcbiAgICB9XG5cbiAgICBpZiAoQi5pc0J1ZmZlcihjaHVuaykgJiYgdGhpc1tFTkNPRElOR10pXG4gICAgICBjaHVuayA9IHRoaXNbREVDT0RFUl0ud3JpdGUoY2h1bmspXG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMuZmxvd2luZ1xuICAgICAgICA/ICh0aGlzLmVtaXQoJ2RhdGEnLCBjaHVuayksIHRoaXMuZmxvd2luZylcbiAgICAgICAgOiAodGhpc1tCVUZGRVJQVVNIXShjaHVuayksIGZhbHNlKVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAodGhpc1tCVUZGRVJMRU5HVEhdICE9PSAwKVxuICAgICAgICB0aGlzLmVtaXQoJ3JlYWRhYmxlJylcbiAgICAgIGlmIChjYilcbiAgICAgICAgY2IoKVxuICAgIH1cbiAgfVxuXG4gIHJlYWQgKG4pIHtcbiAgICBpZiAodGhpc1tERVNUUk9ZRURdKVxuICAgICAgcmV0dXJuIG51bGxcblxuICAgIHRyeSB7XG4gICAgICBpZiAodGhpc1tCVUZGRVJMRU5HVEhdID09PSAwIHx8IG4gPT09IDAgfHwgbiA+IHRoaXNbQlVGRkVSTEVOR1RIXSlcbiAgICAgICAgcmV0dXJuIG51bGxcblxuICAgICAgaWYgKHRoaXNbT0JKRUNUTU9ERV0pXG4gICAgICAgIG4gPSBudWxsXG5cbiAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPiAxICYmICF0aGlzW09CSkVDVE1PREVdKSB7XG4gICAgICAgIGlmICh0aGlzLmVuY29kaW5nKVxuICAgICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFlhbGxpc3QoW1xuICAgICAgICAgICAgQXJyYXkuZnJvbSh0aGlzLmJ1ZmZlcikuam9pbignJylcbiAgICAgICAgICBdKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgWWFsbGlzdChbXG4gICAgICAgICAgICBCLmNvbmNhdChBcnJheS5mcm9tKHRoaXMuYnVmZmVyKSwgdGhpc1tCVUZGRVJMRU5HVEhdKVxuICAgICAgICAgIF0pXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzW1JFQURdKG4gfHwgbnVsbCwgdGhpcy5idWZmZXIuaGVhZC52YWx1ZSlcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKVxuICAgIH1cbiAgfVxuXG4gIFtSRUFEXSAobiwgY2h1bmspIHtcbiAgICBpZiAobiA9PT0gY2h1bmsubGVuZ3RoIHx8IG4gPT09IG51bGwpXG4gICAgICB0aGlzW0JVRkZFUlNISUZUXSgpXG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmJ1ZmZlci5oZWFkLnZhbHVlID0gY2h1bmsuc2xpY2UobilcbiAgICAgIGNodW5rID0gY2h1bmsuc2xpY2UoMCwgbilcbiAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSAtPSBuXG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KCdkYXRhJywgY2h1bmspXG5cbiAgICBpZiAoIXRoaXMuYnVmZmVyLmxlbmd0aCAmJiAhdGhpc1tFT0ZdKVxuICAgICAgdGhpcy5lbWl0KCdkcmFpbicpXG5cbiAgICByZXR1cm4gY2h1bmtcbiAgfVxuXG4gIGVuZCAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYiA9IGNodW5rLCBjaHVuayA9IG51bGxcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBlbmNvZGluZywgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBpZiAoY2h1bmspXG4gICAgICB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZylcbiAgICBpZiAoY2IpXG4gICAgICB0aGlzLm9uY2UoJ2VuZCcsIGNiKVxuICAgIHRoaXNbRU9GXSA9IHRydWVcbiAgICB0aGlzLndyaXRhYmxlID0gZmFsc2VcblxuICAgIC8vIGlmIHdlIGhhdmVuJ3Qgd3JpdHRlbiBhbnl0aGluZywgdGhlbiBnbyBhaGVhZCBhbmQgZW1pdCxcbiAgICAvLyBldmVuIGlmIHdlJ3JlIG5vdCByZWFkaW5nLlxuICAgIC8vIHdlJ2xsIHJlLWVtaXQgaWYgYSBuZXcgJ2VuZCcgbGlzdGVuZXIgaXMgYWRkZWQgYW55d2F5LlxuICAgIC8vIFRoaXMgbWFrZXMgTVAgbW9yZSBzdWl0YWJsZSB0byB3cml0ZS1vbmx5IHVzZSBjYXNlcy5cbiAgICBpZiAodGhpcy5mbG93aW5nIHx8ICF0aGlzW1BBVVNFRF0pXG4gICAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIGRvbid0IGxldCB0aGUgaW50ZXJuYWwgcmVzdW1lIGJlIG92ZXJ3cml0dGVuXG4gIFtSRVNVTUVdICgpIHtcbiAgICBpZiAodGhpc1tERVNUUk9ZRURdKVxuICAgICAgcmV0dXJuXG5cbiAgICB0aGlzW1BBVVNFRF0gPSBmYWxzZVxuICAgIHRoaXNbRkxPV0lOR10gPSB0cnVlXG4gICAgdGhpcy5lbWl0KCdyZXN1bWUnKVxuICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGgpXG4gICAgICB0aGlzW0ZMVVNIXSgpXG4gICAgZWxzZSBpZiAodGhpc1tFT0ZdKVxuICAgICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKVxuICAgIGVsc2VcbiAgICAgIHRoaXMuZW1pdCgnZHJhaW4nKVxuICB9XG5cbiAgcmVzdW1lICgpIHtcbiAgICByZXR1cm4gdGhpc1tSRVNVTUVdKClcbiAgfVxuXG4gIHBhdXNlICgpIHtcbiAgICB0aGlzW0ZMT1dJTkddID0gZmFsc2VcbiAgICB0aGlzW1BBVVNFRF0gPSB0cnVlXG4gIH1cblxuICBnZXQgZGVzdHJveWVkICgpIHtcbiAgICByZXR1cm4gdGhpc1tERVNUUk9ZRURdXG4gIH1cblxuICBnZXQgZmxvd2luZyAoKSB7XG4gICAgcmV0dXJuIHRoaXNbRkxPV0lOR11cbiAgfVxuXG4gIGdldCBwYXVzZWQgKCkge1xuICAgIHJldHVybiB0aGlzW1BBVVNFRF1cbiAgfVxuXG4gIFtCVUZGRVJQVVNIXSAoY2h1bmspIHtcbiAgICBpZiAodGhpc1tPQkpFQ1RNT0RFXSlcbiAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSArPSAxXG4gICAgZWxzZVxuICAgICAgdGhpc1tCVUZGRVJMRU5HVEhdICs9IGNodW5rLmxlbmd0aFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlci5wdXNoKGNodW5rKVxuICB9XG5cbiAgW0JVRkZFUlNISUZUXSAoKSB7XG4gICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgaWYgKHRoaXNbT0JKRUNUTU9ERV0pXG4gICAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSAtPSAxXG4gICAgICBlbHNlXG4gICAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSAtPSB0aGlzLmJ1ZmZlci5oZWFkLnZhbHVlLmxlbmd0aFxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5idWZmZXIuc2hpZnQoKVxuICB9XG5cbiAgW0ZMVVNIXSAoKSB7XG4gICAgZG8ge30gd2hpbGUgKHRoaXNbRkxVU0hDSFVOS10odGhpc1tCVUZGRVJTSElGVF0oKSkpXG5cbiAgICBpZiAoIXRoaXMuYnVmZmVyLmxlbmd0aCAmJiAhdGhpc1tFT0ZdKVxuICAgICAgdGhpcy5lbWl0KCdkcmFpbicpXG4gIH1cblxuICBbRkxVU0hDSFVOS10gKGNodW5rKSB7XG4gICAgcmV0dXJuIGNodW5rID8gKHRoaXMuZW1pdCgnZGF0YScsIGNodW5rKSwgdGhpcy5mbG93aW5nKSA6IGZhbHNlXG4gIH1cblxuICBwaXBlIChkZXN0LCBvcHRzKSB7XG4gICAgaWYgKHRoaXNbREVTVFJPWUVEXSlcbiAgICAgIHJldHVyblxuXG4gICAgY29uc3QgZW5kZWQgPSB0aGlzW0VNSVRURURfRU5EXVxuICAgIG9wdHMgPSBvcHRzIHx8IHt9XG4gICAgaWYgKGRlc3QgPT09IHByb2Nlc3Muc3Rkb3V0IHx8IGRlc3QgPT09IHByb2Nlc3Muc3RkZXJyKVxuICAgICAgb3B0cy5lbmQgPSBmYWxzZVxuICAgIGVsc2VcbiAgICAgIG9wdHMuZW5kID0gb3B0cy5lbmQgIT09IGZhbHNlXG5cbiAgICBjb25zdCBwID0geyBkZXN0OiBkZXN0LCBvcHRzOiBvcHRzLCBvbmRyYWluOiBfID0+IHRoaXNbUkVTVU1FXSgpIH1cbiAgICB0aGlzLnBpcGVzLnB1c2gocClcblxuICAgIGRlc3Qub24oJ2RyYWluJywgcC5vbmRyYWluKVxuICAgIHRoaXNbUkVTVU1FXSgpXG4gICAgLy8gcGlwaW5nIGFuIGVuZGVkIHN0cmVhbSBlbmRzIGltbWVkaWF0ZWx5XG4gICAgaWYgKGVuZGVkICYmIHAub3B0cy5lbmQpXG4gICAgICBwLmRlc3QuZW5kKClcbiAgICByZXR1cm4gZGVzdFxuICB9XG5cbiAgYWRkTGlzdGVuZXIgKGV2LCBmbikge1xuICAgIHJldHVybiB0aGlzLm9uKGV2LCBmbilcbiAgfVxuXG4gIG9uIChldiwgZm4pIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHN1cGVyLm9uKGV2LCBmbilcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGV2ID09PSAnZGF0YScgJiYgIXRoaXMucGlwZXMubGVuZ3RoICYmICF0aGlzLmZsb3dpbmcpXG4gICAgICAgIHRoaXNbUkVTVU1FXSgpXG4gICAgICBlbHNlIGlmIChpc0VuZGlzaChldikgJiYgdGhpc1tFTUlUVEVEX0VORF0pIHtcbiAgICAgICAgc3VwZXIuZW1pdChldilcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoZXYpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0IGVtaXR0ZWRFbmQgKCkge1xuICAgIHJldHVybiB0aGlzW0VNSVRURURfRU5EXVxuICB9XG5cbiAgW01BWUJFX0VNSVRfRU5EXSAoKSB7XG4gICAgaWYgKCF0aGlzW0VNSVRUSU5HX0VORF0gJiZcbiAgICAgICAgIXRoaXNbRU1JVFRFRF9FTkRdICYmXG4gICAgICAgICF0aGlzW0RFU1RST1lFRF0gJiZcbiAgICAgICAgdGhpcy5idWZmZXIubGVuZ3RoID09PSAwICYmXG4gICAgICAgIHRoaXNbRU9GXSkge1xuICAgICAgdGhpc1tFTUlUVElOR19FTkRdID0gdHJ1ZVxuICAgICAgdGhpcy5lbWl0KCdlbmQnKVxuICAgICAgdGhpcy5lbWl0KCdwcmVmaW5pc2gnKVxuICAgICAgdGhpcy5lbWl0KCdmaW5pc2gnKVxuICAgICAgaWYgKHRoaXNbQ0xPU0VEXSlcbiAgICAgICAgdGhpcy5lbWl0KCdjbG9zZScpXG4gICAgICB0aGlzW0VNSVRUSU5HX0VORF0gPSBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGVtaXQgKGV2LCBkYXRhKSB7XG4gICAgLy8gZXJyb3IgYW5kIGNsb3NlIGFyZSBvbmx5IGV2ZW50cyBhbGxvd2VkIGFmdGVyIGNhbGxpbmcgZGVzdHJveSgpXG4gICAgaWYgKGV2ICE9PSAnZXJyb3InICYmIGV2ICE9PSAnY2xvc2UnICYmIGV2ICE9PSBERVNUUk9ZRUQgJiYgdGhpc1tERVNUUk9ZRURdKVxuICAgICAgcmV0dXJuXG4gICAgZWxzZSBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgICAgaWYgKCFkYXRhKVxuICAgICAgICByZXR1cm5cblxuICAgICAgaWYgKHRoaXMucGlwZXMubGVuZ3RoKVxuICAgICAgICB0aGlzLnBpcGVzLmZvckVhY2gocCA9PlxuICAgICAgICAgIHAuZGVzdC53cml0ZShkYXRhKSA9PT0gZmFsc2UgJiYgdGhpcy5wYXVzZSgpKVxuICAgIH0gZWxzZSBpZiAoZXYgPT09ICdlbmQnKSB7XG4gICAgICAvLyBvbmx5IGFjdHVhbCBlbmQgZ2V0cyB0aGlzIHRyZWF0bWVudFxuICAgICAgaWYgKHRoaXNbRU1JVFRFRF9FTkRdID09PSB0cnVlKVxuICAgICAgICByZXR1cm5cblxuICAgICAgdGhpc1tFTUlUVEVEX0VORF0gPSB0cnVlXG4gICAgICB0aGlzLnJlYWRhYmxlID0gZmFsc2VcblxuICAgICAgaWYgKHRoaXNbREVDT0RFUl0pIHtcbiAgICAgICAgZGF0YSA9IHRoaXNbREVDT0RFUl0uZW5kKClcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICB0aGlzLnBpcGVzLmZvckVhY2gocCA9PiBwLmRlc3Qud3JpdGUoZGF0YSkpXG4gICAgICAgICAgc3VwZXIuZW1pdCgnZGF0YScsIGRhdGEpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5waXBlcy5mb3JFYWNoKHAgPT4ge1xuICAgICAgICBwLmRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgcC5vbmRyYWluKVxuICAgICAgICBpZiAocC5vcHRzLmVuZClcbiAgICAgICAgICBwLmRlc3QuZW5kKClcbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmIChldiA9PT0gJ2Nsb3NlJykge1xuICAgICAgdGhpc1tDTE9TRURdID0gdHJ1ZVxuICAgICAgLy8gZG9uJ3QgZW1pdCBjbG9zZSBiZWZvcmUgJ2VuZCcgYW5kICdmaW5pc2gnXG4gICAgICBpZiAoIXRoaXNbRU1JVFRFRF9FTkRdICYmICF0aGlzW0RFU1RST1lFRF0pXG4gICAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIFRPRE86IHJlcGxhY2Ugd2l0aCBhIHNwcmVhZCBvcGVyYXRvciB3aGVuIE5vZGUgdjQgc3VwcG9ydCBkcm9wc1xuICAgIGNvbnN0IGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aClcbiAgICBhcmdzWzBdID0gZXZcbiAgICBhcmdzWzFdID0gZGF0YVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXVxuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gc3VwZXIuZW1pdC5hcHBseSh0aGlzLCBhcmdzKVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoIWlzRW5kaXNoKGV2KSlcbiAgICAgICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKVxuICAgICAgZWxzZVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhldilcbiAgICB9XG4gIH1cblxuICAvLyBjb25zdCBhbGwgPSBhd2FpdCBzdHJlYW0uY29sbGVjdCgpXG4gIGNvbGxlY3QgKCkge1xuICAgIGNvbnN0IGJ1ZiA9IFtdXG4gICAgYnVmLmRhdGFMZW5ndGggPSAwXG4gICAgdGhpcy5vbignZGF0YScsIGMgPT4ge1xuICAgICAgYnVmLnB1c2goYylcbiAgICAgIGJ1Zi5kYXRhTGVuZ3RoICs9IGMubGVuZ3RoXG4gICAgfSlcbiAgICByZXR1cm4gdGhpcy5wcm9taXNlKCkudGhlbigoKSA9PiBidWYpXG4gIH1cblxuICAvLyBjb25zdCBkYXRhID0gYXdhaXQgc3RyZWFtLmNvbmNhdCgpXG4gIGNvbmNhdCAoKSB7XG4gICAgcmV0dXJuIHRoaXNbT0JKRUNUTU9ERV1cbiAgICAgID8gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdjYW5ub3QgY29uY2F0IGluIG9iamVjdE1vZGUnKSlcbiAgICAgIDogdGhpcy5jb2xsZWN0KCkudGhlbihidWYgPT5cbiAgICAgICAgICB0aGlzW09CSkVDVE1PREVdXG4gICAgICAgICAgICA/IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignY2Fubm90IGNvbmNhdCBpbiBvYmplY3RNb2RlJykpXG4gICAgICAgICAgICA6IHRoaXNbRU5DT0RJTkddID8gYnVmLmpvaW4oJycpIDogQi5jb25jYXQoYnVmLCBidWYuZGF0YUxlbmd0aCkpXG4gIH1cblxuICAvLyBzdHJlYW0ucHJvbWlzZSgpLnRoZW4oKCkgPT4gZG9uZSwgZXIgPT4gZW1pdHRlZCBlcnJvcilcbiAgcHJvbWlzZSAoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMub24oREVTVFJPWUVELCAoKSA9PiByZWplY3QobmV3IEVycm9yKCdzdHJlYW0gZGVzdHJveWVkJykpKVxuICAgICAgdGhpcy5vbignZW5kJywgKCkgPT4gcmVzb2x2ZSgpKVxuICAgICAgdGhpcy5vbignZXJyb3InLCBlciA9PiByZWplY3QoZXIpKVxuICAgIH0pXG4gIH1cblxuICAvLyBmb3IgYXdhaXQgKGxldCBjaHVuayBvZiBzdHJlYW0pXG4gIFtBU1lOQ0lURVJBVE9SXSAoKSB7XG4gICAgY29uc3QgbmV4dCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcyA9IHRoaXMucmVhZCgpXG4gICAgICBpZiAocmVzICE9PSBudWxsKVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgZG9uZTogZmFsc2UsIHZhbHVlOiByZXMgfSlcblxuICAgICAgaWYgKHRoaXNbRU9GXSlcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IGRvbmU6IHRydWUgfSlcblxuICAgICAgbGV0IHJlc29sdmUgPSBudWxsXG4gICAgICBsZXQgcmVqZWN0ID0gbnVsbFxuICAgICAgY29uc3Qgb25lcnIgPSBlciA9PiB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpXG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKVxuICAgICAgICByZWplY3QoZXIpXG4gICAgICB9XG4gICAgICBjb25zdCBvbmRhdGEgPSB2YWx1ZSA9PiB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnIpXG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKVxuICAgICAgICB0aGlzLnBhdXNlKClcbiAgICAgICAgcmVzb2x2ZSh7IHZhbHVlOiB2YWx1ZSwgZG9uZTogISF0aGlzW0VPRl0gfSlcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9uZW5kID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyKVxuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKVxuICAgICAgICByZXNvbHZlKHsgZG9uZTogdHJ1ZSB9KVxuICAgICAgfVxuICAgICAgY29uc3Qgb25kZXN0cm95ID0gKCkgPT4gb25lcnIobmV3IEVycm9yKCdzdHJlYW0gZGVzdHJveWVkJykpXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgIHJlamVjdCA9IHJlalxuICAgICAgICByZXNvbHZlID0gcmVzXG4gICAgICAgIHRoaXMub25jZShERVNUUk9ZRUQsIG9uZGVzdHJveSlcbiAgICAgICAgdGhpcy5vbmNlKCdlcnJvcicsIG9uZXJyKVxuICAgICAgICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKVxuICAgICAgICB0aGlzLm9uY2UoJ2RhdGEnLCBvbmRhdGEpXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiB7IG5leHQgfVxuICB9XG5cbiAgLy8gZm9yIChsZXQgY2h1bmsgb2Ygc3RyZWFtKVxuICBbSVRFUkFUT1JdICgpIHtcbiAgICBjb25zdCBuZXh0ID0gKCkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnJlYWQoKVxuICAgICAgY29uc3QgZG9uZSA9IHZhbHVlID09PSBudWxsXG4gICAgICByZXR1cm4geyB2YWx1ZSwgZG9uZSB9XG4gICAgfVxuICAgIHJldHVybiB7IG5leHQgfVxuICB9XG5cbiAgZGVzdHJveSAoZXIpIHtcbiAgICBpZiAodGhpc1tERVNUUk9ZRURdKSB7XG4gICAgICBpZiAoZXIpXG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcilcbiAgICAgIGVsc2VcbiAgICAgICAgdGhpcy5lbWl0KERFU1RST1lFRClcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgdGhpc1tERVNUUk9ZRURdID0gdHJ1ZVxuXG4gICAgLy8gdGhyb3cgYXdheSBhbGwgYnVmZmVyZWQgZGF0YSwgaXQncyBuZXZlciBjb21pbmcgb3V0XG4gICAgdGhpcy5idWZmZXIgPSBuZXcgWWFsbGlzdCgpXG4gICAgdGhpc1tCVUZGRVJMRU5HVEhdID0gMFxuXG4gICAgaWYgKHR5cGVvZiB0aGlzLmNsb3NlID09PSAnZnVuY3Rpb24nICYmICF0aGlzW0NMT1NFRF0pXG4gICAgICB0aGlzLmNsb3NlKClcblxuICAgIGlmIChlcilcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcilcbiAgICBlbHNlIC8vIGlmIG5vIGVycm9yIHRvIGVtaXQsIHN0aWxsIHJlamVjdCBwZW5kaW5nIHByb21pc2VzXG4gICAgICB0aGlzLmVtaXQoREVTVFJPWUVEKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXRpYyBpc1N0cmVhbSAocykge1xuICAgIHJldHVybiAhIXMgJiYgKHMgaW5zdGFuY2VvZiBNaW5pcGFzcyB8fCBzIGluc3RhbmNlb2YgRUUgJiYgKFxuICAgICAgdHlwZW9mIHMucGlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCAvLyByZWFkYWJsZVxuICAgICAgKHR5cGVvZiBzLndyaXRlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzLmVuZCA9PT0gJ2Z1bmN0aW9uJykgLy8gd3JpdGFibGVcbiAgICApKVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/minipass@2.9.0/node_modules/minipass/index.js\n");

/***/ })

};
;