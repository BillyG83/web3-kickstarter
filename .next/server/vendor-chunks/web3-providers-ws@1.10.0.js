/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/web3-providers-ws@1.10.0";
exports.ids = ["vendor-chunks/web3-providers-ws@1.10.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/web3-providers-ws@1.10.0/node_modules/web3-providers-ws/lib/helpers.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/web3-providers-ws@1.10.0/node_modules/web3-providers-ws/lib/helpers.js ***!
  \***************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var isNode = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';\nvar isRN = typeof navigator !== 'undefined' && navigator.product === 'ReactNative';\nvar _btoa = null;\nvar helpers = null;\nif (isNode || isRN) {\n    _btoa = function (str) {\n        return Buffer.from(str).toString('base64');\n    };\n    var url = __webpack_require__(/*! url */ \"url\");\n    if (url.URL) {\n        // Use the new Node 6+ API for parsing URLs that supports username/password\n        var newURL = url.URL;\n        helpers = function (url) {\n            return new newURL(url);\n        };\n    }\n    else {\n        // Web3 supports Node.js 5, so fall back to the legacy URL API if necessary\n        helpers = (__webpack_require__(/*! url */ \"url\").parse);\n    }\n}\nelse {\n    _btoa = btoa.bind(typeof globalThis === 'object' ? globalThis : self);\n    helpers = function (url) {\n        return new URL(url);\n    };\n}\nmodule.exports = {\n    parseURL: helpers,\n    btoa: _btoa\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViMy1wcm92aWRlcnMtd3NAMS4xMC4wL25vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVycy13cy9saWIvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLGdCQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw2Q0FBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8va2lja3N0YXJ0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL3dlYjMtcHJvdmlkZXJzLXdzQDEuMTAuMC9ub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlcnMtd3MvbGliL2hlbHBlcnMuanM/YmY4NiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaXNOb2RlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyA/IHByb2Nlc3MgOiAwKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nO1xudmFyIGlzUk4gPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJztcbnZhciBfYnRvYSA9IG51bGw7XG52YXIgaGVscGVycyA9IG51bGw7XG5pZiAoaXNOb2RlIHx8IGlzUk4pIHtcbiAgICBfYnRvYSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0cikudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIH07XG4gICAgdmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpO1xuICAgIGlmICh1cmwuVVJMKSB7XG4gICAgICAgIC8vIFVzZSB0aGUgbmV3IE5vZGUgNisgQVBJIGZvciBwYXJzaW5nIFVSTHMgdGhhdCBzdXBwb3J0cyB1c2VybmFtZS9wYXNzd29yZFxuICAgICAgICB2YXIgbmV3VVJMID0gdXJsLlVSTDtcbiAgICAgICAgaGVscGVycyA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgbmV3VVJMKHVybCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBXZWIzIHN1cHBvcnRzIE5vZGUuanMgNSwgc28gZmFsbCBiYWNrIHRvIHRoZSBsZWdhY3kgVVJMIEFQSSBpZiBuZWNlc3NhcnlcbiAgICAgICAgaGVscGVycyA9IHJlcXVpcmUoJ3VybCcpLnBhcnNlO1xuICAgIH1cbn1cbmVsc2Uge1xuICAgIF9idG9hID0gYnRvYS5iaW5kKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JyA/IGdsb2JhbFRoaXMgOiBzZWxmKTtcbiAgICBoZWxwZXJzID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICByZXR1cm4gbmV3IFVSTCh1cmwpO1xuICAgIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBwYXJzZVVSTDogaGVscGVycyxcbiAgICBidG9hOiBfYnRvYVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/web3-providers-ws@1.10.0/node_modules/web3-providers-ws/lib/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/web3-providers-ws@1.10.0/node_modules/web3-providers-ws/lib/index.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/web3-providers-ws@1.10.0/node_modules/web3-providers-ws/lib/index.js ***!
  \*************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */\n/**\n * @file WebsocketProvider.js\n * @authors: Samuel Furter <samuel@ethereum.org>, Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2019\n */\n\nvar EventEmitter = __webpack_require__(/*! eventemitter3 */ \"(ssr)/./node_modules/.pnpm/eventemitter3@4.0.4/node_modules/eventemitter3/index.js\");\nvar helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/.pnpm/web3-providers-ws@1.10.0/node_modules/web3-providers-ws/lib/helpers.js\");\nvar errors = (__webpack_require__(/*! web3-core-helpers */ \"(ssr)/./node_modules/.pnpm/web3-core-helpers@1.10.0/node_modules/web3-core-helpers/lib/index.js\").errors);\nvar Ws = (__webpack_require__(/*! websocket */ \"websocket\").w3cwebsocket);\n/**\n * @param {string} url\n * @param {Object} options\n *\n * @constructor\n */\nvar WebsocketProvider = function WebsocketProvider(url, options) {\n    EventEmitter.call(this);\n    options = options || {};\n    this.url = url;\n    this._customTimeout = options.timeout || 1000 * 15;\n    this.headers = options.headers || {};\n    this.protocol = options.protocol || undefined;\n    this.reconnectOptions = Object.assign({\n        auto: false,\n        delay: 5000,\n        maxAttempts: false,\n        onTimeout: false\n    }, options.reconnect);\n    this.clientConfig = options.clientConfig || undefined; // Allow a custom client configuration\n    this.requestOptions = options.requestOptions || undefined; // Allow a custom request options (https://github.com/theturtle32/WebSocket-Node/blob/master/docs/WebSocketClient.md#connectrequesturl-requestedprotocols-origin-headers-requestoptions)\n    this.DATA = 'data';\n    this.CLOSE = 'close';\n    this.ERROR = 'error';\n    this.CONNECT = 'connect';\n    this.RECONNECT = 'reconnect';\n    this.connection = null;\n    this.requestQueue = new Map();\n    this.responseQueue = new Map();\n    this.reconnectAttempts = 0;\n    this.reconnecting = false;\n    this.connectFailedDescription = null;\n    // The w3cwebsocket implementation does not support Basic Auth\n    // username/password in the URL. So generate the basic auth header, and\n    // pass through with any additional headers supplied in constructor\n    var parsedURL = helpers.parseURL(url);\n    if (parsedURL.username && parsedURL.password) {\n        this.headers.authorization = 'Basic ' + helpers.btoa(parsedURL.username + ':' + parsedURL.password);\n    }\n    // When all node core implementations that do not have the\n    // WHATWG compatible URL parser go out of service this line can be removed.\n    if (parsedURL.auth) {\n        this.headers.authorization = 'Basic ' + helpers.btoa(parsedURL.auth);\n    }\n    // make property `connected` which will return the current connection status\n    Object.defineProperty(this, 'connected', {\n        get: function () {\n            return this.connection && this.connection.readyState === this.connection.OPEN;\n        },\n        enumerable: true\n    });\n    this.connect();\n};\n// Inherit from EventEmitter\nWebsocketProvider.prototype = Object.create(EventEmitter.prototype);\nWebsocketProvider.prototype.constructor = WebsocketProvider;\n/**\n * Connects to the configured node\n *\n * @method connect\n *\n * @returns {void}\n */\nWebsocketProvider.prototype.connect = function () {\n    this.connection = new Ws(this.url, this.protocol, undefined, this.headers, this.requestOptions, this.clientConfig);\n    this._addSocketListeners();\n};\n/**\n * Listener for the `data` event of the underlying WebSocket object\n *\n * @method _onMessage\n *\n * @returns {void}\n */\nWebsocketProvider.prototype._onMessage = function (e) {\n    var _this = this;\n    this._parseResponse((typeof e.data === 'string') ? e.data : '').forEach(function (result) {\n        if (result.method && result.method.indexOf('_subscription') !== -1) {\n            _this.emit(_this.DATA, result);\n            return;\n        }\n        var id = result.id;\n        // get the id which matches the returned id\n        if (Array.isArray(result)) {\n            id = result[0].id;\n        }\n        if (_this.responseQueue.has(id)) {\n            if (_this.responseQueue.get(id).callback !== undefined) {\n                _this.responseQueue.get(id).callback(false, result);\n            }\n            _this.responseQueue.delete(id);\n        }\n    });\n};\n/**\n * Listener for the `open` event of the underlying WebSocket object\n *\n * @method _onConnect\n *\n * @returns {void}\n */\nWebsocketProvider.prototype._onConnect = function () {\n    this.emit(this.CONNECT);\n    this.reconnectAttempts = 0;\n    this.reconnecting = false;\n    if (this.requestQueue.size > 0) {\n        var _this = this;\n        this.requestQueue.forEach(function (request, key) {\n            _this.send(request.payload, request.callback);\n            _this.requestQueue.delete(key);\n        });\n    }\n};\nWebsocketProvider.prototype._onConnectFailed = function (event) {\n    this.connectFailedDescription = event.toString().split('\\n')[0];\n    var _this = this;\n    if (this.connectFailedDescription) {\n        event.description = this.connectFailedDescription;\n        this.connectFailedDescription = null; // clean the message, so it won't be used in the next connection\n    }\n    event.code = 1006;\n    event.reason = 'connection failed';\n    if (this.reconnectOptions.auto && (![1000, 1001].includes(event.code) || event.wasClean === false)) {\n        this.reconnect();\n        return;\n    }\n    this.emit(this.ERROR, event);\n    if (this.requestQueue.size > 0) {\n        this.requestQueue.forEach(function (request, key) {\n            request.callback(errors.ConnectionNotOpenError(event));\n            _this.requestQueue.delete(key);\n        });\n    }\n    if (this.responseQueue.size > 0) {\n        this.responseQueue.forEach(function (request, key) {\n            request.callback(errors.InvalidConnection('on WS', event));\n            _this.responseQueue.delete(key);\n        });\n    }\n    //clean connection on our own\n    if (this.connection._connection) {\n        this.connection._connection.removeAllListeners();\n    }\n    this.connection._client.removeAllListeners();\n    this.connection._readyState = 3; // set readyState to CLOSED\n    this.emit(this.CLOSE, event);\n};\n/**\n * Listener for the `close` event of the underlying WebSocket object\n *\n * @method _onClose\n *\n * @returns {void}\n */\nWebsocketProvider.prototype._onClose = function (event) {\n    var _this = this;\n    if (this.reconnectOptions.auto && (![1000, 1001].includes(event.code) || event.wasClean === false)) {\n        this.reconnect();\n        return;\n    }\n    this.emit(this.CLOSE, event);\n    if (this.requestQueue.size > 0) {\n        this.requestQueue.forEach(function (request, key) {\n            request.callback(errors.ConnectionNotOpenError(event));\n            _this.requestQueue.delete(key);\n        });\n    }\n    if (this.responseQueue.size > 0) {\n        this.responseQueue.forEach(function (request, key) {\n            request.callback(errors.InvalidConnection('on WS', event));\n            _this.responseQueue.delete(key);\n        });\n    }\n    this._removeSocketListeners();\n    this.removeAllListeners();\n};\n/**\n * Will add the required socket listeners\n *\n * @method _addSocketListeners\n *\n * @returns {void}\n */\nWebsocketProvider.prototype._addSocketListeners = function () {\n    this.connection.addEventListener('message', this._onMessage.bind(this));\n    this.connection.addEventListener('open', this._onConnect.bind(this));\n    this.connection.addEventListener('close', this._onClose.bind(this));\n    if (this.connection._client) {\n        this.connection._client.removeAllListeners('connectFailed'); //Override the internal listeners, so they don't trigger a `close` event. We want to trigger `_onClose` manually with a description.\n        this.connection._client.on('connectFailed', this._onConnectFailed.bind(this));\n    }\n};\n/**\n * Will remove all socket listeners\n *\n * @method _removeSocketListeners\n *\n * @returns {void}\n */\nWebsocketProvider.prototype._removeSocketListeners = function () {\n    this.connection.removeEventListener('message', this._onMessage);\n    this.connection.removeEventListener('open', this._onConnect);\n    this.connection.removeEventListener('close', this._onClose);\n    if (this.connection._connection)\n        this.connection._client.removeListener('connectFailed', this._onConnectFailed);\n};\n/**\n * Will parse the response and make an array out of it.\n *\n * @method _parseResponse\n *\n * @param {String} data\n *\n * @returns {Array}\n */\nWebsocketProvider.prototype._parseResponse = function (data) {\n    var _this = this, returnValues = [];\n    // DE-CHUNKER\n    var dechunkedData = data\n        .replace(/\\}[\\n\\r]?\\{/g, '}|--|{') // }{\n        .replace(/\\}\\][\\n\\r]?\\[\\{/g, '}]|--|[{') // }][{\n        .replace(/\\}[\\n\\r]?\\[\\{/g, '}|--|[{') // }[{\n        .replace(/\\}\\][\\n\\r]?\\{/g, '}]|--|{') // }]{\n        .split('|--|');\n    dechunkedData.forEach(function (data) {\n        // prepend the last chunk\n        if (_this.lastChunk)\n            data = _this.lastChunk + data;\n        var result = null;\n        try {\n            result = JSON.parse(data);\n        }\n        catch (e) {\n            _this.lastChunk = data;\n            // start timeout to cancel all requests\n            clearTimeout(_this.lastChunkTimeout);\n            _this.lastChunkTimeout = setTimeout(function () {\n                if (_this.reconnectOptions.auto && _this.reconnectOptions.onTimeout) {\n                    _this.reconnect();\n                    return;\n                }\n                _this.emit(_this.ERROR, errors.ConnectionTimeout(_this._customTimeout));\n                if (_this.requestQueue.size > 0) {\n                    _this.requestQueue.forEach(function (request, key) {\n                        request.callback(errors.ConnectionTimeout(_this._customTimeout));\n                        _this.requestQueue.delete(key);\n                    });\n                }\n            }, _this._customTimeout);\n            return;\n        }\n        // cancel timeout and set chunk to null\n        clearTimeout(_this.lastChunkTimeout);\n        _this.lastChunk = null;\n        if (result)\n            returnValues.push(result);\n    });\n    return returnValues;\n};\n/**\n * Does check if the provider is connecting and will add it to the queue or will send it directly\n *\n * @method send\n *\n * @param {Object} payload\n * @param {Function} callback\n *\n * @returns {void}\n */\nWebsocketProvider.prototype.send = function (payload, callback) {\n    var _this = this;\n    var id = payload.id;\n    var request = { payload: payload, callback: callback };\n    if (Array.isArray(payload)) {\n        id = payload[0].id;\n    }\n    if (this.connection.readyState === this.connection.CONNECTING || this.reconnecting) {\n        this.requestQueue.set(id, request);\n        return;\n    }\n    if (this.connection.readyState !== this.connection.OPEN) {\n        this.requestQueue.delete(id);\n        this.emit(this.ERROR, errors.ConnectionNotOpenError());\n        request.callback(errors.ConnectionNotOpenError());\n        return;\n    }\n    this.responseQueue.set(id, request);\n    this.requestQueue.delete(id);\n    try {\n        this.connection.send(JSON.stringify(request.payload));\n    }\n    catch (error) {\n        request.callback(error);\n        _this.responseQueue.delete(id);\n    }\n};\n/**\n * Resets the providers, clears all callbacks\n *\n * @method reset\n *\n * @returns {void}\n */\nWebsocketProvider.prototype.reset = function () {\n    this.responseQueue.clear();\n    this.requestQueue.clear();\n    this.removeAllListeners();\n    this._removeSocketListeners();\n    this._addSocketListeners();\n};\n/**\n * Closes the current connection with the given code and reason arguments\n *\n * @method disconnect\n *\n * @param {number} code\n * @param {string} reason\n *\n * @returns {void}\n */\nWebsocketProvider.prototype.disconnect = function (code, reason) {\n    this._removeSocketListeners();\n    this.connection.close(code || 1000, reason);\n};\n/**\n * Returns the desired boolean.\n *\n * @method supportsSubscriptions\n *\n * @returns {boolean}\n */\nWebsocketProvider.prototype.supportsSubscriptions = function () {\n    return true;\n};\n/**\n * Removes the listeners and reconnects to the socket.\n *\n * @method reconnect\n *\n * @returns {void}\n */\nWebsocketProvider.prototype.reconnect = function () {\n    var _this = this;\n    this.reconnecting = true;\n    if (this.responseQueue.size > 0) {\n        this.responseQueue.forEach(function (request, key) {\n            try {\n                _this.responseQueue.delete(key);\n                request.callback(errors.PendingRequestsOnReconnectingError());\n            }\n            catch (e) {\n                console.error(\"Error encountered in reconnect: \", e);\n            }\n        });\n    }\n    if (!this.reconnectOptions.maxAttempts ||\n        this.reconnectAttempts < this.reconnectOptions.maxAttempts) {\n        setTimeout(function () {\n            _this.reconnectAttempts++;\n            _this._removeSocketListeners();\n            _this.emit(_this.RECONNECT, _this.reconnectAttempts);\n            _this.connect();\n        }, this.reconnectOptions.delay);\n        return;\n    }\n    this.emit(this.ERROR, errors.MaxAttemptsReachedOnReconnectingError());\n    this.reconnecting = false;\n    if (this.requestQueue.size > 0) {\n        this.requestQueue.forEach(function (request, key) {\n            request.callback(errors.MaxAttemptsReachedOnReconnectingError());\n            _this.requestQueue.delete(key);\n        });\n    }\n};\nmodule.exports = WebsocketProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViMy1wcm92aWRlcnMtd3NAMS4xMC4wL25vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVycy13cy9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUNiLG1CQUFtQixtQkFBTyxDQUFDLHlHQUFlO0FBQzFDLGNBQWMsbUJBQU8sQ0FBQyx1SEFBYztBQUNwQyxhQUFhLHdKQUFtQztBQUNoRCxTQUFTLGdFQUFpQztBQUMxQztBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDJEQUEyRDtBQUMzRCwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUyxNQUFNLEtBQUs7QUFDeEMsb0JBQW9CLGFBQWEsTUFBTSxPQUFPLE9BQU87QUFDckQsb0JBQW9CLFdBQVcsTUFBTSxNQUFNLE9BQU87QUFDbEQsb0JBQW9CLFdBQVcsTUFBTSxNQUFNLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8va2lja3N0YXJ0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL3dlYjMtcHJvdmlkZXJzLXdzQDEuMTAuMC9ub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlcnMtd3MvbGliL2luZGV4LmpzPzMzY2YiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuICovXG4vKipcbiAqIEBmaWxlIFdlYnNvY2tldFByb3ZpZGVyLmpzXG4gKiBAYXV0aG9yczogU2FtdWVsIEZ1cnRlciA8c2FtdWVsQGV0aGVyZXVtLm9yZz4sIEZhYmlhbiBWb2dlbHN0ZWxsZXIgPGZhYmlhbkBldGhlcmV1bS5vcmc+XG4gKiBAZGF0ZSAyMDE5XG4gKi9cbid1c2Ugc3RyaWN0JztcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudGVtaXR0ZXIzJyk7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycy5qcycpO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoJ3dlYjMtY29yZS1oZWxwZXJzJykuZXJyb3JzO1xudmFyIFdzID0gcmVxdWlyZSgnd2Vic29ja2V0JykudzNjd2Vic29ja2V0O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgV2Vic29ja2V0UHJvdmlkZXIgPSBmdW5jdGlvbiBXZWJzb2NrZXRQcm92aWRlcih1cmwsIG9wdGlvbnMpIHtcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLl9jdXN0b21UaW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0IHx8IDEwMDAgKiAxNTtcbiAgICB0aGlzLmhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMgfHwge307XG4gICAgdGhpcy5wcm90b2NvbCA9IG9wdGlvbnMucHJvdG9jb2wgfHwgdW5kZWZpbmVkO1xuICAgIHRoaXMucmVjb25uZWN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBhdXRvOiBmYWxzZSxcbiAgICAgICAgZGVsYXk6IDUwMDAsXG4gICAgICAgIG1heEF0dGVtcHRzOiBmYWxzZSxcbiAgICAgICAgb25UaW1lb3V0OiBmYWxzZVxuICAgIH0sIG9wdGlvbnMucmVjb25uZWN0KTtcbiAgICB0aGlzLmNsaWVudENvbmZpZyA9IG9wdGlvbnMuY2xpZW50Q29uZmlnIHx8IHVuZGVmaW5lZDsgLy8gQWxsb3cgYSBjdXN0b20gY2xpZW50IGNvbmZpZ3VyYXRpb25cbiAgICB0aGlzLnJlcXVlc3RPcHRpb25zID0gb3B0aW9ucy5yZXF1ZXN0T3B0aW9ucyB8fCB1bmRlZmluZWQ7IC8vIEFsbG93IGEgY3VzdG9tIHJlcXVlc3Qgb3B0aW9ucyAoaHR0cHM6Ly9naXRodWIuY29tL3RoZXR1cnRsZTMyL1dlYlNvY2tldC1Ob2RlL2Jsb2IvbWFzdGVyL2RvY3MvV2ViU29ja2V0Q2xpZW50Lm1kI2Nvbm5lY3RyZXF1ZXN0dXJsLXJlcXVlc3RlZHByb3RvY29scy1vcmlnaW4taGVhZGVycy1yZXF1ZXN0b3B0aW9ucylcbiAgICB0aGlzLkRBVEEgPSAnZGF0YSc7XG4gICAgdGhpcy5DTE9TRSA9ICdjbG9zZSc7XG4gICAgdGhpcy5FUlJPUiA9ICdlcnJvcic7XG4gICAgdGhpcy5DT05ORUNUID0gJ2Nvbm5lY3QnO1xuICAgIHRoaXMuUkVDT05ORUNUID0gJ3JlY29ubmVjdCc7XG4gICAgdGhpcy5jb25uZWN0aW9uID0gbnVsbDtcbiAgICB0aGlzLnJlcXVlc3RRdWV1ZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnJlc3BvbnNlUXVldWUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9IDA7XG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmNvbm5lY3RGYWlsZWREZXNjcmlwdGlvbiA9IG51bGw7XG4gICAgLy8gVGhlIHczY3dlYnNvY2tldCBpbXBsZW1lbnRhdGlvbiBkb2VzIG5vdCBzdXBwb3J0IEJhc2ljIEF1dGhcbiAgICAvLyB1c2VybmFtZS9wYXNzd29yZCBpbiB0aGUgVVJMLiBTbyBnZW5lcmF0ZSB0aGUgYmFzaWMgYXV0aCBoZWFkZXIsIGFuZFxuICAgIC8vIHBhc3MgdGhyb3VnaCB3aXRoIGFueSBhZGRpdGlvbmFsIGhlYWRlcnMgc3VwcGxpZWQgaW4gY29uc3RydWN0b3JcbiAgICB2YXIgcGFyc2VkVVJMID0gaGVscGVycy5wYXJzZVVSTCh1cmwpO1xuICAgIGlmIChwYXJzZWRVUkwudXNlcm5hbWUgJiYgcGFyc2VkVVJMLnBhc3N3b3JkKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5hdXRob3JpemF0aW9uID0gJ0Jhc2ljICcgKyBoZWxwZXJzLmJ0b2EocGFyc2VkVVJMLnVzZXJuYW1lICsgJzonICsgcGFyc2VkVVJMLnBhc3N3b3JkKTtcbiAgICB9XG4gICAgLy8gV2hlbiBhbGwgbm9kZSBjb3JlIGltcGxlbWVudGF0aW9ucyB0aGF0IGRvIG5vdCBoYXZlIHRoZVxuICAgIC8vIFdIQVRXRyBjb21wYXRpYmxlIFVSTCBwYXJzZXIgZ28gb3V0IG9mIHNlcnZpY2UgdGhpcyBsaW5lIGNhbiBiZSByZW1vdmVkLlxuICAgIGlmIChwYXJzZWRVUkwuYXV0aCkge1xuICAgICAgICB0aGlzLmhlYWRlcnMuYXV0aG9yaXphdGlvbiA9ICdCYXNpYyAnICsgaGVscGVycy5idG9hKHBhcnNlZFVSTC5hdXRoKTtcbiAgICB9XG4gICAgLy8gbWFrZSBwcm9wZXJ0eSBgY29ubmVjdGVkYCB3aGljaCB3aWxsIHJldHVybiB0aGUgY3VycmVudCBjb25uZWN0aW9uIHN0YXR1c1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY29ubmVjdGVkJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24gJiYgdGhpcy5jb25uZWN0aW9uLnJlYWR5U3RhdGUgPT09IHRoaXMuY29ubmVjdGlvbi5PUEVOO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5jb25uZWN0KCk7XG59O1xuLy8gSW5oZXJpdCBmcm9tIEV2ZW50RW1pdHRlclxuV2Vic29ja2V0UHJvdmlkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcbldlYnNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFdlYnNvY2tldFByb3ZpZGVyO1xuLyoqXG4gKiBDb25uZWN0cyB0byB0aGUgY29uZmlndXJlZCBub2RlXG4gKlxuICogQG1ldGhvZCBjb25uZWN0XG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbldlYnNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY29ubmVjdGlvbiA9IG5ldyBXcyh0aGlzLnVybCwgdGhpcy5wcm90b2NvbCwgdW5kZWZpbmVkLCB0aGlzLmhlYWRlcnMsIHRoaXMucmVxdWVzdE9wdGlvbnMsIHRoaXMuY2xpZW50Q29uZmlnKTtcbiAgICB0aGlzLl9hZGRTb2NrZXRMaXN0ZW5lcnMoKTtcbn07XG4vKipcbiAqIExpc3RlbmVyIGZvciB0aGUgYGRhdGFgIGV2ZW50IG9mIHRoZSB1bmRlcmx5aW5nIFdlYlNvY2tldCBvYmplY3RcbiAqXG4gKiBAbWV0aG9kIF9vbk1lc3NhZ2VcbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuV2Vic29ja2V0UHJvdmlkZXIucHJvdG90eXBlLl9vbk1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5fcGFyc2VSZXNwb25zZSgodHlwZW9mIGUuZGF0YSA9PT0gJ3N0cmluZycpID8gZS5kYXRhIDogJycpLmZvckVhY2goZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBpZiAocmVzdWx0Lm1ldGhvZCAmJiByZXN1bHQubWV0aG9kLmluZGV4T2YoJ19zdWJzY3JpcHRpb24nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoX3RoaXMuREFUQSwgcmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaWQgPSByZXN1bHQuaWQ7XG4gICAgICAgIC8vIGdldCB0aGUgaWQgd2hpY2ggbWF0Y2hlcyB0aGUgcmV0dXJuZWQgaWRcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgICAgICAgaWQgPSByZXN1bHRbMF0uaWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF90aGlzLnJlc3BvbnNlUXVldWUuaGFzKGlkKSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnJlc3BvbnNlUXVldWUuZ2V0KGlkKS5jYWxsYmFjayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVzcG9uc2VRdWV1ZS5nZXQoaWQpLmNhbGxiYWNrKGZhbHNlLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMucmVzcG9uc2VRdWV1ZS5kZWxldGUoaWQpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuLyoqXG4gKiBMaXN0ZW5lciBmb3IgdGhlIGBvcGVuYCBldmVudCBvZiB0aGUgdW5kZXJseWluZyBXZWJTb2NrZXQgb2JqZWN0XG4gKlxuICogQG1ldGhvZCBfb25Db25uZWN0XG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbldlYnNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5fb25Db25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZW1pdCh0aGlzLkNPTk5FQ1QpO1xuICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPSAwO1xuICAgIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgaWYgKHRoaXMucmVxdWVzdFF1ZXVlLnNpemUgPiAwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucmVxdWVzdFF1ZXVlLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlc3QsIGtleSkge1xuICAgICAgICAgICAgX3RoaXMuc2VuZChyZXF1ZXN0LnBheWxvYWQsIHJlcXVlc3QuY2FsbGJhY2spO1xuICAgICAgICAgICAgX3RoaXMucmVxdWVzdFF1ZXVlLmRlbGV0ZShrZXkpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuV2Vic29ja2V0UHJvdmlkZXIucHJvdG90eXBlLl9vbkNvbm5lY3RGYWlsZWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB0aGlzLmNvbm5lY3RGYWlsZWREZXNjcmlwdGlvbiA9IGV2ZW50LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdO1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKHRoaXMuY29ubmVjdEZhaWxlZERlc2NyaXB0aW9uKSB7XG4gICAgICAgIGV2ZW50LmRlc2NyaXB0aW9uID0gdGhpcy5jb25uZWN0RmFpbGVkRGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMuY29ubmVjdEZhaWxlZERlc2NyaXB0aW9uID0gbnVsbDsgLy8gY2xlYW4gdGhlIG1lc3NhZ2UsIHNvIGl0IHdvbid0IGJlIHVzZWQgaW4gdGhlIG5leHQgY29ubmVjdGlvblxuICAgIH1cbiAgICBldmVudC5jb2RlID0gMTAwNjtcbiAgICBldmVudC5yZWFzb24gPSAnY29ubmVjdGlvbiBmYWlsZWQnO1xuICAgIGlmICh0aGlzLnJlY29ubmVjdE9wdGlvbnMuYXV0byAmJiAoIVsxMDAwLCAxMDAxXS5pbmNsdWRlcyhldmVudC5jb2RlKSB8fCBldmVudC53YXNDbGVhbiA9PT0gZmFsc2UpKSB7XG4gICAgICAgIHRoaXMucmVjb25uZWN0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbWl0KHRoaXMuRVJST1IsIGV2ZW50KTtcbiAgICBpZiAodGhpcy5yZXF1ZXN0UXVldWUuc2l6ZSA+IDApIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0UXVldWUuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVzdCwga2V5KSB7XG4gICAgICAgICAgICByZXF1ZXN0LmNhbGxiYWNrKGVycm9ycy5Db25uZWN0aW9uTm90T3BlbkVycm9yKGV2ZW50KSk7XG4gICAgICAgICAgICBfdGhpcy5yZXF1ZXN0UXVldWUuZGVsZXRlKGtleSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZXNwb25zZVF1ZXVlLnNpemUgPiAwKSB7XG4gICAgICAgIHRoaXMucmVzcG9uc2VRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1ZXN0LCBrZXkpIHtcbiAgICAgICAgICAgIHJlcXVlc3QuY2FsbGJhY2soZXJyb3JzLkludmFsaWRDb25uZWN0aW9uKCdvbiBXUycsIGV2ZW50KSk7XG4gICAgICAgICAgICBfdGhpcy5yZXNwb25zZVF1ZXVlLmRlbGV0ZShrZXkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy9jbGVhbiBjb25uZWN0aW9uIG9uIG91ciBvd25cbiAgICBpZiAodGhpcy5jb25uZWN0aW9uLl9jb25uZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5fY29ubmVjdGlvbi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgdGhpcy5jb25uZWN0aW9uLl9jbGllbnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5jb25uZWN0aW9uLl9yZWFkeVN0YXRlID0gMzsgLy8gc2V0IHJlYWR5U3RhdGUgdG8gQ0xPU0VEXG4gICAgdGhpcy5lbWl0KHRoaXMuQ0xPU0UsIGV2ZW50KTtcbn07XG4vKipcbiAqIExpc3RlbmVyIGZvciB0aGUgYGNsb3NlYCBldmVudCBvZiB0aGUgdW5kZXJseWluZyBXZWJTb2NrZXQgb2JqZWN0XG4gKlxuICogQG1ldGhvZCBfb25DbG9zZVxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5XZWJzb2NrZXRQcm92aWRlci5wcm90b3R5cGUuX29uQ2xvc2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmICh0aGlzLnJlY29ubmVjdE9wdGlvbnMuYXV0byAmJiAoIVsxMDAwLCAxMDAxXS5pbmNsdWRlcyhldmVudC5jb2RlKSB8fCBldmVudC53YXNDbGVhbiA9PT0gZmFsc2UpKSB7XG4gICAgICAgIHRoaXMucmVjb25uZWN0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbWl0KHRoaXMuQ0xPU0UsIGV2ZW50KTtcbiAgICBpZiAodGhpcy5yZXF1ZXN0UXVldWUuc2l6ZSA+IDApIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0UXVldWUuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVzdCwga2V5KSB7XG4gICAgICAgICAgICByZXF1ZXN0LmNhbGxiYWNrKGVycm9ycy5Db25uZWN0aW9uTm90T3BlbkVycm9yKGV2ZW50KSk7XG4gICAgICAgICAgICBfdGhpcy5yZXF1ZXN0UXVldWUuZGVsZXRlKGtleSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZXNwb25zZVF1ZXVlLnNpemUgPiAwKSB7XG4gICAgICAgIHRoaXMucmVzcG9uc2VRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1ZXN0LCBrZXkpIHtcbiAgICAgICAgICAgIHJlcXVlc3QuY2FsbGJhY2soZXJyb3JzLkludmFsaWRDb25uZWN0aW9uKCdvbiBXUycsIGV2ZW50KSk7XG4gICAgICAgICAgICBfdGhpcy5yZXNwb25zZVF1ZXVlLmRlbGV0ZShrZXkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVtb3ZlU29ja2V0TGlzdGVuZXJzKCk7XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG4vKipcbiAqIFdpbGwgYWRkIHRoZSByZXF1aXJlZCBzb2NrZXQgbGlzdGVuZXJzXG4gKlxuICogQG1ldGhvZCBfYWRkU29ja2V0TGlzdGVuZXJzXG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbldlYnNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5fYWRkU29ja2V0TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5fb25NZXNzYWdlLmJpbmQodGhpcykpO1xuICAgIHRoaXMuY29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKCdvcGVuJywgdGhpcy5fb25Db25uZWN0LmJpbmQodGhpcykpO1xuICAgIHRoaXMuY29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIHRoaXMuX29uQ2xvc2UuYmluZCh0aGlzKSk7XG4gICAgaWYgKHRoaXMuY29ubmVjdGlvbi5fY2xpZW50KSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5fY2xpZW50LnJlbW92ZUFsbExpc3RlbmVycygnY29ubmVjdEZhaWxlZCcpOyAvL092ZXJyaWRlIHRoZSBpbnRlcm5hbCBsaXN0ZW5lcnMsIHNvIHRoZXkgZG9uJ3QgdHJpZ2dlciBhIGBjbG9zZWAgZXZlbnQuIFdlIHdhbnQgdG8gdHJpZ2dlciBgX29uQ2xvc2VgIG1hbnVhbGx5IHdpdGggYSBkZXNjcmlwdGlvbi5cbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLl9jbGllbnQub24oJ2Nvbm5lY3RGYWlsZWQnLCB0aGlzLl9vbkNvbm5lY3RGYWlsZWQuYmluZCh0aGlzKSk7XG4gICAgfVxufTtcbi8qKlxuICogV2lsbCByZW1vdmUgYWxsIHNvY2tldCBsaXN0ZW5lcnNcbiAqXG4gKiBAbWV0aG9kIF9yZW1vdmVTb2NrZXRMaXN0ZW5lcnNcbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuV2Vic29ja2V0UHJvdmlkZXIucHJvdG90eXBlLl9yZW1vdmVTb2NrZXRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jb25uZWN0aW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLl9vbk1lc3NhZ2UpO1xuICAgIHRoaXMuY29ubmVjdGlvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdvcGVuJywgdGhpcy5fb25Db25uZWN0KTtcbiAgICB0aGlzLmNvbm5lY3Rpb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xvc2UnLCB0aGlzLl9vbkNsb3NlKTtcbiAgICBpZiAodGhpcy5jb25uZWN0aW9uLl9jb25uZWN0aW9uKVxuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uX2NsaWVudC5yZW1vdmVMaXN0ZW5lcignY29ubmVjdEZhaWxlZCcsIHRoaXMuX29uQ29ubmVjdEZhaWxlZCk7XG59O1xuLyoqXG4gKiBXaWxsIHBhcnNlIHRoZSByZXNwb25zZSBhbmQgbWFrZSBhbiBhcnJheSBvdXQgb2YgaXQuXG4gKlxuICogQG1ldGhvZCBfcGFyc2VSZXNwb25zZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICovXG5XZWJzb2NrZXRQcm92aWRlci5wcm90b3R5cGUuX3BhcnNlUmVzcG9uc2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXMsIHJldHVyblZhbHVlcyA9IFtdO1xuICAgIC8vIERFLUNIVU5LRVJcbiAgICB2YXIgZGVjaHVua2VkRGF0YSA9IGRhdGFcbiAgICAgICAgLnJlcGxhY2UoL1xcfVtcXG5cXHJdP1xcey9nLCAnfXwtLXx7JykgLy8gfXtcbiAgICAgICAgLnJlcGxhY2UoL1xcfVxcXVtcXG5cXHJdP1xcW1xcey9nLCAnfV18LS18W3snKSAvLyB9XVt7XG4gICAgICAgIC5yZXBsYWNlKC9cXH1bXFxuXFxyXT9cXFtcXHsvZywgJ318LS18W3snKSAvLyB9W3tcbiAgICAgICAgLnJlcGxhY2UoL1xcfVxcXVtcXG5cXHJdP1xcey9nLCAnfV18LS18eycpIC8vIH1de1xuICAgICAgICAuc3BsaXQoJ3wtLXwnKTtcbiAgICBkZWNodW5rZWREYXRhLmZvckVhY2goZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgLy8gcHJlcGVuZCB0aGUgbGFzdCBjaHVua1xuICAgICAgICBpZiAoX3RoaXMubGFzdENodW5rKVxuICAgICAgICAgICAgZGF0YSA9IF90aGlzLmxhc3RDaHVuayArIGRhdGE7XG4gICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgX3RoaXMubGFzdENodW5rID0gZGF0YTtcbiAgICAgICAgICAgIC8vIHN0YXJ0IHRpbWVvdXQgdG8gY2FuY2VsIGFsbCByZXF1ZXN0c1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLmxhc3RDaHVua1RpbWVvdXQpO1xuICAgICAgICAgICAgX3RoaXMubGFzdENodW5rVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5yZWNvbm5lY3RPcHRpb25zLmF1dG8gJiYgX3RoaXMucmVjb25uZWN0T3B0aW9ucy5vblRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdChfdGhpcy5FUlJPUiwgZXJyb3JzLkNvbm5lY3Rpb25UaW1lb3V0KF90aGlzLl9jdXN0b21UaW1lb3V0KSk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnJlcXVlc3RRdWV1ZS5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXF1ZXN0UXVldWUuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVzdCwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmNhbGxiYWNrKGVycm9ycy5Db25uZWN0aW9uVGltZW91dChfdGhpcy5fY3VzdG9tVGltZW91dCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVxdWVzdFF1ZXVlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfdGhpcy5fY3VzdG9tVGltZW91dCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FuY2VsIHRpbWVvdXQgYW5kIHNldCBjaHVuayB0byBudWxsXG4gICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5sYXN0Q2h1bmtUaW1lb3V0KTtcbiAgICAgICAgX3RoaXMubGFzdENodW5rID0gbnVsbDtcbiAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICAgIHJldHVyblZhbHVlcy5wdXNoKHJlc3VsdCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlcztcbn07XG4vKipcbiAqIERvZXMgY2hlY2sgaWYgdGhlIHByb3ZpZGVyIGlzIGNvbm5lY3RpbmcgYW5kIHdpbGwgYWRkIGl0IHRvIHRoZSBxdWV1ZSBvciB3aWxsIHNlbmQgaXQgZGlyZWN0bHlcbiAqXG4gKiBAbWV0aG9kIHNlbmRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuV2Vic29ja2V0UHJvdmlkZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAocGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBpZCA9IHBheWxvYWQuaWQ7XG4gICAgdmFyIHJlcXVlc3QgPSB7IHBheWxvYWQ6IHBheWxvYWQsIGNhbGxiYWNrOiBjYWxsYmFjayB9O1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQpKSB7XG4gICAgICAgIGlkID0gcGF5bG9hZFswXS5pZDtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29ubmVjdGlvbi5yZWFkeVN0YXRlID09PSB0aGlzLmNvbm5lY3Rpb24uQ09OTkVDVElORyB8fCB0aGlzLnJlY29ubmVjdGluZykge1xuICAgICAgICB0aGlzLnJlcXVlc3RRdWV1ZS5zZXQoaWQsIHJlcXVlc3QpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbm5lY3Rpb24ucmVhZHlTdGF0ZSAhPT0gdGhpcy5jb25uZWN0aW9uLk9QRU4pIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0UXVldWUuZGVsZXRlKGlkKTtcbiAgICAgICAgdGhpcy5lbWl0KHRoaXMuRVJST1IsIGVycm9ycy5Db25uZWN0aW9uTm90T3BlbkVycm9yKCkpO1xuICAgICAgICByZXF1ZXN0LmNhbGxiYWNrKGVycm9ycy5Db25uZWN0aW9uTm90T3BlbkVycm9yKCkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVzcG9uc2VRdWV1ZS5zZXQoaWQsIHJlcXVlc3QpO1xuICAgIHRoaXMucmVxdWVzdFF1ZXVlLmRlbGV0ZShpZCk7XG4gICAgdHJ5IHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLnNlbmQoSlNPTi5zdHJpbmdpZnkocmVxdWVzdC5wYXlsb2FkKSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXF1ZXN0LmNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgX3RoaXMucmVzcG9uc2VRdWV1ZS5kZWxldGUoaWQpO1xuICAgIH1cbn07XG4vKipcbiAqIFJlc2V0cyB0aGUgcHJvdmlkZXJzLCBjbGVhcnMgYWxsIGNhbGxiYWNrc1xuICpcbiAqIEBtZXRob2QgcmVzZXRcbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuV2Vic29ja2V0UHJvdmlkZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVzcG9uc2VRdWV1ZS5jbGVhcigpO1xuICAgIHRoaXMucmVxdWVzdFF1ZXVlLmNsZWFyKCk7XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl9yZW1vdmVTb2NrZXRMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl9hZGRTb2NrZXRMaXN0ZW5lcnMoKTtcbn07XG4vKipcbiAqIENsb3NlcyB0aGUgY3VycmVudCBjb25uZWN0aW9uIHdpdGggdGhlIGdpdmVuIGNvZGUgYW5kIHJlYXNvbiBhcmd1bWVudHNcbiAqXG4gKiBAbWV0aG9kIGRpc2Nvbm5lY3RcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gY29kZVxuICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvblxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5XZWJzb2NrZXRQcm92aWRlci5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uIChjb2RlLCByZWFzb24pIHtcbiAgICB0aGlzLl9yZW1vdmVTb2NrZXRMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmNvbm5lY3Rpb24uY2xvc2UoY29kZSB8fCAxMDAwLCByZWFzb24pO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgZGVzaXJlZCBib29sZWFuLlxuICpcbiAqIEBtZXRob2Qgc3VwcG9ydHNTdWJzY3JpcHRpb25zXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbldlYnNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5zdXBwb3J0c1N1YnNjcmlwdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG4gKiBSZW1vdmVzIHRoZSBsaXN0ZW5lcnMgYW5kIHJlY29ubmVjdHMgdG8gdGhlIHNvY2tldC5cbiAqXG4gKiBAbWV0aG9kIHJlY29ubmVjdFxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5XZWJzb2NrZXRQcm92aWRlci5wcm90b3R5cGUucmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSB0cnVlO1xuICAgIGlmICh0aGlzLnJlc3BvbnNlUXVldWUuc2l6ZSA+IDApIHtcbiAgICAgICAgdGhpcy5yZXNwb25zZVF1ZXVlLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlc3QsIGtleSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZXNwb25zZVF1ZXVlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuY2FsbGJhY2soZXJyb3JzLlBlbmRpbmdSZXF1ZXN0c09uUmVjb25uZWN0aW5nRXJyb3IoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBlbmNvdW50ZXJlZCBpbiByZWNvbm5lY3Q6IFwiLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghdGhpcy5yZWNvbm5lY3RPcHRpb25zLm1heEF0dGVtcHRzIHx8XG4gICAgICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPCB0aGlzLnJlY29ubmVjdE9wdGlvbnMubWF4QXR0ZW1wdHMpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5yZWNvbm5lY3RBdHRlbXB0cysrO1xuICAgICAgICAgICAgX3RoaXMuX3JlbW92ZVNvY2tldExpc3RlbmVycygpO1xuICAgICAgICAgICAgX3RoaXMuZW1pdChfdGhpcy5SRUNPTk5FQ1QsIF90aGlzLnJlY29ubmVjdEF0dGVtcHRzKTtcbiAgICAgICAgICAgIF90aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgfSwgdGhpcy5yZWNvbm5lY3RPcHRpb25zLmRlbGF5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVtaXQodGhpcy5FUlJPUiwgZXJyb3JzLk1heEF0dGVtcHRzUmVhY2hlZE9uUmVjb25uZWN0aW5nRXJyb3IoKSk7XG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5yZXF1ZXN0UXVldWUuc2l6ZSA+IDApIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0UXVldWUuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVzdCwga2V5KSB7XG4gICAgICAgICAgICByZXF1ZXN0LmNhbGxiYWNrKGVycm9ycy5NYXhBdHRlbXB0c1JlYWNoZWRPblJlY29ubmVjdGluZ0Vycm9yKCkpO1xuICAgICAgICAgICAgX3RoaXMucmVxdWVzdFF1ZXVlLmRlbGV0ZShrZXkpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBXZWJzb2NrZXRQcm92aWRlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/web3-providers-ws@1.10.0/node_modules/web3-providers-ws/lib/index.js\n");

/***/ })

};
;