/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/web3-utils@1.10.0";
exports.ids = ["vendor-chunks/web3-utils@1.10.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/web3-utils@1.10.0/node_modules/web3-utils/lib/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/web3-utils@1.10.0/node_modules/web3-utils/lib/index.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */\n/**\n * @file utils.js\n * @author Marek Kotewicz <marek@parity.io>\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\nvar ethjsUnit = __webpack_require__(/*! ethjs-unit */ \"(ssr)/./node_modules/.pnpm/ethjs-unit@0.1.6/node_modules/ethjs-unit/lib/index.js\");\nvar utils = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/.pnpm/web3-utils@1.10.0/node_modules/web3-utils/lib/utils.js\");\nvar soliditySha3 = __webpack_require__(/*! ./soliditySha3.js */ \"(ssr)/./node_modules/.pnpm/web3-utils@1.10.0/node_modules/web3-utils/lib/soliditySha3.js\");\nvar randombytes = __webpack_require__(/*! randombytes */ \"(ssr)/./node_modules/.pnpm/randombytes@2.1.0/node_modules/randombytes/index.js\");\nvar BN = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/.pnpm/bn.js@5.2.1/node_modules/bn.js/lib/bn.js\");\n/**\n * Fires an error in an event emitter and callback and returns the eventemitter\n *\n * @method _fireError\n * @param {Object} error a string, a error, or an object with {message, data}\n * @param {Object} emitter\n * @param {Function} reject\n * @param {Function} callback\n * @param {any} optionalData\n * @return {Object} the emitter\n */\nvar _fireError = function (error, emitter, reject, callback, optionalData) {\n    /*jshint maxcomplexity: 10 */\n    // add data if given\n    if (!!error && typeof error === 'object' && !(error instanceof Error) && error.data) {\n        if (!!error.data && typeof error.data === 'object' || Array.isArray(error.data)) {\n            error.data = JSON.stringify(error.data, null, 2);\n        }\n        error = error.message + \"\\n\" + error.data;\n    }\n    if (typeof error === 'string') {\n        error = new Error(error);\n    }\n    if (typeof callback === 'function') {\n        callback(error, optionalData);\n    }\n    if (typeof reject === 'function') {\n        // suppress uncatched error if an error listener is present\n        // OR suppress uncatched error if an callback listener is present\n        if (emitter &&\n            (typeof emitter.listeners === 'function' &&\n                emitter.listeners('error').length) || typeof callback === 'function') {\n            emitter.catch(function () { });\n        }\n        // reject later, to be able to return emitter\n        setTimeout(function () {\n            reject(error);\n        }, 1);\n    }\n    if (emitter && typeof emitter.emit === 'function') {\n        // emit later, to be able to return emitter\n        setTimeout(function () {\n            emitter.emit('error', error, optionalData);\n            emitter.removeAllListeners();\n        }, 1);\n    }\n    return emitter;\n};\n/**\n * Should be used to create full function/event name from json abi\n *\n * @method _jsonInterfaceMethodToString\n * @param {Object} json\n * @return {String} full function/event name\n */\nvar _jsonInterfaceMethodToString = function (json) {\n    if (!!json && typeof json === 'object' && json.name && json.name.indexOf('(') !== -1) {\n        return json.name;\n    }\n    return json.name + '(' + _flattenTypes(false, json.inputs).join(',') + ')';\n};\n/**\n * Should be used to flatten json abi inputs/outputs into an array of type-representing-strings\n *\n * @method _flattenTypes\n * @param {bool} includeTuple\n * @param {Object} puts\n * @return {Array} parameters as strings\n */\nvar _flattenTypes = function (includeTuple, puts) {\n    // console.log(\"entered _flattenTypes. inputs/outputs: \" + puts)\n    var types = [];\n    puts.forEach(function (param) {\n        if (typeof param.components === 'object') {\n            if (param.type.substring(0, 5) !== 'tuple') {\n                throw new Error('components found but type is not tuple; report on GitHub');\n            }\n            var suffix = '';\n            var arrayBracket = param.type.indexOf('[');\n            if (arrayBracket >= 0) {\n                suffix = param.type.substring(arrayBracket);\n            }\n            var result = _flattenTypes(includeTuple, param.components);\n            // console.log(\"result should have things: \" + result)\n            if (Array.isArray(result) && includeTuple) {\n                // console.log(\"include tuple word, and its an array. joining...: \" + result.types)\n                types.push('tuple(' + result.join(',') + ')' + suffix);\n            }\n            else if (!includeTuple) {\n                // console.log(\"don't include tuple, but its an array. joining...: \" + result)\n                types.push('(' + result.join(',') + ')' + suffix);\n            }\n            else {\n                // console.log(\"its a single type within a tuple: \" + result.types)\n                types.push('(' + result + ')');\n            }\n        }\n        else {\n            // console.log(\"its a type and not directly in a tuple: \" + param.type)\n            types.push(param.type);\n        }\n    });\n    return types;\n};\n/**\n * Returns a random hex string by the given bytes size\n *\n * @param {Number} size\n * @returns {string}\n */\nvar randomHex = function (size) {\n    return '0x' + randombytes(size).toString('hex');\n};\n/**\n * Should be called to get ascii from it's hex representation\n *\n * @method hexToAscii\n * @param {String} hex\n * @returns {String} ascii string representation of hex value\n */\nvar hexToAscii = function (hex) {\n    if (!utils.isHexStrict(hex))\n        throw new Error('The parameter must be a valid HEX string.');\n    var str = \"\";\n    var i = 0, l = hex.length;\n    if (hex.substring(0, 2) === '0x') {\n        i = 2;\n    }\n    for (; i < l; i += 2) {\n        var code = parseInt(hex.slice(i, i + 2), 16);\n        str += String.fromCharCode(code);\n    }\n    return str;\n};\n/**\n * Should be called to get hex representation (prefixed by 0x) of ascii string\n *\n * @method asciiToHex\n * @param {String} str\n * @returns {String} hex representation of input string\n */\nvar asciiToHex = function (str) {\n    if (!str)\n        return \"0x00\";\n    var hex = \"\";\n    for (var i = 0; i < str.length; i++) {\n        var code = str.charCodeAt(i);\n        var n = code.toString(16);\n        hex += n.length < 2 ? '0' + n : n;\n    }\n    return \"0x\" + hex;\n};\n/**\n * Returns value of unit in Wei\n *\n * @method getUnitValue\n * @param {String} unit the unit to convert to, default ether\n * @returns {BN} value of the unit (in Wei)\n * @throws error if the unit is not correct:w\n */\nvar getUnitValue = function (unit) {\n    unit = unit ? unit.toLowerCase() : 'ether';\n    if (!ethjsUnit.unitMap[unit]) {\n        throw new Error('This unit \"' + unit + '\" doesn\\'t exist, please use the one of the following units' + JSON.stringify(ethjsUnit.unitMap, null, 2));\n    }\n    return unit;\n};\n/**\n * Takes a number of wei and converts it to any other ether unit.\n *\n * Possible units are:\n *   SI Short   SI Full        Effigy       Other\n * - kwei       femtoether     babbage\n * - mwei       picoether      lovelace\n * - gwei       nanoether      shannon      nano\n * - --         microether     szabo        micro\n * - --         milliether     finney       milli\n * - ether      --             --\n * - kether                    --           grand\n * - mether\n * - gether\n * - tether\n *\n * @method fromWei\n * @param {Number|String} number can be a number, number string or a HEX of a decimal\n * @param {String} unit the unit to convert to, default ether\n * @return {String|Object} When given a BN object it returns one as well, otherwise a number\n */\nvar fromWei = function (number, unit) {\n    unit = getUnitValue(unit);\n    if (!utils.isBN(number) && !(typeof number === 'string')) {\n        throw new Error('Please pass numbers as strings or BN objects to avoid precision errors.');\n    }\n    return utils.isBN(number) ? ethjsUnit.fromWei(number, unit) : ethjsUnit.fromWei(number, unit).toString(10);\n};\n/**\n * Takes a number of a unit and converts it to wei.\n *\n * Possible units are:\n *   SI Short   SI Full        Effigy       Other\n * - kwei       femtoether     babbage\n * - mwei       picoether      lovelace\n * - gwei       nanoether      shannon      nano\n * - --         microether     szabo        micro\n * - --         microether     szabo        micro\n * - --         milliether     finney       milli\n * - ether      --             --\n * - kether                    --           grand\n * - mether\n * - gether\n * - tether\n *\n * @method toWei\n * @param {Number|String|BN} number can be a number, number string or a HEX of a decimal\n * @param {String} unit the unit to convert from, default ether\n * @return {String|Object} When given a BN object it returns one as well, otherwise a number\n */\nvar toWei = function (number, unit) {\n    unit = getUnitValue(unit);\n    if (!utils.isBN(number) && !(typeof number === 'string')) {\n        throw new Error('Please pass numbers as strings or BN objects to avoid precision errors.');\n    }\n    return utils.isBN(number) ? ethjsUnit.toWei(number, unit) : ethjsUnit.toWei(number, unit).toString(10);\n};\n/**\n * Converts to a checksum address\n *\n * @method toChecksumAddress\n * @param {String} address the given HEX address\n * @return {String}\n */\nvar toChecksumAddress = function (address) {\n    if (typeof address === 'undefined')\n        return '';\n    if (!/^(0x)?[0-9a-f]{40}$/i.test(address))\n        throw new Error('Given address \"' + address + '\" is not a valid Ethereum address.');\n    address = address.toLowerCase().replace(/^0x/i, '');\n    var addressHash = utils.sha3(address).replace(/^0x/i, '');\n    var checksumAddress = '0x';\n    for (var i = 0; i < address.length; i++) {\n        // If ith character is 8 to f then make it uppercase\n        if (parseInt(addressHash[i], 16) > 7) {\n            checksumAddress += address[i].toUpperCase();\n        }\n        else {\n            checksumAddress += address[i];\n        }\n    }\n    return checksumAddress;\n};\n/**\n * Returns -1 if a<b, 1 if a>b; 0 if a == b.\n * For more details on this type of function, see\n * developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\n * Block tag `safe` and `block number` combination param is not supported\n * @method compareBlockNumbers\n *\n * @param {String|Number|BN} a\n *\n * @param {String|Number|BN} b\n *\n * @returns {Number} -1, 0, or 1\n */\nvar compareBlockNumbers = function (a, b) {\n    // Increasing order: (genesis = earliest), safe, (finalized ~ latest), pending\n    // safe vs block-num cant be compared as block number provided can be on left or right side of safe tag, until safe tag block number is extracted and compared\n    if (a === b) {\n        return 0;\n    }\n    else if ((\"genesis\" === a || \"earliest\" === a || 0 === a) && (\"genesis\" === b || \"earliest\" === b || 0 === b)) {\n        return 0;\n    }\n    else if (\"genesis\" === a || \"earliest\" === a || a === 0) {\n        // b !== a, thus a < b\n        return -1;\n    }\n    else if (\"genesis\" === b || \"earliest\" === b || b === 0) {\n        // b !== a, thus a > b\n        return 1;\n    }\n    else if (a === \"latest\" || a === \"finalized\") {\n        if (b === \"pending\") {\n            return -1;\n        }\n        else {\n            // b !== (\"pending\" OR \"latest\"), thus a > b\n            return 1;\n        }\n    }\n    else if (b === \"latest\" || b === \"finalized\") {\n        if (a === \"pending\") {\n            return 1;\n        }\n        else {\n            // b !== (\"pending\" OR \"latest\"), thus a > b\n            return -1;\n        }\n    }\n    else if (a === \"pending\") {\n        // b (== OR <) \"latest\", thus a > b\n        return 1;\n    }\n    else if (b === \"pending\") {\n        return -1;\n    }\n    else if (a === \"safe\" || b === \"safe\") {\n        // either a or b is \"safe\" and the other one did not fall into any of the conditions above, so the other one is a number\n        return undefined;\n    }\n    else {\n        let bnA = new BN(a);\n        let bnB = new BN(b);\n        if (bnA.lt(bnB)) {\n            return -1;\n        }\n        else if (bnA.eq(bnB)) {\n            return 0;\n        }\n        else {\n            return 1;\n        }\n    }\n};\nmodule.exports = {\n    _fireError: _fireError,\n    _jsonInterfaceMethodToString: _jsonInterfaceMethodToString,\n    _flattenTypes: _flattenTypes,\n    // extractDisplayName: extractDisplayName,\n    // extractTypeName: extractTypeName,\n    randomHex: randomHex,\n    BN: utils.BN,\n    isBN: utils.isBN,\n    isBigNumber: utils.isBigNumber,\n    isHex: utils.isHex,\n    isHexStrict: utils.isHexStrict,\n    sha3: utils.sha3,\n    sha3Raw: utils.sha3Raw,\n    keccak256: utils.sha3,\n    soliditySha3: soliditySha3.soliditySha3,\n    soliditySha3Raw: soliditySha3.soliditySha3Raw,\n    encodePacked: soliditySha3.encodePacked,\n    isAddress: utils.isAddress,\n    checkAddressChecksum: utils.checkAddressChecksum,\n    toChecksumAddress: toChecksumAddress,\n    toHex: utils.toHex,\n    toBN: utils.toBN,\n    bytesToHex: utils.bytesToHex,\n    hexToBytes: utils.hexToBytes,\n    hexToNumberString: utils.hexToNumberString,\n    hexToNumber: utils.hexToNumber,\n    toDecimal: utils.hexToNumber,\n    numberToHex: utils.numberToHex,\n    fromDecimal: utils.numberToHex,\n    hexToUtf8: utils.hexToUtf8,\n    hexToString: utils.hexToUtf8,\n    toUtf8: utils.hexToUtf8,\n    stripHexPrefix: utils.stripHexPrefix,\n    utf8ToHex: utils.utf8ToHex,\n    stringToHex: utils.utf8ToHex,\n    fromUtf8: utils.utf8ToHex,\n    hexToAscii: hexToAscii,\n    toAscii: hexToAscii,\n    asciiToHex: asciiToHex,\n    fromAscii: asciiToHex,\n    unitMap: ethjsUnit.unitMap,\n    toWei: toWei,\n    fromWei: fromWei,\n    padLeft: utils.leftPad,\n    leftPad: utils.leftPad,\n    padRight: utils.rightPad,\n    rightPad: utils.rightPad,\n    toTwosComplement: utils.toTwosComplement,\n    isBloom: utils.isBloom,\n    isUserEthereumAddressInBloom: utils.isUserEthereumAddressInBloom,\n    isContractAddressInBloom: utils.isContractAddressInBloom,\n    isTopic: utils.isTopic,\n    isTopicInBloom: utils.isTopicInBloom,\n    isInBloom: utils.isInBloom,\n    compareBlockNumbers: compareBlockNumbers,\n    toNumber: utils.toNumber\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViMy11dGlsc0AxLjEwLjAvbm9kZV9tb2R1bGVzL3dlYjMtdXRpbHMvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxvR0FBWTtBQUNwQyxZQUFZLG1CQUFPLENBQUMscUdBQVk7QUFDaEMsbUJBQW1CLG1CQUFPLENBQUMsbUhBQW1CO0FBQzlDLGtCQUFrQixtQkFBTyxDQUFDLG1HQUFhO0FBQ3ZDLFNBQVMsbUJBQU8sQ0FBQyxrRkFBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUSw0Q0FBNEM7QUFDL0QsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckIsV0FBVyxLQUFLO0FBQ2hCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxRQUFRO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5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c291cmNlcyI6WyJ3ZWJwYWNrOi8va2lja3N0YXJ0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL3dlYjMtdXRpbHNAMS4xMC4wL25vZGVfbW9kdWxlcy93ZWIzLXV0aWxzL2xpYi9pbmRleC5qcz8wMjRiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiAqL1xuLyoqXG4gKiBAZmlsZSB1dGlscy5qc1xuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAcGFyaXR5LmlvPlxuICogQGF1dGhvciBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZXJldW0ub3JnPlxuICogQGRhdGUgMjAxN1xuICovXG52YXIgZXRoanNVbml0ID0gcmVxdWlyZSgnZXRoanMtdW5pdCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscy5qcycpO1xudmFyIHNvbGlkaXR5U2hhMyA9IHJlcXVpcmUoJy4vc29saWRpdHlTaGEzLmpzJyk7XG52YXIgcmFuZG9tYnl0ZXMgPSByZXF1aXJlKCdyYW5kb21ieXRlcycpO1xudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbi8qKlxuICogRmlyZXMgYW4gZXJyb3IgaW4gYW4gZXZlbnQgZW1pdHRlciBhbmQgY2FsbGJhY2sgYW5kIHJldHVybnMgdGhlIGV2ZW50ZW1pdHRlclxuICpcbiAqIEBtZXRob2QgX2ZpcmVFcnJvclxuICogQHBhcmFtIHtPYmplY3R9IGVycm9yIGEgc3RyaW5nLCBhIGVycm9yLCBvciBhbiBvYmplY3Qgd2l0aCB7bWVzc2FnZSwgZGF0YX1cbiAqIEBwYXJhbSB7T2JqZWN0fSBlbWl0dGVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0ge2FueX0gb3B0aW9uYWxEYXRhXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBlbWl0dGVyXG4gKi9cbnZhciBfZmlyZUVycm9yID0gZnVuY3Rpb24gKGVycm9yLCBlbWl0dGVyLCByZWplY3QsIGNhbGxiYWNrLCBvcHRpb25hbERhdGEpIHtcbiAgICAvKmpzaGludCBtYXhjb21wbGV4aXR5OiAxMCAqL1xuICAgIC8vIGFkZCBkYXRhIGlmIGdpdmVuXG4gICAgaWYgKCEhZXJyb3IgJiYgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiAhKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpICYmIGVycm9yLmRhdGEpIHtcbiAgICAgICAgaWYgKCEhZXJyb3IuZGF0YSAmJiB0eXBlb2YgZXJyb3IuZGF0YSA9PT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShlcnJvci5kYXRhKSkge1xuICAgICAgICAgICAgZXJyb3IuZGF0YSA9IEpTT04uc3RyaW5naWZ5KGVycm9yLmRhdGEsIG51bGwsIDIpO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yID0gZXJyb3IubWVzc2FnZSArIFwiXFxuXCIgKyBlcnJvci5kYXRhO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihlcnJvcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyb3IsIG9wdGlvbmFsRGF0YSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVqZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIHN1cHByZXNzIHVuY2F0Y2hlZCBlcnJvciBpZiBhbiBlcnJvciBsaXN0ZW5lciBpcyBwcmVzZW50XG4gICAgICAgIC8vIE9SIHN1cHByZXNzIHVuY2F0Y2hlZCBlcnJvciBpZiBhbiBjYWxsYmFjayBsaXN0ZW5lciBpcyBwcmVzZW50XG4gICAgICAgIGlmIChlbWl0dGVyICYmXG4gICAgICAgICAgICAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJzID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAgICAgZW1pdHRlci5saXN0ZW5lcnMoJ2Vycm9yJykubGVuZ3RoKSB8fCB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIuY2F0Y2goZnVuY3Rpb24gKCkgeyB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWplY3QgbGF0ZXIsIHRvIGJlIGFibGUgdG8gcmV0dXJuIGVtaXR0ZXJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9LCAxKTtcbiAgICB9XG4gICAgaWYgKGVtaXR0ZXIgJiYgdHlwZW9mIGVtaXR0ZXIuZW1pdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBlbWl0IGxhdGVyLCB0byBiZSBhYmxlIHRvIHJldHVybiBlbWl0dGVyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdlcnJvcicsIGVycm9yLCBvcHRpb25hbERhdGEpO1xuICAgICAgICAgICAgZW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgfSwgMSk7XG4gICAgfVxuICAgIHJldHVybiBlbWl0dGVyO1xufTtcbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIGZ1bGwgZnVuY3Rpb24vZXZlbnQgbmFtZSBmcm9tIGpzb24gYWJpXG4gKlxuICogQG1ldGhvZCBfanNvbkludGVyZmFjZU1ldGhvZFRvU3RyaW5nXG4gKiBAcGFyYW0ge09iamVjdH0ganNvblxuICogQHJldHVybiB7U3RyaW5nfSBmdWxsIGZ1bmN0aW9uL2V2ZW50IG5hbWVcbiAqL1xudmFyIF9qc29uSW50ZXJmYWNlTWV0aG9kVG9TdHJpbmcgPSBmdW5jdGlvbiAoanNvbikge1xuICAgIGlmICghIWpzb24gJiYgdHlwZW9mIGpzb24gPT09ICdvYmplY3QnICYmIGpzb24ubmFtZSAmJiBqc29uLm5hbWUuaW5kZXhPZignKCcpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4ganNvbi5uYW1lO1xuICAgIH1cbiAgICByZXR1cm4ganNvbi5uYW1lICsgJygnICsgX2ZsYXR0ZW5UeXBlcyhmYWxzZSwganNvbi5pbnB1dHMpLmpvaW4oJywnKSArICcpJztcbn07XG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGZsYXR0ZW4ganNvbiBhYmkgaW5wdXRzL291dHB1dHMgaW50byBhbiBhcnJheSBvZiB0eXBlLXJlcHJlc2VudGluZy1zdHJpbmdzXG4gKlxuICogQG1ldGhvZCBfZmxhdHRlblR5cGVzXG4gKiBAcGFyYW0ge2Jvb2x9IGluY2x1ZGVUdXBsZVxuICogQHBhcmFtIHtPYmplY3R9IHB1dHNcbiAqIEByZXR1cm4ge0FycmF5fSBwYXJhbWV0ZXJzIGFzIHN0cmluZ3NcbiAqL1xudmFyIF9mbGF0dGVuVHlwZXMgPSBmdW5jdGlvbiAoaW5jbHVkZVR1cGxlLCBwdXRzKSB7XG4gICAgLy8gY29uc29sZS5sb2coXCJlbnRlcmVkIF9mbGF0dGVuVHlwZXMuIGlucHV0cy9vdXRwdXRzOiBcIiArIHB1dHMpXG4gICAgdmFyIHR5cGVzID0gW107XG4gICAgcHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICBpZiAodHlwZW9mIHBhcmFtLmNvbXBvbmVudHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAocGFyYW0udHlwZS5zdWJzdHJpbmcoMCwgNSkgIT09ICd0dXBsZScpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbXBvbmVudHMgZm91bmQgYnV0IHR5cGUgaXMgbm90IHR1cGxlOyByZXBvcnQgb24gR2l0SHViJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gJyc7XG4gICAgICAgICAgICB2YXIgYXJyYXlCcmFja2V0ID0gcGFyYW0udHlwZS5pbmRleE9mKCdbJyk7XG4gICAgICAgICAgICBpZiAoYXJyYXlCcmFja2V0ID49IDApIHtcbiAgICAgICAgICAgICAgICBzdWZmaXggPSBwYXJhbS50eXBlLnN1YnN0cmluZyhhcnJheUJyYWNrZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IF9mbGF0dGVuVHlwZXMoaW5jbHVkZVR1cGxlLCBwYXJhbS5jb21wb25lbnRzKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwicmVzdWx0IHNob3VsZCBoYXZlIHRoaW5nczogXCIgKyByZXN1bHQpXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpICYmIGluY2x1ZGVUdXBsZSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiaW5jbHVkZSB0dXBsZSB3b3JkLCBhbmQgaXRzIGFuIGFycmF5LiBqb2luaW5nLi4uOiBcIiArIHJlc3VsdC50eXBlcylcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKCd0dXBsZSgnICsgcmVzdWx0LmpvaW4oJywnKSArICcpJyArIHN1ZmZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaW5jbHVkZVR1cGxlKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJkb24ndCBpbmNsdWRlIHR1cGxlLCBidXQgaXRzIGFuIGFycmF5LiBqb2luaW5nLi4uOiBcIiArIHJlc3VsdClcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKCcoJyArIHJlc3VsdC5qb2luKCcsJykgKyAnKScgKyBzdWZmaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJpdHMgYSBzaW5nbGUgdHlwZSB3aXRoaW4gYSB0dXBsZTogXCIgKyByZXN1bHQudHlwZXMpXG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgnKCcgKyByZXN1bHQgKyAnKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJpdHMgYSB0eXBlIGFuZCBub3QgZGlyZWN0bHkgaW4gYSB0dXBsZTogXCIgKyBwYXJhbS50eXBlKVxuICAgICAgICAgICAgdHlwZXMucHVzaChwYXJhbS50eXBlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0eXBlcztcbn07XG4vKipcbiAqIFJldHVybnMgYSByYW5kb20gaGV4IHN0cmluZyBieSB0aGUgZ2l2ZW4gYnl0ZXMgc2l6ZVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzaXplXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG52YXIgcmFuZG9tSGV4ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICByZXR1cm4gJzB4JyArIHJhbmRvbWJ5dGVzKHNpemUpLnRvU3RyaW5nKCdoZXgnKTtcbn07XG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGFzY2lpIGZyb20gaXQncyBoZXggcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAbWV0aG9kIGhleFRvQXNjaWlcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZXhcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGFzY2lpIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBoZXggdmFsdWVcbiAqL1xudmFyIGhleFRvQXNjaWkgPSBmdW5jdGlvbiAoaGV4KSB7XG4gICAgaWYgKCF1dGlscy5pc0hleFN0cmljdChoZXgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwYXJhbWV0ZXIgbXVzdCBiZSBhIHZhbGlkIEhFWCBzdHJpbmcuJyk7XG4gICAgdmFyIHN0ciA9IFwiXCI7XG4gICAgdmFyIGkgPSAwLCBsID0gaGV4Lmxlbmd0aDtcbiAgICBpZiAoaGV4LnN1YnN0cmluZygwLCAyKSA9PT0gJzB4Jykge1xuICAgICAgICBpID0gMjtcbiAgICB9XG4gICAgZm9yICg7IGkgPCBsOyBpICs9IDIpIHtcbiAgICAgICAgdmFyIGNvZGUgPSBwYXJzZUludChoZXguc2xpY2UoaSwgaSArIDIpLCAxNik7XG4gICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufTtcbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgaGV4IHJlcHJlc2VudGF0aW9uIChwcmVmaXhlZCBieSAweCkgb2YgYXNjaWkgc3RyaW5nXG4gKlxuICogQG1ldGhvZCBhc2NpaVRvSGV4XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBoZXggcmVwcmVzZW50YXRpb24gb2YgaW5wdXQgc3RyaW5nXG4gKi9cbnZhciBhc2NpaVRvSGV4ID0gZnVuY3Rpb24gKHN0cikge1xuICAgIGlmICghc3RyKVxuICAgICAgICByZXR1cm4gXCIweDAwXCI7XG4gICAgdmFyIGhleCA9IFwiXCI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgdmFyIG4gPSBjb2RlLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaGV4ICs9IG4ubGVuZ3RoIDwgMiA/ICcwJyArIG4gOiBuO1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgaGV4O1xufTtcbi8qKlxuICogUmV0dXJucyB2YWx1ZSBvZiB1bml0IGluIFdlaVxuICpcbiAqIEBtZXRob2QgZ2V0VW5pdFZhbHVlXG4gKiBAcGFyYW0ge1N0cmluZ30gdW5pdCB0aGUgdW5pdCB0byBjb252ZXJ0IHRvLCBkZWZhdWx0IGV0aGVyXG4gKiBAcmV0dXJucyB7Qk59IHZhbHVlIG9mIHRoZSB1bml0IChpbiBXZWkpXG4gKiBAdGhyb3dzIGVycm9yIGlmIHRoZSB1bml0IGlzIG5vdCBjb3JyZWN0OndcbiAqL1xudmFyIGdldFVuaXRWYWx1ZSA9IGZ1bmN0aW9uICh1bml0KSB7XG4gICAgdW5pdCA9IHVuaXQgPyB1bml0LnRvTG93ZXJDYXNlKCkgOiAnZXRoZXInO1xuICAgIGlmICghZXRoanNVbml0LnVuaXRNYXBbdW5pdF0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIHVuaXQgXCInICsgdW5pdCArICdcIiBkb2VzblxcJ3QgZXhpc3QsIHBsZWFzZSB1c2UgdGhlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHVuaXRzJyArIEpTT04uc3RyaW5naWZ5KGV0aGpzVW5pdC51bml0TWFwLCBudWxsLCAyKSk7XG4gICAgfVxuICAgIHJldHVybiB1bml0O1xufTtcbi8qKlxuICogVGFrZXMgYSBudW1iZXIgb2Ygd2VpIGFuZCBjb252ZXJ0cyBpdCB0byBhbnkgb3RoZXIgZXRoZXIgdW5pdC5cbiAqXG4gKiBQb3NzaWJsZSB1bml0cyBhcmU6XG4gKiAgIFNJIFNob3J0ICAgU0kgRnVsbCAgICAgICAgRWZmaWd5ICAgICAgIE90aGVyXG4gKiAtIGt3ZWkgICAgICAgZmVtdG9ldGhlciAgICAgYmFiYmFnZVxuICogLSBtd2VpICAgICAgIHBpY29ldGhlciAgICAgIGxvdmVsYWNlXG4gKiAtIGd3ZWkgICAgICAgbmFub2V0aGVyICAgICAgc2hhbm5vbiAgICAgIG5hbm9cbiAqIC0gLS0gICAgICAgICBtaWNyb2V0aGVyICAgICBzemFibyAgICAgICAgbWljcm9cbiAqIC0gLS0gICAgICAgICBtaWxsaWV0aGVyICAgICBmaW5uZXkgICAgICAgbWlsbGlcbiAqIC0gZXRoZXIgICAgICAtLSAgICAgICAgICAgICAtLVxuICogLSBrZXRoZXIgICAgICAgICAgICAgICAgICAgIC0tICAgICAgICAgICBncmFuZFxuICogLSBtZXRoZXJcbiAqIC0gZ2V0aGVyXG4gKiAtIHRldGhlclxuICpcbiAqIEBtZXRob2QgZnJvbVdlaVxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBudW1iZXIgY2FuIGJlIGEgbnVtYmVyLCBudW1iZXIgc3RyaW5nIG9yIGEgSEVYIG9mIGEgZGVjaW1hbFxuICogQHBhcmFtIHtTdHJpbmd9IHVuaXQgdGhlIHVuaXQgdG8gY29udmVydCB0bywgZGVmYXVsdCBldGhlclxuICogQHJldHVybiB7U3RyaW5nfE9iamVjdH0gV2hlbiBnaXZlbiBhIEJOIG9iamVjdCBpdCByZXR1cm5zIG9uZSBhcyB3ZWxsLCBvdGhlcndpc2UgYSBudW1iZXJcbiAqL1xudmFyIGZyb21XZWkgPSBmdW5jdGlvbiAobnVtYmVyLCB1bml0KSB7XG4gICAgdW5pdCA9IGdldFVuaXRWYWx1ZSh1bml0KTtcbiAgICBpZiAoIXV0aWxzLmlzQk4obnVtYmVyKSAmJiAhKHR5cGVvZiBudW1iZXIgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwYXNzIG51bWJlcnMgYXMgc3RyaW5ncyBvciBCTiBvYmplY3RzIHRvIGF2b2lkIHByZWNpc2lvbiBlcnJvcnMuJyk7XG4gICAgfVxuICAgIHJldHVybiB1dGlscy5pc0JOKG51bWJlcikgPyBldGhqc1VuaXQuZnJvbVdlaShudW1iZXIsIHVuaXQpIDogZXRoanNVbml0LmZyb21XZWkobnVtYmVyLCB1bml0KS50b1N0cmluZygxMCk7XG59O1xuLyoqXG4gKiBUYWtlcyBhIG51bWJlciBvZiBhIHVuaXQgYW5kIGNvbnZlcnRzIGl0IHRvIHdlaS5cbiAqXG4gKiBQb3NzaWJsZSB1bml0cyBhcmU6XG4gKiAgIFNJIFNob3J0ICAgU0kgRnVsbCAgICAgICAgRWZmaWd5ICAgICAgIE90aGVyXG4gKiAtIGt3ZWkgICAgICAgZmVtdG9ldGhlciAgICAgYmFiYmFnZVxuICogLSBtd2VpICAgICAgIHBpY29ldGhlciAgICAgIGxvdmVsYWNlXG4gKiAtIGd3ZWkgICAgICAgbmFub2V0aGVyICAgICAgc2hhbm5vbiAgICAgIG5hbm9cbiAqIC0gLS0gICAgICAgICBtaWNyb2V0aGVyICAgICBzemFibyAgICAgICAgbWljcm9cbiAqIC0gLS0gICAgICAgICBtaWNyb2V0aGVyICAgICBzemFibyAgICAgICAgbWljcm9cbiAqIC0gLS0gICAgICAgICBtaWxsaWV0aGVyICAgICBmaW5uZXkgICAgICAgbWlsbGlcbiAqIC0gZXRoZXIgICAgICAtLSAgICAgICAgICAgICAtLVxuICogLSBrZXRoZXIgICAgICAgICAgICAgICAgICAgIC0tICAgICAgICAgICBncmFuZFxuICogLSBtZXRoZXJcbiAqIC0gZ2V0aGVyXG4gKiAtIHRldGhlclxuICpcbiAqIEBtZXRob2QgdG9XZWlcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xCTn0gbnVtYmVyIGNhbiBiZSBhIG51bWJlciwgbnVtYmVyIHN0cmluZyBvciBhIEhFWCBvZiBhIGRlY2ltYWxcbiAqIEBwYXJhbSB7U3RyaW5nfSB1bml0IHRoZSB1bml0IHRvIGNvbnZlcnQgZnJvbSwgZGVmYXVsdCBldGhlclxuICogQHJldHVybiB7U3RyaW5nfE9iamVjdH0gV2hlbiBnaXZlbiBhIEJOIG9iamVjdCBpdCByZXR1cm5zIG9uZSBhcyB3ZWxsLCBvdGhlcndpc2UgYSBudW1iZXJcbiAqL1xudmFyIHRvV2VpID0gZnVuY3Rpb24gKG51bWJlciwgdW5pdCkge1xuICAgIHVuaXQgPSBnZXRVbml0VmFsdWUodW5pdCk7XG4gICAgaWYgKCF1dGlscy5pc0JOKG51bWJlcikgJiYgISh0eXBlb2YgbnVtYmVyID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgcGFzcyBudW1iZXJzIGFzIHN0cmluZ3Mgb3IgQk4gb2JqZWN0cyB0byBhdm9pZCBwcmVjaXNpb24gZXJyb3JzLicpO1xuICAgIH1cbiAgICByZXR1cm4gdXRpbHMuaXNCTihudW1iZXIpID8gZXRoanNVbml0LnRvV2VpKG51bWJlciwgdW5pdCkgOiBldGhqc1VuaXQudG9XZWkobnVtYmVyLCB1bml0KS50b1N0cmluZygxMCk7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyB0byBhIGNoZWNrc3VtIGFkZHJlc3NcbiAqXG4gKiBAbWV0aG9kIHRvQ2hlY2tzdW1BZGRyZXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyB0aGUgZ2l2ZW4gSEVYIGFkZHJlc3NcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xudmFyIHRvQ2hlY2tzdW1BZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICBpZiAodHlwZW9mIGFkZHJlc3MgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgaWYgKCEvXigweCk/WzAtOWEtZl17NDB9JC9pLnRlc3QoYWRkcmVzcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignR2l2ZW4gYWRkcmVzcyBcIicgKyBhZGRyZXNzICsgJ1wiIGlzIG5vdCBhIHZhbGlkIEV0aGVyZXVtIGFkZHJlc3MuJyk7XG4gICAgYWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9eMHgvaSwgJycpO1xuICAgIHZhciBhZGRyZXNzSGFzaCA9IHV0aWxzLnNoYTMoYWRkcmVzcykucmVwbGFjZSgvXjB4L2ksICcnKTtcbiAgICB2YXIgY2hlY2tzdW1BZGRyZXNzID0gJzB4JztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFkZHJlc3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gSWYgaXRoIGNoYXJhY3RlciBpcyA4IHRvIGYgdGhlbiBtYWtlIGl0IHVwcGVyY2FzZVxuICAgICAgICBpZiAocGFyc2VJbnQoYWRkcmVzc0hhc2hbaV0sIDE2KSA+IDcpIHtcbiAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyArPSBhZGRyZXNzW2ldLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGVja3N1bUFkZHJlc3MgKz0gYWRkcmVzc1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hlY2tzdW1BZGRyZXNzO1xufTtcbi8qKlxuICogUmV0dXJucyAtMSBpZiBhPGIsIDEgaWYgYT5iOyAwIGlmIGEgPT0gYi5cbiAqIEZvciBtb3JlIGRldGFpbHMgb24gdGhpcyB0eXBlIG9mIGZ1bmN0aW9uLCBzZWVcbiAqIGRldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb3J0XG4gKiBCbG9jayB0YWcgYHNhZmVgIGFuZCBgYmxvY2sgbnVtYmVyYCBjb21iaW5hdGlvbiBwYXJhbSBpcyBub3Qgc3VwcG9ydGVkXG4gKiBAbWV0aG9kIGNvbXBhcmVCbG9ja051bWJlcnNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8Qk59IGFcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8Qk59IGJcbiAqXG4gKiBAcmV0dXJucyB7TnVtYmVyfSAtMSwgMCwgb3IgMVxuICovXG52YXIgY29tcGFyZUJsb2NrTnVtYmVycyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgLy8gSW5jcmVhc2luZyBvcmRlcjogKGdlbmVzaXMgPSBlYXJsaWVzdCksIHNhZmUsIChmaW5hbGl6ZWQgfiBsYXRlc3QpLCBwZW5kaW5nXG4gICAgLy8gc2FmZSB2cyBibG9jay1udW0gY2FudCBiZSBjb21wYXJlZCBhcyBibG9jayBudW1iZXIgcHJvdmlkZWQgY2FuIGJlIG9uIGxlZnQgb3IgcmlnaHQgc2lkZSBvZiBzYWZlIHRhZywgdW50aWwgc2FmZSB0YWcgYmxvY2sgbnVtYmVyIGlzIGV4dHJhY3RlZCBhbmQgY29tcGFyZWRcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoKFwiZ2VuZXNpc1wiID09PSBhIHx8IFwiZWFybGllc3RcIiA9PT0gYSB8fCAwID09PSBhKSAmJiAoXCJnZW5lc2lzXCIgPT09IGIgfHwgXCJlYXJsaWVzdFwiID09PSBiIHx8IDAgPT09IGIpKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlbHNlIGlmIChcImdlbmVzaXNcIiA9PT0gYSB8fCBcImVhcmxpZXN0XCIgPT09IGEgfHwgYSA9PT0gMCkge1xuICAgICAgICAvLyBiICE9PSBhLCB0aHVzIGEgPCBiXG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoXCJnZW5lc2lzXCIgPT09IGIgfHwgXCJlYXJsaWVzdFwiID09PSBiIHx8IGIgPT09IDApIHtcbiAgICAgICAgLy8gYiAhPT0gYSwgdGh1cyBhID4gYlxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYSA9PT0gXCJsYXRlc3RcIiB8fCBhID09PSBcImZpbmFsaXplZFwiKSB7XG4gICAgICAgIGlmIChiID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYiAhPT0gKFwicGVuZGluZ1wiIE9SIFwibGF0ZXN0XCIpLCB0aHVzIGEgPiBiXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChiID09PSBcImxhdGVzdFwiIHx8IGIgPT09IFwiZmluYWxpemVkXCIpIHtcbiAgICAgICAgaWYgKGEgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGIgIT09IChcInBlbmRpbmdcIiBPUiBcImxhdGVzdFwiKSwgdGh1cyBhID4gYlxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGEgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgIC8vIGIgKD09IE9SIDwpIFwibGF0ZXN0XCIsIHRodXMgYSA+IGJcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGIgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYSA9PT0gXCJzYWZlXCIgfHwgYiA9PT0gXCJzYWZlXCIpIHtcbiAgICAgICAgLy8gZWl0aGVyIGEgb3IgYiBpcyBcInNhZmVcIiBhbmQgdGhlIG90aGVyIG9uZSBkaWQgbm90IGZhbGwgaW50byBhbnkgb2YgdGhlIGNvbmRpdGlvbnMgYWJvdmUsIHNvIHRoZSBvdGhlciBvbmUgaXMgYSBudW1iZXJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBibkEgPSBuZXcgQk4oYSk7XG4gICAgICAgIGxldCBibkIgPSBuZXcgQk4oYik7XG4gICAgICAgIGlmIChibkEubHQoYm5CKSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJuQS5lcShibkIpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIF9maXJlRXJyb3I6IF9maXJlRXJyb3IsXG4gICAgX2pzb25JbnRlcmZhY2VNZXRob2RUb1N0cmluZzogX2pzb25JbnRlcmZhY2VNZXRob2RUb1N0cmluZyxcbiAgICBfZmxhdHRlblR5cGVzOiBfZmxhdHRlblR5cGVzLFxuICAgIC8vIGV4dHJhY3REaXNwbGF5TmFtZTogZXh0cmFjdERpc3BsYXlOYW1lLFxuICAgIC8vIGV4dHJhY3RUeXBlTmFtZTogZXh0cmFjdFR5cGVOYW1lLFxuICAgIHJhbmRvbUhleDogcmFuZG9tSGV4LFxuICAgIEJOOiB1dGlscy5CTixcbiAgICBpc0JOOiB1dGlscy5pc0JOLFxuICAgIGlzQmlnTnVtYmVyOiB1dGlscy5pc0JpZ051bWJlcixcbiAgICBpc0hleDogdXRpbHMuaXNIZXgsXG4gICAgaXNIZXhTdHJpY3Q6IHV0aWxzLmlzSGV4U3RyaWN0LFxuICAgIHNoYTM6IHV0aWxzLnNoYTMsXG4gICAgc2hhM1JhdzogdXRpbHMuc2hhM1JhdyxcbiAgICBrZWNjYWsyNTY6IHV0aWxzLnNoYTMsXG4gICAgc29saWRpdHlTaGEzOiBzb2xpZGl0eVNoYTMuc29saWRpdHlTaGEzLFxuICAgIHNvbGlkaXR5U2hhM1Jhdzogc29saWRpdHlTaGEzLnNvbGlkaXR5U2hhM1JhdyxcbiAgICBlbmNvZGVQYWNrZWQ6IHNvbGlkaXR5U2hhMy5lbmNvZGVQYWNrZWQsXG4gICAgaXNBZGRyZXNzOiB1dGlscy5pc0FkZHJlc3MsXG4gICAgY2hlY2tBZGRyZXNzQ2hlY2tzdW06IHV0aWxzLmNoZWNrQWRkcmVzc0NoZWNrc3VtLFxuICAgIHRvQ2hlY2tzdW1BZGRyZXNzOiB0b0NoZWNrc3VtQWRkcmVzcyxcbiAgICB0b0hleDogdXRpbHMudG9IZXgsXG4gICAgdG9CTjogdXRpbHMudG9CTixcbiAgICBieXRlc1RvSGV4OiB1dGlscy5ieXRlc1RvSGV4LFxuICAgIGhleFRvQnl0ZXM6IHV0aWxzLmhleFRvQnl0ZXMsXG4gICAgaGV4VG9OdW1iZXJTdHJpbmc6IHV0aWxzLmhleFRvTnVtYmVyU3RyaW5nLFxuICAgIGhleFRvTnVtYmVyOiB1dGlscy5oZXhUb051bWJlcixcbiAgICB0b0RlY2ltYWw6IHV0aWxzLmhleFRvTnVtYmVyLFxuICAgIG51bWJlclRvSGV4OiB1dGlscy5udW1iZXJUb0hleCxcbiAgICBmcm9tRGVjaW1hbDogdXRpbHMubnVtYmVyVG9IZXgsXG4gICAgaGV4VG9VdGY4OiB1dGlscy5oZXhUb1V0ZjgsXG4gICAgaGV4VG9TdHJpbmc6IHV0aWxzLmhleFRvVXRmOCxcbiAgICB0b1V0Zjg6IHV0aWxzLmhleFRvVXRmOCxcbiAgICBzdHJpcEhleFByZWZpeDogdXRpbHMuc3RyaXBIZXhQcmVmaXgsXG4gICAgdXRmOFRvSGV4OiB1dGlscy51dGY4VG9IZXgsXG4gICAgc3RyaW5nVG9IZXg6IHV0aWxzLnV0ZjhUb0hleCxcbiAgICBmcm9tVXRmODogdXRpbHMudXRmOFRvSGV4LFxuICAgIGhleFRvQXNjaWk6IGhleFRvQXNjaWksXG4gICAgdG9Bc2NpaTogaGV4VG9Bc2NpaSxcbiAgICBhc2NpaVRvSGV4OiBhc2NpaVRvSGV4LFxuICAgIGZyb21Bc2NpaTogYXNjaWlUb0hleCxcbiAgICB1bml0TWFwOiBldGhqc1VuaXQudW5pdE1hcCxcbiAgICB0b1dlaTogdG9XZWksXG4gICAgZnJvbVdlaTogZnJvbVdlaSxcbiAgICBwYWRMZWZ0OiB1dGlscy5sZWZ0UGFkLFxuICAgIGxlZnRQYWQ6IHV0aWxzLmxlZnRQYWQsXG4gICAgcGFkUmlnaHQ6IHV0aWxzLnJpZ2h0UGFkLFxuICAgIHJpZ2h0UGFkOiB1dGlscy5yaWdodFBhZCxcbiAgICB0b1R3b3NDb21wbGVtZW50OiB1dGlscy50b1R3b3NDb21wbGVtZW50LFxuICAgIGlzQmxvb206IHV0aWxzLmlzQmxvb20sXG4gICAgaXNVc2VyRXRoZXJldW1BZGRyZXNzSW5CbG9vbTogdXRpbHMuaXNVc2VyRXRoZXJldW1BZGRyZXNzSW5CbG9vbSxcbiAgICBpc0NvbnRyYWN0QWRkcmVzc0luQmxvb206IHV0aWxzLmlzQ29udHJhY3RBZGRyZXNzSW5CbG9vbSxcbiAgICBpc1RvcGljOiB1dGlscy5pc1RvcGljLFxuICAgIGlzVG9waWNJbkJsb29tOiB1dGlscy5pc1RvcGljSW5CbG9vbSxcbiAgICBpc0luQmxvb206IHV0aWxzLmlzSW5CbG9vbSxcbiAgICBjb21wYXJlQmxvY2tOdW1iZXJzOiBjb21wYXJlQmxvY2tOdW1iZXJzLFxuICAgIHRvTnVtYmVyOiB1dGlscy50b051bWJlclxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/web3-utils@1.10.0/node_modules/web3-utils/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/web3-utils@1.10.0/node_modules/web3-utils/lib/soliditySha3.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.pnpm/web3-utils@1.10.0/node_modules/web3-utils/lib/soliditySha3.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */\n/**\n * @file soliditySha3.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\nvar BN = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/.pnpm/bn.js@5.2.1/node_modules/bn.js/lib/bn.js\");\nvar utils = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/.pnpm/web3-utils@1.10.0/node_modules/web3-utils/lib/utils.js\");\nvar _elementaryName = function (name) {\n    /*jshint maxcomplexity:false */\n    if (name.startsWith('int[')) {\n        return 'int256' + name.slice(3);\n    }\n    else if (name === 'int') {\n        return 'int256';\n    }\n    else if (name.startsWith('uint[')) {\n        return 'uint256' + name.slice(4);\n    }\n    else if (name === 'uint') {\n        return 'uint256';\n    }\n    else if (name.startsWith('fixed[')) {\n        return 'fixed128x128' + name.slice(5);\n    }\n    else if (name === 'fixed') {\n        return 'fixed128x128';\n    }\n    else if (name.startsWith('ufixed[')) {\n        return 'ufixed128x128' + name.slice(6);\n    }\n    else if (name === 'ufixed') {\n        return 'ufixed128x128';\n    }\n    return name;\n};\n// Parse N from type<N>\nvar _parseTypeN = function (type) {\n    var typesize = /^\\D+(\\d+).*$/.exec(type);\n    return typesize ? parseInt(typesize[1], 10) : null;\n};\n// Parse N from type[<N>]\nvar _parseTypeNArray = function (type) {\n    var arraySize = /^\\D+\\d*\\[(\\d+)\\]$/.exec(type);\n    return arraySize ? parseInt(arraySize[1], 10) : null;\n};\nvar _parseNumber = function (arg) {\n    var type = typeof arg;\n    if (type === 'string') {\n        if (utils.isHexStrict(arg)) {\n            return new BN(arg.replace(/0x/i, ''), 16);\n        }\n        else {\n            return new BN(arg, 10);\n        }\n    }\n    else if (type === 'number') {\n        return new BN(arg);\n    }\n    else if (utils.isBigNumber(arg)) {\n        return new BN(arg.toString(10));\n    }\n    else if (utils.isBN(arg)) {\n        return arg;\n    }\n    else {\n        throw new Error(arg + ' is not a number');\n    }\n};\nvar _solidityPack = function (type, value, arraySize) {\n    /*jshint maxcomplexity:false */\n    var size, num;\n    type = _elementaryName(type);\n    if (type === 'bytes') {\n        if (value.replace(/^0x/i, '').length % 2 !== 0) {\n            throw new Error('Invalid bytes characters ' + value.length);\n        }\n        return value;\n    }\n    else if (type === 'string') {\n        return utils.utf8ToHex(value);\n    }\n    else if (type === 'bool') {\n        return value ? '01' : '00';\n    }\n    else if (type.startsWith('address')) {\n        if (arraySize) {\n            size = 64;\n        }\n        else {\n            size = 40;\n        }\n        if (!utils.isAddress(value)) {\n            throw new Error(value + ' is not a valid address, or the checksum is invalid.');\n        }\n        return utils.leftPad(value.toLowerCase(), size);\n    }\n    size = _parseTypeN(type);\n    if (type.startsWith('bytes')) {\n        if (!size) {\n            throw new Error('bytes[] not yet supported in solidity');\n        }\n        // must be 32 byte slices when in an array\n        if (arraySize) {\n            size = 32;\n        }\n        if (size < 1 || size > 32 || size < value.replace(/^0x/i, '').length / 2) {\n            throw new Error('Invalid bytes' + size + ' for ' + value);\n        }\n        return utils.rightPad(value, size * 2);\n    }\n    else if (type.startsWith('uint')) {\n        if ((size % 8) || (size < 8) || (size > 256)) {\n            throw new Error('Invalid uint' + size + ' size');\n        }\n        num = _parseNumber(value);\n        if (num.bitLength() > size) {\n            throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + num.bitLength());\n        }\n        if (num.lt(new BN(0))) {\n            throw new Error('Supplied uint ' + num.toString() + ' is negative');\n        }\n        return size ? utils.leftPad(num.toString('hex'), size / 8 * 2) : num;\n    }\n    else if (type.startsWith('int')) {\n        if ((size % 8) || (size < 8) || (size > 256)) {\n            throw new Error('Invalid int' + size + ' size');\n        }\n        num = _parseNumber(value);\n        if (num.bitLength() > size) {\n            throw new Error('Supplied int exceeds width: ' + size + ' vs ' + num.bitLength());\n        }\n        if (num.lt(new BN(0))) {\n            return num.toTwos(size).toString('hex');\n        }\n        else {\n            return size ? utils.leftPad(num.toString('hex'), size / 8 * 2) : num;\n        }\n    }\n    else {\n        // FIXME: support all other types\n        throw new Error('Unsupported or invalid type: ' + type);\n    }\n};\nvar _processSolidityEncodePackedArgs = function (arg) {\n    /*jshint maxcomplexity:false */\n    if (Array.isArray(arg)) {\n        throw new Error('Autodetection of array types is not supported.');\n    }\n    var type, value = '';\n    var hexArg, arraySize;\n    // if type is given\n    if (!!arg && typeof arg === 'object' && (arg.hasOwnProperty('v') || arg.hasOwnProperty('t') || arg.hasOwnProperty('value') || arg.hasOwnProperty('type'))) {\n        type = arg.hasOwnProperty('t') ? arg.t : arg.type;\n        value = arg.hasOwnProperty('v') ? arg.v : arg.value;\n        // otherwise try to guess the type\n    }\n    else {\n        type = utils.toHex(arg, true);\n        value = utils.toHex(arg);\n        if (!type.startsWith('int') && !type.startsWith('uint')) {\n            type = 'bytes';\n        }\n    }\n    if ((type.startsWith('int') || type.startsWith('uint')) && typeof value === 'string' && !/^(-)?0x/i.test(value)) {\n        value = new BN(value);\n    }\n    // get the array size\n    if (Array.isArray(value)) {\n        arraySize = _parseTypeNArray(type);\n        if (arraySize && value.length !== arraySize) {\n            throw new Error(type + ' is not matching the given array ' + JSON.stringify(value));\n        }\n        else {\n            arraySize = value.length;\n        }\n    }\n    if (Array.isArray(value)) {\n        hexArg = value.map(function (val) {\n            return _solidityPack(type, val, arraySize).toString('hex').replace('0x', '');\n        });\n        return hexArg.join('');\n    }\n    else {\n        hexArg = _solidityPack(type, value, arraySize);\n        return hexArg.toString('hex').replace('0x', '');\n    }\n};\n/**\n * Hashes solidity values to a sha3 hash using keccak 256\n *\n * @method soliditySha3\n * @return {Object} the sha3\n */\nvar soliditySha3 = function () {\n    /*jshint maxcomplexity:false */\n    var args = Array.prototype.slice.call(arguments);\n    var hexArgs = args.map(_processSolidityEncodePackedArgs);\n    // console.log(args, hexArgs);\n    // console.log('0x'+ hexArgs.join(''));\n    return utils.sha3('0x' + hexArgs.join(''));\n};\n/**\n * Hashes solidity values to a sha3 hash using keccak 256 but does return the hash of value `null` instead of `null`\n *\n * @method soliditySha3Raw\n * @return {Object} the sha3\n */\nvar soliditySha3Raw = function () {\n    return utils.sha3Raw('0x' + Array.prototype.slice.call(arguments).map(_processSolidityEncodePackedArgs).join(''));\n};\n/**\n * Encode packed args to hex\n *\n * @method encodePacked\n * @return {String} the hex encoded arguments\n */\nvar encodePacked = function () {\n    /*jshint maxcomplexity:false */\n    var args = Array.prototype.slice.call(arguments);\n    var hexArgs = args.map(_processSolidityEncodePackedArgs);\n    return '0x' + hexArgs.join('').toLowerCase();\n};\nmodule.exports = {\n    soliditySha3: soliditySha3,\n    soliditySha3Raw: soliditySha3Raw,\n    encodePacked: encodePacked\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViMy11dGlsc0AxLjEwLjAvbm9kZV9tb2R1bGVzL3dlYjMtdXRpbHMvbGliL3NvbGlkaXR5U2hhMy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsbUJBQU8sQ0FBQyxrRkFBTztBQUN4QixZQUFZLG1CQUFPLENBQUMscUdBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2tpY2tzdGFydC8uL25vZGVfbW9kdWxlcy8ucG5wbS93ZWIzLXV0aWxzQDEuMTAuMC9ub2RlX21vZHVsZXMvd2ViMy11dGlscy9saWIvc29saWRpdHlTaGEzLmpzPzQ4ZWIiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuICovXG4vKipcbiAqIEBmaWxlIHNvbGlkaXR5U2hhMy5qc1xuICogQGF1dGhvciBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZXJldW0ub3JnPlxuICogQGRhdGUgMjAxN1xuICovXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscy5qcycpO1xudmFyIF9lbGVtZW50YXJ5TmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eTpmYWxzZSAqL1xuICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoJ2ludFsnKSkge1xuICAgICAgICByZXR1cm4gJ2ludDI1NicgKyBuYW1lLnNsaWNlKDMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYW1lID09PSAnaW50Jykge1xuICAgICAgICByZXR1cm4gJ2ludDI1Nic7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5hbWUuc3RhcnRzV2l0aCgndWludFsnKSkge1xuICAgICAgICByZXR1cm4gJ3VpbnQyNTYnICsgbmFtZS5zbGljZSg0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZSA9PT0gJ3VpbnQnKSB7XG4gICAgICAgIHJldHVybiAndWludDI1Nic7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5hbWUuc3RhcnRzV2l0aCgnZml4ZWRbJykpIHtcbiAgICAgICAgcmV0dXJuICdmaXhlZDEyOHgxMjgnICsgbmFtZS5zbGljZSg1KTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZSA9PT0gJ2ZpeGVkJykge1xuICAgICAgICByZXR1cm4gJ2ZpeGVkMTI4eDEyOCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5hbWUuc3RhcnRzV2l0aCgndWZpeGVkWycpKSB7XG4gICAgICAgIHJldHVybiAndWZpeGVkMTI4eDEyOCcgKyBuYW1lLnNsaWNlKDYpO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYW1lID09PSAndWZpeGVkJykge1xuICAgICAgICByZXR1cm4gJ3VmaXhlZDEyOHgxMjgnO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZTtcbn07XG4vLyBQYXJzZSBOIGZyb20gdHlwZTxOPlxudmFyIF9wYXJzZVR5cGVOID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICB2YXIgdHlwZXNpemUgPSAvXlxcRCsoXFxkKykuKiQvLmV4ZWModHlwZSk7XG4gICAgcmV0dXJuIHR5cGVzaXplID8gcGFyc2VJbnQodHlwZXNpemVbMV0sIDEwKSA6IG51bGw7XG59O1xuLy8gUGFyc2UgTiBmcm9tIHR5cGVbPE4+XVxudmFyIF9wYXJzZVR5cGVOQXJyYXkgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIHZhciBhcnJheVNpemUgPSAvXlxcRCtcXGQqXFxbKFxcZCspXFxdJC8uZXhlYyh0eXBlKTtcbiAgICByZXR1cm4gYXJyYXlTaXplID8gcGFyc2VJbnQoYXJyYXlTaXplWzFdLCAxMCkgOiBudWxsO1xufTtcbnZhciBfcGFyc2VOdW1iZXIgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgYXJnO1xuICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodXRpbHMuaXNIZXhTdHJpY3QoYXJnKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCTihhcmcucmVwbGFjZSgvMHgvaSwgJycpLCAxNik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJOKGFyZywgMTApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBuZXcgQk4oYXJnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodXRpbHMuaXNCaWdOdW1iZXIoYXJnKSkge1xuICAgICAgICByZXR1cm4gbmV3IEJOKGFyZy50b1N0cmluZygxMCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh1dGlscy5pc0JOKGFyZykpIHtcbiAgICAgICAgcmV0dXJuIGFyZztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihhcmcgKyAnIGlzIG5vdCBhIG51bWJlcicpO1xuICAgIH1cbn07XG52YXIgX3NvbGlkaXR5UGFjayA9IGZ1bmN0aW9uICh0eXBlLCB2YWx1ZSwgYXJyYXlTaXplKSB7XG4gICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eTpmYWxzZSAqL1xuICAgIHZhciBzaXplLCBudW07XG4gICAgdHlwZSA9IF9lbGVtZW50YXJ5TmFtZSh0eXBlKTtcbiAgICBpZiAodHlwZSA9PT0gJ2J5dGVzJykge1xuICAgICAgICBpZiAodmFsdWUucmVwbGFjZSgvXjB4L2ksICcnKS5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZXMgY2hhcmFjdGVycyAnICsgdmFsdWUubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB1dGlscy51dGY4VG9IZXgodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID8gJzAxJyA6ICcwMCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUuc3RhcnRzV2l0aCgnYWRkcmVzcycpKSB7XG4gICAgICAgIGlmIChhcnJheVNpemUpIHtcbiAgICAgICAgICAgIHNpemUgPSA2NDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNpemUgPSA0MDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXV0aWxzLmlzQWRkcmVzcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih2YWx1ZSArICcgaXMgbm90IGEgdmFsaWQgYWRkcmVzcywgb3IgdGhlIGNoZWNrc3VtIGlzIGludmFsaWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHV0aWxzLmxlZnRQYWQodmFsdWUudG9Mb3dlckNhc2UoKSwgc2l6ZSk7XG4gICAgfVxuICAgIHNpemUgPSBfcGFyc2VUeXBlTih0eXBlKTtcbiAgICBpZiAodHlwZS5zdGFydHNXaXRoKCdieXRlcycpKSB7XG4gICAgICAgIGlmICghc2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdieXRlc1tdIG5vdCB5ZXQgc3VwcG9ydGVkIGluIHNvbGlkaXR5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbXVzdCBiZSAzMiBieXRlIHNsaWNlcyB3aGVuIGluIGFuIGFycmF5XG4gICAgICAgIGlmIChhcnJheVNpemUpIHtcbiAgICAgICAgICAgIHNpemUgPSAzMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2l6ZSA8IDEgfHwgc2l6ZSA+IDMyIHx8IHNpemUgPCB2YWx1ZS5yZXBsYWNlKC9eMHgvaSwgJycpLmxlbmd0aCAvIDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlcycgKyBzaXplICsgJyBmb3IgJyArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRpbHMucmlnaHRQYWQodmFsdWUsIHNpemUgKiAyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZS5zdGFydHNXaXRoKCd1aW50JykpIHtcbiAgICAgICAgaWYgKChzaXplICUgOCkgfHwgKHNpemUgPCA4KSB8fCAoc2l6ZSA+IDI1NikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB1aW50JyArIHNpemUgKyAnIHNpemUnKTtcbiAgICAgICAgfVxuICAgICAgICBudW0gPSBfcGFyc2VOdW1iZXIodmFsdWUpO1xuICAgICAgICBpZiAobnVtLmJpdExlbmd0aCgpID4gc2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwbGllZCB1aW50IGV4Y2VlZHMgd2lkdGg6ICcgKyBzaXplICsgJyB2cyAnICsgbnVtLmJpdExlbmd0aCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtLmx0KG5ldyBCTigwKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3VwcGxpZWQgdWludCAnICsgbnVtLnRvU3RyaW5nKCkgKyAnIGlzIG5lZ2F0aXZlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpemUgPyB1dGlscy5sZWZ0UGFkKG51bS50b1N0cmluZygnaGV4JyksIHNpemUgLyA4ICogMikgOiBudW07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUuc3RhcnRzV2l0aCgnaW50JykpIHtcbiAgICAgICAgaWYgKChzaXplICUgOCkgfHwgKHNpemUgPCA4KSB8fCAoc2l6ZSA+IDI1NikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnQnICsgc2l6ZSArICcgc2l6ZScpO1xuICAgICAgICB9XG4gICAgICAgIG51bSA9IF9wYXJzZU51bWJlcih2YWx1ZSk7XG4gICAgICAgIGlmIChudW0uYml0TGVuZ3RoKCkgPiBzaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBsaWVkIGludCBleGNlZWRzIHdpZHRoOiAnICsgc2l6ZSArICcgdnMgJyArIG51bS5iaXRMZW5ndGgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bS5sdChuZXcgQk4oMCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtLnRvVHdvcyhzaXplKS50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc2l6ZSA/IHV0aWxzLmxlZnRQYWQobnVtLnRvU3RyaW5nKCdoZXgnKSwgc2l6ZSAvIDggKiAyKSA6IG51bTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gRklYTUU6IHN1cHBvcnQgYWxsIG90aGVyIHR5cGVzXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgb3IgaW52YWxpZCB0eXBlOiAnICsgdHlwZSk7XG4gICAgfVxufTtcbnZhciBfcHJvY2Vzc1NvbGlkaXR5RW5jb2RlUGFja2VkQXJncyA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAvKmpzaGludCBtYXhjb21wbGV4aXR5OmZhbHNlICovXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dG9kZXRlY3Rpb24gb2YgYXJyYXkgdHlwZXMgaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgICB9XG4gICAgdmFyIHR5cGUsIHZhbHVlID0gJyc7XG4gICAgdmFyIGhleEFyZywgYXJyYXlTaXplO1xuICAgIC8vIGlmIHR5cGUgaXMgZ2l2ZW5cbiAgICBpZiAoISFhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgKGFyZy5oYXNPd25Qcm9wZXJ0eSgndicpIHx8IGFyZy5oYXNPd25Qcm9wZXJ0eSgndCcpIHx8IGFyZy5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSB8fCBhcmcuaGFzT3duUHJvcGVydHkoJ3R5cGUnKSkpIHtcbiAgICAgICAgdHlwZSA9IGFyZy5oYXNPd25Qcm9wZXJ0eSgndCcpID8gYXJnLnQgOiBhcmcudHlwZTtcbiAgICAgICAgdmFsdWUgPSBhcmcuaGFzT3duUHJvcGVydHkoJ3YnKSA/IGFyZy52IDogYXJnLnZhbHVlO1xuICAgICAgICAvLyBvdGhlcndpc2UgdHJ5IHRvIGd1ZXNzIHRoZSB0eXBlXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0eXBlID0gdXRpbHMudG9IZXgoYXJnLCB0cnVlKTtcbiAgICAgICAgdmFsdWUgPSB1dGlscy50b0hleChhcmcpO1xuICAgICAgICBpZiAoIXR5cGUuc3RhcnRzV2l0aCgnaW50JykgJiYgIXR5cGUuc3RhcnRzV2l0aCgndWludCcpKSB7XG4gICAgICAgICAgICB0eXBlID0gJ2J5dGVzJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoKHR5cGUuc3RhcnRzV2l0aCgnaW50JykgfHwgdHlwZS5zdGFydHNXaXRoKCd1aW50JykpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgIS9eKC0pPzB4L2kudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSBuZXcgQk4odmFsdWUpO1xuICAgIH1cbiAgICAvLyBnZXQgdGhlIGFycmF5IHNpemVcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgYXJyYXlTaXplID0gX3BhcnNlVHlwZU5BcnJheSh0eXBlKTtcbiAgICAgICAgaWYgKGFycmF5U2l6ZSAmJiB2YWx1ZS5sZW5ndGggIT09IGFycmF5U2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHR5cGUgKyAnIGlzIG5vdCBtYXRjaGluZyB0aGUgZ2l2ZW4gYXJyYXkgJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhcnJheVNpemUgPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGhleEFyZyA9IHZhbHVlLm1hcChmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gX3NvbGlkaXR5UGFjayh0eXBlLCB2YWwsIGFycmF5U2l6ZSkudG9TdHJpbmcoJ2hleCcpLnJlcGxhY2UoJzB4JywgJycpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGhleEFyZy5qb2luKCcnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGhleEFyZyA9IF9zb2xpZGl0eVBhY2sodHlwZSwgdmFsdWUsIGFycmF5U2l6ZSk7XG4gICAgICAgIHJldHVybiBoZXhBcmcudG9TdHJpbmcoJ2hleCcpLnJlcGxhY2UoJzB4JywgJycpO1xuICAgIH1cbn07XG4vKipcbiAqIEhhc2hlcyBzb2xpZGl0eSB2YWx1ZXMgdG8gYSBzaGEzIGhhc2ggdXNpbmcga2VjY2FrIDI1NlxuICpcbiAqIEBtZXRob2Qgc29saWRpdHlTaGEzXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBzaGEzXG4gKi9cbnZhciBzb2xpZGl0eVNoYTMgPSBmdW5jdGlvbiAoKSB7XG4gICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eTpmYWxzZSAqL1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB2YXIgaGV4QXJncyA9IGFyZ3MubWFwKF9wcm9jZXNzU29saWRpdHlFbmNvZGVQYWNrZWRBcmdzKTtcbiAgICAvLyBjb25zb2xlLmxvZyhhcmdzLCBoZXhBcmdzKTtcbiAgICAvLyBjb25zb2xlLmxvZygnMHgnKyBoZXhBcmdzLmpvaW4oJycpKTtcbiAgICByZXR1cm4gdXRpbHMuc2hhMygnMHgnICsgaGV4QXJncy5qb2luKCcnKSk7XG59O1xuLyoqXG4gKiBIYXNoZXMgc29saWRpdHkgdmFsdWVzIHRvIGEgc2hhMyBoYXNoIHVzaW5nIGtlY2NhayAyNTYgYnV0IGRvZXMgcmV0dXJuIHRoZSBoYXNoIG9mIHZhbHVlIGBudWxsYCBpbnN0ZWFkIG9mIGBudWxsYFxuICpcbiAqIEBtZXRob2Qgc29saWRpdHlTaGEzUmF3XG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBzaGEzXG4gKi9cbnZhciBzb2xpZGl0eVNoYTNSYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHV0aWxzLnNoYTNSYXcoJzB4JyArIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykubWFwKF9wcm9jZXNzU29saWRpdHlFbmNvZGVQYWNrZWRBcmdzKS5qb2luKCcnKSk7XG59O1xuLyoqXG4gKiBFbmNvZGUgcGFja2VkIGFyZ3MgdG8gaGV4XG4gKlxuICogQG1ldGhvZCBlbmNvZGVQYWNrZWRcbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIGhleCBlbmNvZGVkIGFyZ3VtZW50c1xuICovXG52YXIgZW5jb2RlUGFja2VkID0gZnVuY3Rpb24gKCkge1xuICAgIC8qanNoaW50IG1heGNvbXBsZXhpdHk6ZmFsc2UgKi9cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgdmFyIGhleEFyZ3MgPSBhcmdzLm1hcChfcHJvY2Vzc1NvbGlkaXR5RW5jb2RlUGFja2VkQXJncyk7XG4gICAgcmV0dXJuICcweCcgKyBoZXhBcmdzLmpvaW4oJycpLnRvTG93ZXJDYXNlKCk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgc29saWRpdHlTaGEzOiBzb2xpZGl0eVNoYTMsXG4gICAgc29saWRpdHlTaGEzUmF3OiBzb2xpZGl0eVNoYTNSYXcsXG4gICAgZW5jb2RlUGFja2VkOiBlbmNvZGVQYWNrZWRcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/web3-utils@1.10.0/node_modules/web3-utils/lib/soliditySha3.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/web3-utils@1.10.0/node_modules/web3-utils/lib/utils.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/web3-utils@1.10.0/node_modules/web3-utils/lib/utils.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */\n/**\n * @file utils.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\nvar BN = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/.pnpm/bn.js@5.2.1/node_modules/bn.js/lib/bn.js\");\nvar numberToBN = __webpack_require__(/*! number-to-bn */ \"(ssr)/./node_modules/.pnpm/number-to-bn@1.7.0/node_modules/number-to-bn/src/index.js\");\nvar utf8 = __webpack_require__(/*! utf8 */ \"(ssr)/./node_modules/.pnpm/utf8@3.0.0/node_modules/utf8/utf8.js\");\nvar ethereumjsUtil = __webpack_require__(/*! ethereumjs-util */ \"(ssr)/./node_modules/.pnpm/ethereumjs-util@7.1.5/node_modules/ethereumjs-util/dist/index.js\");\nvar ethereumBloomFilters = __webpack_require__(/*! ethereum-bloom-filters */ \"(ssr)/./node_modules/.pnpm/ethereum-bloom-filters@1.1.0/node_modules/ethereum-bloom-filters/dist/index.js\");\n/**\n * Returns true if object is BN, otherwise false\n *\n * @method isBN\n * @param {Object} object\n * @return {Boolean}\n */\nvar isBN = function (object) {\n    return BN.isBN(object);\n};\n/**\n * Returns true if object is BigNumber, otherwise false\n *\n * @method isBigNumber\n * @param {Object} object\n * @return {Boolean}\n */\nvar isBigNumber = function (object) {\n    return object && object.constructor && object.constructor.name === 'BigNumber';\n};\n/**\n * Takes an input and transforms it into an BN\n *\n * @method toBN\n * @param {Number|String|BN} number, string, HEX string or BN\n * @return {BN} BN\n */\nvar toBN = function (number) {\n    try {\n        return numberToBN.apply(null, arguments);\n    }\n    catch (e) {\n        throw new Error(e + ' Given value: \"' + number + '\"');\n    }\n};\n/**\n * Takes and input transforms it into BN and if it is negative value, into two's complement\n *\n * @method toTwosComplement\n * @param {Number|String|BN} number\n * @return {String}\n */\nvar toTwosComplement = function (number) {\n    return '0x' + toBN(number).toTwos(256).toString(16, 64);\n};\n/**\n * Checks if the given string is an address\n *\n * @method isAddress\n * @param {String} address the given HEX address\n * @return {Boolean}\n */\nvar isAddress = function (address) {\n    // check if it has the basic requirements of an address\n    if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {\n        return false;\n        // If it's ALL lowercase or ALL upppercase\n    }\n    else if (/^(0x|0X)?[0-9a-f]{40}$/.test(address) || /^(0x|0X)?[0-9A-F]{40}$/.test(address)) {\n        return true;\n        // Otherwise check each case\n    }\n    else {\n        return checkAddressChecksum(address);\n    }\n};\n/**\n * Checks if the given string is a checksummed address\n *\n * @method checkAddressChecksum\n * @param {String} address the given HEX address\n * @return {Boolean}\n */\nvar checkAddressChecksum = function (address) {\n    // Check each case\n    address = address.replace(/^0x/i, '');\n    var addressHash = sha3(address.toLowerCase()).replace(/^0x/i, '');\n    for (var i = 0; i < 40; i++) {\n        // the nth letter should be uppercase if the nth digit of casemap is 1\n        if ((parseInt(addressHash[i], 16) > 7 && address[i].toUpperCase() !== address[i]) || (parseInt(addressHash[i], 16) <= 7 && address[i].toLowerCase() !== address[i])) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * Should be called to pad string to expected length\n *\n * @method leftPad\n * @param {String} string to be padded\n * @param {Number} chars that result string should have\n * @param {String} sign, by default 0\n * @returns {String} right aligned string\n */\nvar leftPad = function (string, chars, sign) {\n    var hasPrefix = /^0x/i.test(string) || typeof string === 'number';\n    string = string.toString(16).replace(/^0x/i, '');\n    var padding = (chars - string.length + 1 >= 0) ? chars - string.length + 1 : 0;\n    return (hasPrefix ? '0x' : '') + new Array(padding).join(sign ? sign : \"0\") + string;\n};\n/**\n * Should be called to pad string to expected length\n *\n * @method rightPad\n * @param {String} string to be padded\n * @param {Number} chars that result string should have\n * @param {String} sign, by default 0\n * @returns {String} right aligned string\n */\nvar rightPad = function (string, chars, sign) {\n    var hasPrefix = /^0x/i.test(string) || typeof string === 'number';\n    string = string.toString(16).replace(/^0x/i, '');\n    var padding = (chars - string.length + 1 >= 0) ? chars - string.length + 1 : 0;\n    return (hasPrefix ? '0x' : '') + string + (new Array(padding).join(sign ? sign : \"0\"));\n};\n/**\n * Should be called to get hex representation (prefixed by 0x) of utf8 string\n *\n * @method utf8ToHex\n * @param {String} str\n * @returns {String} hex representation of input string\n */\nvar utf8ToHex = function (str) {\n    str = utf8.encode(str);\n    var hex = \"\";\n    // remove \\u0000 padding from either side\n    str = str.replace(/^(?:\\u0000)*/, '');\n    str = str.split(\"\").reverse().join(\"\");\n    str = str.replace(/^(?:\\u0000)*/, '');\n    str = str.split(\"\").reverse().join(\"\");\n    for (var i = 0; i < str.length; i++) {\n        var code = str.charCodeAt(i);\n        // if (code !== 0) {\n        var n = code.toString(16);\n        hex += n.length < 2 ? '0' + n : n;\n        // }\n    }\n    return \"0x\" + hex;\n};\n/**\n * Should be called to get utf8 from it's hex representation\n *\n * @method hexToUtf8\n * @param {String} hex\n * @returns {String} ascii string representation of hex value\n */\nvar hexToUtf8 = function (hex) {\n    if (!isHexStrict(hex))\n        throw new Error('The parameter \"' + hex + '\" must be a valid HEX string.');\n    var str = \"\";\n    var code = 0;\n    hex = hex.replace(/^0x/i, '');\n    // remove 00 padding from either side\n    hex = hex.replace(/^(?:00)*/, '');\n    hex = hex.split(\"\").reverse().join(\"\");\n    hex = hex.replace(/^(?:00)*/, '');\n    hex = hex.split(\"\").reverse().join(\"\");\n    var l = hex.length;\n    for (var i = 0; i < l; i += 2) {\n        code = parseInt(hex.slice(i, i + 2), 16);\n        // if (code !== 0) {\n        str += String.fromCharCode(code);\n        // }\n    }\n    return utf8.decode(str);\n};\n/**\n * Converts value to it's number representation.\n * However, if the value is larger than the maximum safe integer, returns the value as a string.\n *\n * @method hexToNumber\n * @param {String|Number|BN} value\n * @param {Boolean} bigIntOnOverflow - if true, return the hex value in case of overflow\n * @return {Number|String}\n */\nvar hexToNumber = function (value, bigIntOnOverflow = false) {\n    if (!value) {\n        return value;\n    }\n    if (typeof value === 'string' && !isHexStrict(value)) {\n        throw new Error('Given value \"' + value + '\" is not a valid hex string.');\n    }\n    const n = toBN(value);\n    if (bigIntOnOverflow && (n > Number.MAX_SAFE_INTEGER || n < Number.MIN_SAFE_INTEGER)) {\n        return BigInt(n);\n    }\n    return n.toNumber();\n};\n/**\n * Converts value to it's decimal representation in string\n *\n * @method hexToNumberString\n * @param {String|Number|BN} value\n * @return {String}\n */\nvar hexToNumberString = function (value) {\n    if (!value)\n        return value;\n    if (typeof value === 'string' && !isHexStrict(value)) {\n        throw new Error('Given value \"' + value + '\" is not a valid hex string.');\n    }\n    return toBN(value).toString(10);\n};\n/**\n * Converts value to it's hex representation\n *\n * @method numberToHex\n * @param {String|Number|BN} value\n * @return {String}\n */\nvar numberToHex = function (value) {\n    if ((value === null || value === undefined)) {\n        return value;\n    }\n    if (!isFinite(value) && !isHexStrict(value)) {\n        throw new Error('Given input \"' + value + '\" is not a number.');\n    }\n    var number = toBN(value);\n    var result = number.toString(16);\n    return number.lt(new BN(0)) ? '-0x' + result.slice(1) : '0x' + result;\n};\n/**\n * Convert a byte array to a hex string\n *\n * Note: Implementation from crypto-js\n *\n * @method bytesToHex\n * @param {Array} bytes\n * @return {String} the hex string\n */\nvar bytesToHex = function (bytes) {\n    for (var hex = [], i = 0; i < bytes.length; i++) {\n        /* jshint ignore:start */\n        hex.push((bytes[i] >>> 4).toString(16));\n        hex.push((bytes[i] & 0xF).toString(16));\n        /* jshint ignore:end */\n    }\n    return '0x' + hex.join(\"\");\n};\n/**\n * Convert a hex string to a byte array\n *\n * Note: Implementation from crypto-js\n *\n * @method hexToBytes\n * @param {string} hex\n * @return {Array} the byte array\n */\nvar hexToBytes = function (hex) {\n    hex = hex.toString(16);\n    if (!isHexStrict(hex)) {\n        throw new Error('Given value \"' + hex + '\" is not a valid hex string.');\n    }\n    hex = hex.replace(/^0x/i, '');\n    for (var bytes = [], c = 0; c < hex.length; c += 2)\n        bytes.push(parseInt(hex.slice(c, c + 2), 16));\n    return bytes;\n};\n/**\n * Auto converts any given value into it's hex representation.\n *\n * And even stringifys objects before.\n *\n * @method toHex\n * @param {String|Number|BN|Object|Buffer} value\n * @param {Boolean} returnType\n * @return {String}\n */\nvar toHex = function (value, returnType) {\n    /*jshint maxcomplexity: false */\n    if (isAddress(value)) {\n        return returnType ? 'address' : '0x' + value.toLowerCase().replace(/^0x/i, '');\n    }\n    if (typeof value === 'boolean') {\n        return returnType ? 'bool' : value ? '0x01' : '0x00';\n    }\n    if (Buffer.isBuffer(value)) {\n        return '0x' + value.toString('hex');\n    }\n    if (typeof value === 'object' && !!value && !isBigNumber(value) && !isBN(value)) {\n        return returnType ? 'string' : utf8ToHex(JSON.stringify(value));\n    }\n    // if its a negative number, pass it through numberToHex\n    if (typeof value === 'string') {\n        if (value.indexOf('-0x') === 0 || value.indexOf('-0X') === 0) {\n            return returnType ? 'int256' : numberToHex(value);\n        }\n        else if (value.indexOf('0x') === 0 || value.indexOf('0X') === 0) {\n            return returnType ? 'bytes' : value;\n        }\n        else if (!isFinite(value)) {\n            return returnType ? 'string' : utf8ToHex(value);\n        }\n    }\n    return returnType ? (value < 0 ? 'int256' : 'uint256') : numberToHex(value);\n};\n/**\n * Check if string is HEX, requires a 0x in front\n *\n * @method isHexStrict\n * @param {String} hex to be checked\n * @returns {Boolean}\n */\nvar isHexStrict = function (hex) {\n    return ((typeof hex === 'string' || typeof hex === 'number') && /^(-)?0x[0-9a-f]*$/i.test(hex));\n};\n/**\n * Check if string is HEX\n *\n * @method isHex\n * @param {String} hex to be checked\n * @returns {Boolean}\n */\nvar isHex = function (hex) {\n    return ((typeof hex === 'string' || typeof hex === 'number') && /^(-0x|0x)?[0-9a-f]*$/i.test(hex));\n};\n/**\n * Remove 0x prefix from string\n *\n * @method stripHexPrefix\n * @param {String} str to be checked\n * @returns {String}\n */\nvar stripHexPrefix = function (str) {\n    if (str !== 0 && isHex(str))\n        return str.replace(/^(-)?0x/i, '$1');\n    return str;\n};\n/**\n * Returns true if given string is a valid Ethereum block header bloom.\n *\n * @method isBloom\n * @param {String} bloom encoded bloom filter\n * @return {Boolean}\n */\nvar isBloom = function (bloom) {\n    return ethereumBloomFilters.isBloom(bloom);\n};\n/**\n * Returns true if the ethereum users address is part of the given bloom\n * note: false positives are possible.\n *\n * @method isUserEthereumAddressInBloom\n * @param {String} ethereumAddress encoded bloom filter\n * @param {String} bloom ethereum addresss\n * @return {Boolean}\n */\nvar isUserEthereumAddressInBloom = function (bloom, ethereumAddress) {\n    return ethereumBloomFilters.isUserEthereumAddressInBloom(bloom, ethereumAddress);\n};\n/**\n * Returns true if the contract address is part of the given bloom\n * note: false positives are possible.\n *\n * @method isUserEthereumAddressInBloom\n * @param {String} bloom encoded bloom filter\n * @param {String} contractAddress contract addresss\n * @return {Boolean}\n */\nvar isContractAddressInBloom = function (bloom, contractAddress) {\n    return ethereumBloomFilters.isContractAddressInBloom(bloom, contractAddress);\n};\n/**\n * Returns true if given string is a valid log topic.\n *\n * @method isTopic\n * @param {String} topic encoded topic\n * @return {Boolean}\n */\nvar isTopic = function (topic) {\n    return ethereumBloomFilters.isTopic(topic);\n};\n/**\n * Returns true if the topic is part of the given bloom\n * note: false positives are possible.\n *\n * @method isTopicInBloom\n * @param {String} bloom encoded bloom filter\n * @param {String} topic encoded topic\n * @return {Boolean}\n */\nvar isTopicInBloom = function (bloom, topic) {\n    return ethereumBloomFilters.isTopicInBloom(bloom, topic);\n};\n/**\n * Returns true if the value is part of the given bloom\n * note: false positives are possible.\n *\n * @method isInBloom\n * @param {String} bloom encoded bloom filter\n * @param {String | Uint8Array} topic encoded value\n * @return {Boolean}\n */\nvar isInBloom = function (bloom, topic) {\n    return ethereumBloomFilters.isInBloom(bloom, topic);\n};\n/**\n * Hashes values to a sha3 hash using keccak 256\n *\n * To hash a HEX string the hex must have 0x in front.\n *\n * @method sha3\n * @return {String} the sha3 string\n */\nvar SHA3_NULL_S = '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';\nvar sha3 = function (value) {\n    if (isBN(value)) {\n        value = value.toString();\n    }\n    if (isHexStrict(value) && /^0x/i.test((value).toString())) {\n        value = ethereumjsUtil.toBuffer(value);\n    }\n    else if (typeof value === 'string') {\n        // Assume value is an arbitrary string\n        value = Buffer.from(value, 'utf-8');\n    }\n    var returnValue = ethereumjsUtil.bufferToHex(ethereumjsUtil.keccak256(value));\n    if (returnValue === SHA3_NULL_S) {\n        return null;\n    }\n    else {\n        return returnValue;\n    }\n};\n// expose the under the hood keccak256\nsha3._Hash = ethereumjsUtil.keccak256;\n/**\n * @method sha3Raw\n *\n * @param value\n *\n * @returns {string}\n */\nvar sha3Raw = function (value) {\n    value = sha3(value);\n    if (value === null) {\n        return SHA3_NULL_S;\n    }\n    return value;\n};\n/**\n * Auto converts any given value into it's hex representation,\n * then converts hex to number.\n *\n * @method toNumber\n * @param {String|Number|BN} value\n * @param {Boolean} bigIntOnOverflow - if true, return the hex value in case of overflow\n * @return {Number|String}\n */\nvar toNumber = function (value, bigIntOnOverflow = false) {\n    return typeof value === 'number' ? value : hexToNumber(toHex(value), bigIntOnOverflow);\n};\n// 1.x currently accepts 0x... strings, bn.js after update doesn't. it would be a breaking change\nvar BNwrapped = function (value) {\n    // check negative\n    if (typeof value == \"string\" && value.includes(\"0x\")) {\n        const [negative, hexValue] = value.toLocaleLowerCase().startsWith('-') ? [\"-\", value.slice(3)] : [\"\", value.slice(2)];\n        return new BN(negative + hexValue, 16);\n    }\n    else {\n        return new BN(value);\n    }\n};\nObject.setPrototypeOf(BNwrapped, BN);\nObject.setPrototypeOf(BNwrapped.prototype, BN.prototype);\nmodule.exports = {\n    BN: BNwrapped,\n    isBN: isBN,\n    isBigNumber: isBigNumber,\n    toBN: toBN,\n    isAddress: isAddress,\n    isBloom: isBloom,\n    isUserEthereumAddressInBloom: isUserEthereumAddressInBloom,\n    isContractAddressInBloom: isContractAddressInBloom,\n    isTopic: isTopic,\n    isTopicInBloom: isTopicInBloom,\n    isInBloom: isInBloom,\n    checkAddressChecksum: checkAddressChecksum,\n    utf8ToHex: utf8ToHex,\n    hexToUtf8: hexToUtf8,\n    hexToNumber: hexToNumber,\n    hexToNumberString: hexToNumberString,\n    numberToHex: numberToHex,\n    toHex: toHex,\n    hexToBytes: hexToBytes,\n    bytesToHex: bytesToHex,\n    isHex: isHex,\n    isHexStrict: isHexStrict,\n    stripHexPrefix: stripHexPrefix,\n    leftPad: leftPad,\n    rightPad: rightPad,\n    toTwosComplement: toTwosComplement,\n    sha3: sha3,\n    sha3Raw: sha3Raw,\n    toNumber: toNumber\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vd2ViMy11dGlsc0AxLjEwLjAvbm9kZV9tb2R1bGVzL3dlYjMtdXRpbHMvbGliL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxtQkFBTyxDQUFDLGtGQUFPO0FBQ3hCLGlCQUFpQixtQkFBTyxDQUFDLDBHQUFjO0FBQ3ZDLFdBQVcsbUJBQU8sQ0FBQyw2RUFBTTtBQUN6QixxQkFBcUIsbUJBQU8sQ0FBQyxvSEFBaUI7QUFDOUMsMkJBQTJCLG1CQUFPLENBQUMseUlBQXdCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsWUFBWSxJQUFJO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixHQUFHO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxHQUFHLHVDQUF1QyxHQUFHO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxv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bm9kZV9tb2R1bGVzLy5wbnBtL3dlYjMtdXRpbHNAMS4xMC4wL25vZGVfbW9kdWxlcy93ZWIzLXV0aWxzL2xpYi91dGlscy5qcz8zNmRiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiAqL1xuLyoqXG4gKiBAZmlsZSB1dGlscy5qc1xuICogQGF1dGhvciBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZXJldW0ub3JnPlxuICogQGRhdGUgMjAxN1xuICovXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIG51bWJlclRvQk4gPSByZXF1aXJlKCdudW1iZXItdG8tYm4nKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgndXRmOCcpO1xudmFyIGV0aGVyZXVtanNVdGlsID0gcmVxdWlyZSgnZXRoZXJldW1qcy11dGlsJyk7XG52YXIgZXRoZXJldW1CbG9vbUZpbHRlcnMgPSByZXF1aXJlKCdldGhlcmV1bS1ibG9vbS1maWx0ZXJzJyk7XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaXMgQk4sIG90aGVyd2lzZSBmYWxzZVxuICpcbiAqIEBtZXRob2QgaXNCTlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzQk4gPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIEJOLmlzQk4ob2JqZWN0KTtcbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaXMgQmlnTnVtYmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqXG4gKiBAbWV0aG9kIGlzQmlnTnVtYmVyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgaXNCaWdOdW1iZXIgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuY29uc3RydWN0b3IgJiYgb2JqZWN0LmNvbnN0cnVjdG9yLm5hbWUgPT09ICdCaWdOdW1iZXInO1xufTtcbi8qKlxuICogVGFrZXMgYW4gaW5wdXQgYW5kIHRyYW5zZm9ybXMgaXQgaW50byBhbiBCTlxuICpcbiAqIEBtZXRob2QgdG9CTlxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfEJOfSBudW1iZXIsIHN0cmluZywgSEVYIHN0cmluZyBvciBCTlxuICogQHJldHVybiB7Qk59IEJOXG4gKi9cbnZhciB0b0JOID0gZnVuY3Rpb24gKG51bWJlcikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBudW1iZXJUb0JOLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlICsgJyBHaXZlbiB2YWx1ZTogXCInICsgbnVtYmVyICsgJ1wiJyk7XG4gICAgfVxufTtcbi8qKlxuICogVGFrZXMgYW5kIGlucHV0IHRyYW5zZm9ybXMgaXQgaW50byBCTiBhbmQgaWYgaXQgaXMgbmVnYXRpdmUgdmFsdWUsIGludG8gdHdvJ3MgY29tcGxlbWVudFxuICpcbiAqIEBtZXRob2QgdG9Ud29zQ29tcGxlbWVudFxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfEJOfSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xudmFyIHRvVHdvc0NvbXBsZW1lbnQgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgcmV0dXJuICcweCcgKyB0b0JOKG51bWJlcikudG9Ud29zKDI1NikudG9TdHJpbmcoMTYsIDY0KTtcbn07XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGlzIGFuIGFkZHJlc3NcbiAqXG4gKiBAbWV0aG9kIGlzQWRkcmVzc1xuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgdGhlIGdpdmVuIEhFWCBhZGRyZXNzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgaXNBZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICAvLyBjaGVjayBpZiBpdCBoYXMgdGhlIGJhc2ljIHJlcXVpcmVtZW50cyBvZiBhbiBhZGRyZXNzXG4gICAgaWYgKCEvXigweCk/WzAtOWEtZl17NDB9JC9pLnRlc3QoYWRkcmVzcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBJZiBpdCdzIEFMTCBsb3dlcmNhc2Ugb3IgQUxMIHVwcHBlcmNhc2VcbiAgICB9XG4gICAgZWxzZSBpZiAoL14oMHh8MFgpP1swLTlhLWZdezQwfSQvLnRlc3QoYWRkcmVzcykgfHwgL14oMHh8MFgpP1swLTlBLUZdezQwfSQvLnRlc3QoYWRkcmVzcykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIE90aGVyd2lzZSBjaGVjayBlYWNoIGNhc2VcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBjaGVja0FkZHJlc3NDaGVja3N1bShhZGRyZXNzKTtcbiAgICB9XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHN0cmluZyBpcyBhIGNoZWNrc3VtbWVkIGFkZHJlc3NcbiAqXG4gKiBAbWV0aG9kIGNoZWNrQWRkcmVzc0NoZWNrc3VtXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyB0aGUgZ2l2ZW4gSEVYIGFkZHJlc3NcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBjaGVja0FkZHJlc3NDaGVja3N1bSA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgLy8gQ2hlY2sgZWFjaCBjYXNlXG4gICAgYWRkcmVzcyA9IGFkZHJlc3MucmVwbGFjZSgvXjB4L2ksICcnKTtcbiAgICB2YXIgYWRkcmVzc0hhc2ggPSBzaGEzKGFkZHJlc3MudG9Mb3dlckNhc2UoKSkucmVwbGFjZSgvXjB4L2ksICcnKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQwOyBpKyspIHtcbiAgICAgICAgLy8gdGhlIG50aCBsZXR0ZXIgc2hvdWxkIGJlIHVwcGVyY2FzZSBpZiB0aGUgbnRoIGRpZ2l0IG9mIGNhc2VtYXAgaXMgMVxuICAgICAgICBpZiAoKHBhcnNlSW50KGFkZHJlc3NIYXNoW2ldLCAxNikgPiA3ICYmIGFkZHJlc3NbaV0udG9VcHBlckNhc2UoKSAhPT0gYWRkcmVzc1tpXSkgfHwgKHBhcnNlSW50KGFkZHJlc3NIYXNoW2ldLCAxNikgPD0gNyAmJiBhZGRyZXNzW2ldLnRvTG93ZXJDYXNlKCkgIT09IGFkZHJlc3NbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIHBhZCBzdHJpbmcgdG8gZXhwZWN0ZWQgbGVuZ3RoXG4gKlxuICogQG1ldGhvZCBsZWZ0UGFkXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIHRvIGJlIHBhZGRlZFxuICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJzIHRoYXQgcmVzdWx0IHN0cmluZyBzaG91bGQgaGF2ZVxuICogQHBhcmFtIHtTdHJpbmd9IHNpZ24sIGJ5IGRlZmF1bHQgMFxuICogQHJldHVybnMge1N0cmluZ30gcmlnaHQgYWxpZ25lZCBzdHJpbmdcbiAqL1xudmFyIGxlZnRQYWQgPSBmdW5jdGlvbiAoc3RyaW5nLCBjaGFycywgc2lnbikge1xuICAgIHZhciBoYXNQcmVmaXggPSAvXjB4L2kudGVzdChzdHJpbmcpIHx8IHR5cGVvZiBzdHJpbmcgPT09ICdudW1iZXInO1xuICAgIHN0cmluZyA9IHN0cmluZy50b1N0cmluZygxNikucmVwbGFjZSgvXjB4L2ksICcnKTtcbiAgICB2YXIgcGFkZGluZyA9IChjaGFycyAtIHN0cmluZy5sZW5ndGggKyAxID49IDApID8gY2hhcnMgLSBzdHJpbmcubGVuZ3RoICsgMSA6IDA7XG4gICAgcmV0dXJuIChoYXNQcmVmaXggPyAnMHgnIDogJycpICsgbmV3IEFycmF5KHBhZGRpbmcpLmpvaW4oc2lnbiA/IHNpZ24gOiBcIjBcIikgKyBzdHJpbmc7XG59O1xuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIHBhZCBzdHJpbmcgdG8gZXhwZWN0ZWQgbGVuZ3RoXG4gKlxuICogQG1ldGhvZCByaWdodFBhZFxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyB0byBiZSBwYWRkZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBjaGFycyB0aGF0IHJlc3VsdCBzdHJpbmcgc2hvdWxkIGhhdmVcbiAqIEBwYXJhbSB7U3RyaW5nfSBzaWduLCBieSBkZWZhdWx0IDBcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHJpZ2h0IGFsaWduZWQgc3RyaW5nXG4gKi9cbnZhciByaWdodFBhZCA9IGZ1bmN0aW9uIChzdHJpbmcsIGNoYXJzLCBzaWduKSB7XG4gICAgdmFyIGhhc1ByZWZpeCA9IC9eMHgvaS50ZXN0KHN0cmluZykgfHwgdHlwZW9mIHN0cmluZyA9PT0gJ251bWJlcic7XG4gICAgc3RyaW5nID0gc3RyaW5nLnRvU3RyaW5nKDE2KS5yZXBsYWNlKC9eMHgvaSwgJycpO1xuICAgIHZhciBwYWRkaW5nID0gKGNoYXJzIC0gc3RyaW5nLmxlbmd0aCArIDEgPj0gMCkgPyBjaGFycyAtIHN0cmluZy5sZW5ndGggKyAxIDogMDtcbiAgICByZXR1cm4gKGhhc1ByZWZpeCA/ICcweCcgOiAnJykgKyBzdHJpbmcgKyAobmV3IEFycmF5KHBhZGRpbmcpLmpvaW4oc2lnbiA/IHNpZ24gOiBcIjBcIikpO1xufTtcbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgaGV4IHJlcHJlc2VudGF0aW9uIChwcmVmaXhlZCBieSAweCkgb2YgdXRmOCBzdHJpbmdcbiAqXG4gKiBAbWV0aG9kIHV0ZjhUb0hleFxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ30gaGV4IHJlcHJlc2VudGF0aW9uIG9mIGlucHV0IHN0cmluZ1xuICovXG52YXIgdXRmOFRvSGV4ID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHN0ciA9IHV0ZjguZW5jb2RlKHN0cik7XG4gICAgdmFyIGhleCA9IFwiXCI7XG4gICAgLy8gcmVtb3ZlIFxcdTAwMDAgcGFkZGluZyBmcm9tIGVpdGhlciBzaWRlXG4gICAgc3RyID0gc3RyLnJlcGxhY2UoL14oPzpcXHUwMDAwKSovLCAnJyk7XG4gICAgc3RyID0gc3RyLnNwbGl0KFwiXCIpLnJldmVyc2UoKS5qb2luKFwiXCIpO1xuICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9eKD86XFx1MDAwMCkqLywgJycpO1xuICAgIHN0ciA9IHN0ci5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAvLyBpZiAoY29kZSAhPT0gMCkge1xuICAgICAgICB2YXIgbiA9IGNvZGUudG9TdHJpbmcoMTYpO1xuICAgICAgICBoZXggKz0gbi5sZW5ndGggPCAyID8gJzAnICsgbiA6IG47XG4gICAgICAgIC8vIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIGhleDtcbn07XG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IHV0ZjggZnJvbSBpdCdzIGhleCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBtZXRob2QgaGV4VG9VdGY4XG4gKiBAcGFyYW0ge1N0cmluZ30gaGV4XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBhc2NpaSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgaGV4IHZhbHVlXG4gKi9cbnZhciBoZXhUb1V0ZjggPSBmdW5jdGlvbiAoaGV4KSB7XG4gICAgaWYgKCFpc0hleFN0cmljdChoZXgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwYXJhbWV0ZXIgXCInICsgaGV4ICsgJ1wiIG11c3QgYmUgYSB2YWxpZCBIRVggc3RyaW5nLicpO1xuICAgIHZhciBzdHIgPSBcIlwiO1xuICAgIHZhciBjb2RlID0gMDtcbiAgICBoZXggPSBoZXgucmVwbGFjZSgvXjB4L2ksICcnKTtcbiAgICAvLyByZW1vdmUgMDAgcGFkZGluZyBmcm9tIGVpdGhlciBzaWRlXG4gICAgaGV4ID0gaGV4LnJlcGxhY2UoL14oPzowMCkqLywgJycpO1xuICAgIGhleCA9IGhleC5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKTtcbiAgICBoZXggPSBoZXgucmVwbGFjZSgvXig/OjAwKSovLCAnJyk7XG4gICAgaGV4ID0gaGV4LnNwbGl0KFwiXCIpLnJldmVyc2UoKS5qb2luKFwiXCIpO1xuICAgIHZhciBsID0gaGV4Lmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkgKz0gMikge1xuICAgICAgICBjb2RlID0gcGFyc2VJbnQoaGV4LnNsaWNlKGksIGkgKyAyKSwgMTYpO1xuICAgICAgICAvLyBpZiAoY29kZSAhPT0gMCkge1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgLy8gfVxuICAgIH1cbiAgICByZXR1cm4gdXRmOC5kZWNvZGUoc3RyKTtcbn07XG4vKipcbiAqIENvbnZlcnRzIHZhbHVlIHRvIGl0J3MgbnVtYmVyIHJlcHJlc2VudGF0aW9uLlxuICogSG93ZXZlciwgaWYgdGhlIHZhbHVlIGlzIGxhcmdlciB0aGFuIHRoZSBtYXhpbXVtIHNhZmUgaW50ZWdlciwgcmV0dXJucyB0aGUgdmFsdWUgYXMgYSBzdHJpbmcuXG4gKlxuICogQG1ldGhvZCBoZXhUb051bWJlclxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfEJOfSB2YWx1ZVxuICogQHBhcmFtIHtCb29sZWFufSBiaWdJbnRPbk92ZXJmbG93IC0gaWYgdHJ1ZSwgcmV0dXJuIHRoZSBoZXggdmFsdWUgaW4gY2FzZSBvZiBvdmVyZmxvd1xuICogQHJldHVybiB7TnVtYmVyfFN0cmluZ31cbiAqL1xudmFyIGhleFRvTnVtYmVyID0gZnVuY3Rpb24gKHZhbHVlLCBiaWdJbnRPbk92ZXJmbG93ID0gZmFsc2UpIHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgIWlzSGV4U3RyaWN0KHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dpdmVuIHZhbHVlIFwiJyArIHZhbHVlICsgJ1wiIGlzIG5vdCBhIHZhbGlkIGhleCBzdHJpbmcuJyk7XG4gICAgfVxuICAgIGNvbnN0IG4gPSB0b0JOKHZhbHVlKTtcbiAgICBpZiAoYmlnSW50T25PdmVyZmxvdyAmJiAobiA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IG4gPCBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUikpIHtcbiAgICAgICAgcmV0dXJuIEJpZ0ludChuKTtcbiAgICB9XG4gICAgcmV0dXJuIG4udG9OdW1iZXIoKTtcbn07XG4vKipcbiAqIENvbnZlcnRzIHZhbHVlIHRvIGl0J3MgZGVjaW1hbCByZXByZXNlbnRhdGlvbiBpbiBzdHJpbmdcbiAqXG4gKiBAbWV0aG9kIGhleFRvTnVtYmVyU3RyaW5nXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8Qk59IHZhbHVlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbnZhciBoZXhUb051bWJlclN0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICghdmFsdWUpXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiAhaXNIZXhTdHJpY3QodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignR2l2ZW4gdmFsdWUgXCInICsgdmFsdWUgKyAnXCIgaXMgbm90IGEgdmFsaWQgaGV4IHN0cmluZy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvQk4odmFsdWUpLnRvU3RyaW5nKDEwKTtcbn07XG4vKipcbiAqIENvbnZlcnRzIHZhbHVlIHRvIGl0J3MgaGV4IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQG1ldGhvZCBudW1iZXJUb0hleFxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfEJOfSB2YWx1ZVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG52YXIgbnVtYmVyVG9IZXggPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkgJiYgIWlzSGV4U3RyaWN0KHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dpdmVuIGlucHV0IFwiJyArIHZhbHVlICsgJ1wiIGlzIG5vdCBhIG51bWJlci4nKTtcbiAgICB9XG4gICAgdmFyIG51bWJlciA9IHRvQk4odmFsdWUpO1xuICAgIHZhciByZXN1bHQgPSBudW1iZXIudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBudW1iZXIubHQobmV3IEJOKDApKSA/ICctMHgnICsgcmVzdWx0LnNsaWNlKDEpIDogJzB4JyArIHJlc3VsdDtcbn07XG4vKipcbiAqIENvbnZlcnQgYSBieXRlIGFycmF5IHRvIGEgaGV4IHN0cmluZ1xuICpcbiAqIE5vdGU6IEltcGxlbWVudGF0aW9uIGZyb20gY3J5cHRvLWpzXG4gKlxuICogQG1ldGhvZCBieXRlc1RvSGV4XG4gKiBAcGFyYW0ge0FycmF5fSBieXRlc1xuICogQHJldHVybiB7U3RyaW5nfSB0aGUgaGV4IHN0cmluZ1xuICovXG52YXIgYnl0ZXNUb0hleCA9IGZ1bmN0aW9uIChieXRlcykge1xuICAgIGZvciAodmFyIGhleCA9IFtdLCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbiAgICAgICAgaGV4LnB1c2goKGJ5dGVzW2ldID4+PiA0KS50b1N0cmluZygxNikpO1xuICAgICAgICBoZXgucHVzaCgoYnl0ZXNbaV0gJiAweEYpLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIC8qIGpzaGludCBpZ25vcmU6ZW5kICovXG4gICAgfVxuICAgIHJldHVybiAnMHgnICsgaGV4LmpvaW4oXCJcIik7XG59O1xuLyoqXG4gKiBDb252ZXJ0IGEgaGV4IHN0cmluZyB0byBhIGJ5dGUgYXJyYXlcbiAqXG4gKiBOb3RlOiBJbXBsZW1lbnRhdGlvbiBmcm9tIGNyeXB0by1qc1xuICpcbiAqIEBtZXRob2QgaGV4VG9CeXRlc1xuICogQHBhcmFtIHtzdHJpbmd9IGhleFxuICogQHJldHVybiB7QXJyYXl9IHRoZSBieXRlIGFycmF5XG4gKi9cbnZhciBoZXhUb0J5dGVzID0gZnVuY3Rpb24gKGhleCkge1xuICAgIGhleCA9IGhleC50b1N0cmluZygxNik7XG4gICAgaWYgKCFpc0hleFN0cmljdChoZXgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignR2l2ZW4gdmFsdWUgXCInICsgaGV4ICsgJ1wiIGlzIG5vdCBhIHZhbGlkIGhleCBzdHJpbmcuJyk7XG4gICAgfVxuICAgIGhleCA9IGhleC5yZXBsYWNlKC9eMHgvaSwgJycpO1xuICAgIGZvciAodmFyIGJ5dGVzID0gW10sIGMgPSAwOyBjIDwgaGV4Lmxlbmd0aDsgYyArPSAyKVxuICAgICAgICBieXRlcy5wdXNoKHBhcnNlSW50KGhleC5zbGljZShjLCBjICsgMiksIDE2KSk7XG4gICAgcmV0dXJuIGJ5dGVzO1xufTtcbi8qKlxuICogQXV0byBjb252ZXJ0cyBhbnkgZ2l2ZW4gdmFsdWUgaW50byBpdCdzIGhleCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBBbmQgZXZlbiBzdHJpbmdpZnlzIG9iamVjdHMgYmVmb3JlLlxuICpcbiAqIEBtZXRob2QgdG9IZXhcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcnxCTnxPYmplY3R8QnVmZmVyfSB2YWx1ZVxuICogQHBhcmFtIHtCb29sZWFufSByZXR1cm5UeXBlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbnZhciB0b0hleCA9IGZ1bmN0aW9uICh2YWx1ZSwgcmV0dXJuVHlwZSkge1xuICAgIC8qanNoaW50IG1heGNvbXBsZXhpdHk6IGZhbHNlICovXG4gICAgaWYgKGlzQWRkcmVzcyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHJldHVyblR5cGUgPyAnYWRkcmVzcycgOiAnMHgnICsgdmFsdWUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9eMHgvaSwgJycpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIHJldHVyblR5cGUgPyAnYm9vbCcgOiB2YWx1ZSA/ICcweDAxJyA6ICcweDAwJztcbiAgICB9XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICcweCcgKyB2YWx1ZS50b1N0cmluZygnaGV4Jyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICEhdmFsdWUgJiYgIWlzQmlnTnVtYmVyKHZhbHVlKSAmJiAhaXNCTih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHJldHVyblR5cGUgPyAnc3RyaW5nJyA6IHV0ZjhUb0hleChKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgIH1cbiAgICAvLyBpZiBpdHMgYSBuZWdhdGl2ZSBudW1iZXIsIHBhc3MgaXQgdGhyb3VnaCBudW1iZXJUb0hleFxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh2YWx1ZS5pbmRleE9mKCctMHgnKSA9PT0gMCB8fCB2YWx1ZS5pbmRleE9mKCctMFgnKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJldHVyblR5cGUgPyAnaW50MjU2JyA6IG51bWJlclRvSGV4KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZS5pbmRleE9mKCcweCcpID09PSAwIHx8IHZhbHVlLmluZGV4T2YoJzBYJykgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5UeXBlID8gJ2J5dGVzJyA6IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5UeXBlID8gJ3N0cmluZycgOiB1dGY4VG9IZXgodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5UeXBlID8gKHZhbHVlIDwgMCA/ICdpbnQyNTYnIDogJ3VpbnQyNTYnKSA6IG51bWJlclRvSGV4KHZhbHVlKTtcbn07XG4vKipcbiAqIENoZWNrIGlmIHN0cmluZyBpcyBIRVgsIHJlcXVpcmVzIGEgMHggaW4gZnJvbnRcbiAqXG4gKiBAbWV0aG9kIGlzSGV4U3RyaWN0XG4gKiBAcGFyYW0ge1N0cmluZ30gaGV4IHRvIGJlIGNoZWNrZWRcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG52YXIgaXNIZXhTdHJpY3QgPSBmdW5jdGlvbiAoaGV4KSB7XG4gICAgcmV0dXJuICgodHlwZW9mIGhleCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGhleCA9PT0gJ251bWJlcicpICYmIC9eKC0pPzB4WzAtOWEtZl0qJC9pLnRlc3QoaGV4KSk7XG59O1xuLyoqXG4gKiBDaGVjayBpZiBzdHJpbmcgaXMgSEVYXG4gKlxuICogQG1ldGhvZCBpc0hleFxuICogQHBhcmFtIHtTdHJpbmd9IGhleCB0byBiZSBjaGVja2VkXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzSGV4ID0gZnVuY3Rpb24gKGhleCkge1xuICAgIHJldHVybiAoKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBoZXggPT09ICdudW1iZXInKSAmJiAvXigtMHh8MHgpP1swLTlhLWZdKiQvaS50ZXN0KGhleCkpO1xufTtcbi8qKlxuICogUmVtb3ZlIDB4IHByZWZpeCBmcm9tIHN0cmluZ1xuICpcbiAqIEBtZXRob2Qgc3RyaXBIZXhQcmVmaXhcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdG8gYmUgY2hlY2tlZFxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xudmFyIHN0cmlwSGV4UHJlZml4ID0gZnVuY3Rpb24gKHN0cikge1xuICAgIGlmIChzdHIgIT09IDAgJiYgaXNIZXgoc3RyKSlcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eKC0pPzB4L2ksICckMScpO1xuICAgIHJldHVybiBzdHI7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgZ2l2ZW4gc3RyaW5nIGlzIGEgdmFsaWQgRXRoZXJldW0gYmxvY2sgaGVhZGVyIGJsb29tLlxuICpcbiAqIEBtZXRob2QgaXNCbG9vbVxuICogQHBhcmFtIHtTdHJpbmd9IGJsb29tIGVuY29kZWQgYmxvb20gZmlsdGVyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgaXNCbG9vbSA9IGZ1bmN0aW9uIChibG9vbSkge1xuICAgIHJldHVybiBldGhlcmV1bUJsb29tRmlsdGVycy5pc0Jsb29tKGJsb29tKTtcbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZXRoZXJldW0gdXNlcnMgYWRkcmVzcyBpcyBwYXJ0IG9mIHRoZSBnaXZlbiBibG9vbVxuICogbm90ZTogZmFsc2UgcG9zaXRpdmVzIGFyZSBwb3NzaWJsZS5cbiAqXG4gKiBAbWV0aG9kIGlzVXNlckV0aGVyZXVtQWRkcmVzc0luQmxvb21cbiAqIEBwYXJhbSB7U3RyaW5nfSBldGhlcmV1bUFkZHJlc3MgZW5jb2RlZCBibG9vbSBmaWx0ZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBibG9vbSBldGhlcmV1bSBhZGRyZXNzc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzVXNlckV0aGVyZXVtQWRkcmVzc0luQmxvb20gPSBmdW5jdGlvbiAoYmxvb20sIGV0aGVyZXVtQWRkcmVzcykge1xuICAgIHJldHVybiBldGhlcmV1bUJsb29tRmlsdGVycy5pc1VzZXJFdGhlcmV1bUFkZHJlc3NJbkJsb29tKGJsb29tLCBldGhlcmV1bUFkZHJlc3MpO1xufTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBjb250cmFjdCBhZGRyZXNzIGlzIHBhcnQgb2YgdGhlIGdpdmVuIGJsb29tXG4gKiBub3RlOiBmYWxzZSBwb3NpdGl2ZXMgYXJlIHBvc3NpYmxlLlxuICpcbiAqIEBtZXRob2QgaXNVc2VyRXRoZXJldW1BZGRyZXNzSW5CbG9vbVxuICogQHBhcmFtIHtTdHJpbmd9IGJsb29tIGVuY29kZWQgYmxvb20gZmlsdGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gY29udHJhY3RBZGRyZXNzIGNvbnRyYWN0IGFkZHJlc3NzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgaXNDb250cmFjdEFkZHJlc3NJbkJsb29tID0gZnVuY3Rpb24gKGJsb29tLCBjb250cmFjdEFkZHJlc3MpIHtcbiAgICByZXR1cm4gZXRoZXJldW1CbG9vbUZpbHRlcnMuaXNDb250cmFjdEFkZHJlc3NJbkJsb29tKGJsb29tLCBjb250cmFjdEFkZHJlc3MpO1xufTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGdpdmVuIHN0cmluZyBpcyBhIHZhbGlkIGxvZyB0b3BpYy5cbiAqXG4gKiBAbWV0aG9kIGlzVG9waWNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0b3BpYyBlbmNvZGVkIHRvcGljXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgaXNUb3BpYyA9IGZ1bmN0aW9uICh0b3BpYykge1xuICAgIHJldHVybiBldGhlcmV1bUJsb29tRmlsdGVycy5pc1RvcGljKHRvcGljKTtcbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdG9waWMgaXMgcGFydCBvZiB0aGUgZ2l2ZW4gYmxvb21cbiAqIG5vdGU6IGZhbHNlIHBvc2l0aXZlcyBhcmUgcG9zc2libGUuXG4gKlxuICogQG1ldGhvZCBpc1RvcGljSW5CbG9vbVxuICogQHBhcmFtIHtTdHJpbmd9IGJsb29tIGVuY29kZWQgYmxvb20gZmlsdGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9waWMgZW5jb2RlZCB0b3BpY1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzVG9waWNJbkJsb29tID0gZnVuY3Rpb24gKGJsb29tLCB0b3BpYykge1xuICAgIHJldHVybiBldGhlcmV1bUJsb29tRmlsdGVycy5pc1RvcGljSW5CbG9vbShibG9vbSwgdG9waWMpO1xufTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBwYXJ0IG9mIHRoZSBnaXZlbiBibG9vbVxuICogbm90ZTogZmFsc2UgcG9zaXRpdmVzIGFyZSBwb3NzaWJsZS5cbiAqXG4gKiBAbWV0aG9kIGlzSW5CbG9vbVxuICogQHBhcmFtIHtTdHJpbmd9IGJsb29tIGVuY29kZWQgYmxvb20gZmlsdGVyXG4gKiBAcGFyYW0ge1N0cmluZyB8IFVpbnQ4QXJyYXl9IHRvcGljIGVuY29kZWQgdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBpc0luQmxvb20gPSBmdW5jdGlvbiAoYmxvb20sIHRvcGljKSB7XG4gICAgcmV0dXJuIGV0aGVyZXVtQmxvb21GaWx0ZXJzLmlzSW5CbG9vbShibG9vbSwgdG9waWMpO1xufTtcbi8qKlxuICogSGFzaGVzIHZhbHVlcyB0byBhIHNoYTMgaGFzaCB1c2luZyBrZWNjYWsgMjU2XG4gKlxuICogVG8gaGFzaCBhIEhFWCBzdHJpbmcgdGhlIGhleCBtdXN0IGhhdmUgMHggaW4gZnJvbnQuXG4gKlxuICogQG1ldGhvZCBzaGEzXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBzaGEzIHN0cmluZ1xuICovXG52YXIgU0hBM19OVUxMX1MgPSAnMHhjNWQyNDYwMTg2ZjcyMzNjOTI3ZTdkYjJkY2M3MDNjMGU1MDBiNjUzY2E4MjI3M2I3YmZhZDgwNDVkODVhNDcwJztcbnZhciBzaGEzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKGlzQk4odmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKGlzSGV4U3RyaWN0KHZhbHVlKSAmJiAvXjB4L2kudGVzdCgodmFsdWUpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgIHZhbHVlID0gZXRoZXJldW1qc1V0aWwudG9CdWZmZXIodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIEFzc3VtZSB2YWx1ZSBpcyBhbiBhcmJpdHJhcnkgc3RyaW5nXG4gICAgICAgIHZhbHVlID0gQnVmZmVyLmZyb20odmFsdWUsICd1dGYtOCcpO1xuICAgIH1cbiAgICB2YXIgcmV0dXJuVmFsdWUgPSBldGhlcmV1bWpzVXRpbC5idWZmZXJUb0hleChldGhlcmV1bWpzVXRpbC5rZWNjYWsyNTYodmFsdWUpKTtcbiAgICBpZiAocmV0dXJuVmFsdWUgPT09IFNIQTNfTlVMTF9TKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH1cbn07XG4vLyBleHBvc2UgdGhlIHVuZGVyIHRoZSBob29kIGtlY2NhazI1Nlxuc2hhMy5fSGFzaCA9IGV0aGVyZXVtanNVdGlsLmtlY2NhazI1Njtcbi8qKlxuICogQG1ldGhvZCBzaGEzUmF3XG4gKlxuICogQHBhcmFtIHZhbHVlXG4gKlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xudmFyIHNoYTNSYXcgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YWx1ZSA9IHNoYTModmFsdWUpO1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gU0hBM19OVUxMX1M7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG4vKipcbiAqIEF1dG8gY29udmVydHMgYW55IGdpdmVuIHZhbHVlIGludG8gaXQncyBoZXggcmVwcmVzZW50YXRpb24sXG4gKiB0aGVuIGNvbnZlcnRzIGhleCB0byBudW1iZXIuXG4gKlxuICogQG1ldGhvZCB0b051bWJlclxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfEJOfSB2YWx1ZVxuICogQHBhcmFtIHtCb29sZWFufSBiaWdJbnRPbk92ZXJmbG93IC0gaWYgdHJ1ZSwgcmV0dXJuIHRoZSBoZXggdmFsdWUgaW4gY2FzZSBvZiBvdmVyZmxvd1xuICogQHJldHVybiB7TnVtYmVyfFN0cmluZ31cbiAqL1xudmFyIHRvTnVtYmVyID0gZnVuY3Rpb24gKHZhbHVlLCBiaWdJbnRPbk92ZXJmbG93ID0gZmFsc2UpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/IHZhbHVlIDogaGV4VG9OdW1iZXIodG9IZXgodmFsdWUpLCBiaWdJbnRPbk92ZXJmbG93KTtcbn07XG4vLyAxLnggY3VycmVudGx5IGFjY2VwdHMgMHguLi4gc3RyaW5ncywgYm4uanMgYWZ0ZXIgdXBkYXRlIGRvZXNuJ3QuIGl0IHdvdWxkIGJlIGEgYnJlYWtpbmcgY2hhbmdlXG52YXIgQk53cmFwcGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gY2hlY2sgbmVnYXRpdmVcbiAgICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIgJiYgdmFsdWUuaW5jbHVkZXMoXCIweFwiKSkge1xuICAgICAgICBjb25zdCBbbmVnYXRpdmUsIGhleFZhbHVlXSA9IHZhbHVlLnRvTG9jYWxlTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnLScpID8gW1wiLVwiLCB2YWx1ZS5zbGljZSgzKV0gOiBbXCJcIiwgdmFsdWUuc2xpY2UoMildO1xuICAgICAgICByZXR1cm4gbmV3IEJOKG5lZ2F0aXZlICsgaGV4VmFsdWUsIDE2KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgQk4odmFsdWUpO1xuICAgIH1cbn07XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQk53cmFwcGVkLCBCTik7XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQk53cmFwcGVkLnByb3RvdHlwZSwgQk4ucHJvdG90eXBlKTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIEJOOiBCTndyYXBwZWQsXG4gICAgaXNCTjogaXNCTixcbiAgICBpc0JpZ051bWJlcjogaXNCaWdOdW1iZXIsXG4gICAgdG9CTjogdG9CTixcbiAgICBpc0FkZHJlc3M6IGlzQWRkcmVzcyxcbiAgICBpc0Jsb29tOiBpc0Jsb29tLFxuICAgIGlzVXNlckV0aGVyZXVtQWRkcmVzc0luQmxvb206IGlzVXNlckV0aGVyZXVtQWRkcmVzc0luQmxvb20sXG4gICAgaXNDb250cmFjdEFkZHJlc3NJbkJsb29tOiBpc0NvbnRyYWN0QWRkcmVzc0luQmxvb20sXG4gICAgaXNUb3BpYzogaXNUb3BpYyxcbiAgICBpc1RvcGljSW5CbG9vbTogaXNUb3BpY0luQmxvb20sXG4gICAgaXNJbkJsb29tOiBpc0luQmxvb20sXG4gICAgY2hlY2tBZGRyZXNzQ2hlY2tzdW06IGNoZWNrQWRkcmVzc0NoZWNrc3VtLFxuICAgIHV0ZjhUb0hleDogdXRmOFRvSGV4LFxuICAgIGhleFRvVXRmODogaGV4VG9VdGY4LFxuICAgIGhleFRvTnVtYmVyOiBoZXhUb051bWJlcixcbiAgICBoZXhUb051bWJlclN0cmluZzogaGV4VG9OdW1iZXJTdHJpbmcsXG4gICAgbnVtYmVyVG9IZXg6IG51bWJlclRvSGV4LFxuICAgIHRvSGV4OiB0b0hleCxcbiAgICBoZXhUb0J5dGVzOiBoZXhUb0J5dGVzLFxuICAgIGJ5dGVzVG9IZXg6IGJ5dGVzVG9IZXgsXG4gICAgaXNIZXg6IGlzSGV4LFxuICAgIGlzSGV4U3RyaWN0OiBpc0hleFN0cmljdCxcbiAgICBzdHJpcEhleFByZWZpeDogc3RyaXBIZXhQcmVmaXgsXG4gICAgbGVmdFBhZDogbGVmdFBhZCxcbiAgICByaWdodFBhZDogcmlnaHRQYWQsXG4gICAgdG9Ud29zQ29tcGxlbWVudDogdG9Ud29zQ29tcGxlbWVudCxcbiAgICBzaGEzOiBzaGEzLFxuICAgIHNoYTNSYXc6IHNoYTNSYXcsXG4gICAgdG9OdW1iZXI6IHRvTnVtYmVyXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/web3-utils@1.10.0/node_modules/web3-utils/lib/utils.js\n");

/***/ })

};
;