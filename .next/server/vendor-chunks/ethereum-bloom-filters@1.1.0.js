"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ethereum-bloom-filters@1.1.0";
exports.ids = ["vendor-chunks/ethereum-bloom-filters@1.1.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/ethereum-bloom-filters@1.1.0/node_modules/ethereum-bloom-filters/dist/index.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/ethereum-bloom-filters@1.1.0/node_modules/ethereum-bloom-filters/dist/index.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/.pnpm/ethereum-bloom-filters@1.1.0/node_modules/ethereum-bloom-filters/dist/utils.js\");\n/**\n * Returns true if the bloom is a valid bloom\n * @param bloom The bloom\n */\nfunction isBloom(bloom) {\n    if (typeof bloom !== 'string') {\n        return false;\n    }\n    if (!/^(0x)?[0-9a-f]{512}$/i.test(bloom)) {\n        return false;\n    }\n    if (/^(0x)?[0-9a-f]{512}$/.test(bloom) ||\n        /^(0x)?[0-9A-F]{512}$/.test(bloom)) {\n        return true;\n    }\n    return false;\n}\nexports.isBloom = isBloom;\n/**\n * Returns true if the value is part of the given bloom\n * note: false positives are possible.\n * @param bloom encoded bloom\n * @param value The value\n */\nfunction isInBloom(bloom, value) {\n    if (typeof value === 'object' && value.constructor === Uint8Array) {\n        value = utils_1.bytesToHex(value);\n    }\n    const hash = utils_1.keccak256(value).replace('0x', '');\n    for (let i = 0; i < 12; i += 4) {\n        // calculate bit position in bloom filter that must be active\n        const bitpos = ((parseInt(hash.substr(i, 2), 16) << 8) +\n            parseInt(hash.substr(i + 2, 2), 16)) &\n            2047;\n        // test if bitpos in bloom is active\n        const code = codePointToInt(bloom.charCodeAt(bloom.length - 1 - Math.floor(bitpos / 4)));\n        const offset = 1 << bitpos % 4;\n        if ((code & offset) !== offset) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isInBloom = isInBloom;\n/**\n * Code points to int\n * @param codePoint The code point\n */\nfunction codePointToInt(codePoint) {\n    if (codePoint >= 48 && codePoint <= 57) {\n        /* ['0'..'9'] -> [0..9] */\n        return codePoint - 48;\n    }\n    if (codePoint >= 65 && codePoint <= 70) {\n        /* ['A'..'F'] -> [10..15] */\n        return codePoint - 55;\n    }\n    if (codePoint >= 97 && codePoint <= 102) {\n        /* ['a'..'f'] -> [10..15] */\n        return codePoint - 87;\n    }\n    throw new Error('invalid bloom');\n}\n/**\n * Returns true if the ethereum users address is part of the given bloom.\n * note: false positives are possible.\n * @param bloom encoded bloom\n * @param address the address to test\n */\nfunction isUserEthereumAddressInBloom(bloom, ethereumAddress) {\n    if (!isBloom(bloom)) {\n        throw new Error('Invalid bloom given');\n    }\n    if (!isAddress(ethereumAddress)) {\n        throw new Error(`Invalid ethereum address given: \"${ethereumAddress}\"`);\n    }\n    // you have to pad the ethereum address to 32 bytes\n    // else the bloom filter does not work\n    // this is only if your matching the USERS\n    // ethereum address. Contract address do not need this\n    // hence why we have 2 methods\n    // (0x is not in the 2nd parameter of padleft so 64 chars is fine)\n    const address = utils_1.padLeft(ethereumAddress, 64);\n    return isInBloom(bloom, address);\n}\nexports.isUserEthereumAddressInBloom = isUserEthereumAddressInBloom;\n/**\n * Returns true if the contract address is part of the given bloom.\n * note: false positives are possible.\n * @param bloom encoded bloom\n * @param contractAddress the contract address to test\n */\nfunction isContractAddressInBloom(bloom, contractAddress) {\n    if (!isBloom(bloom)) {\n        throw new Error('Invalid bloom given');\n    }\n    if (!isAddress(contractAddress)) {\n        throw new Error(`Invalid contract address given: \"${contractAddress}\"`);\n    }\n    return isInBloom(bloom, contractAddress);\n}\nexports.isContractAddressInBloom = isContractAddressInBloom;\n/**\n * Returns true if the topic is part of the given bloom.\n * note: false positives are possible.\n * @param bloom encoded bloom\n * @param topic the topic encoded hex\n */\nfunction isTopicInBloom(bloom, topic) {\n    if (!isBloom(bloom)) {\n        throw new Error('Invalid bloom given');\n    }\n    if (!isTopic(topic)) {\n        throw new Error('Invalid topic');\n    }\n    return isInBloom(bloom, topic);\n}\nexports.isTopicInBloom = isTopicInBloom;\n/**\n * Checks if its a valid topic\n * @param topic encoded hex topic\n */\nfunction isTopic(topic) {\n    if (typeof topic !== 'string') {\n        return false;\n    }\n    if (!/^(0x)?[0-9a-f]{64}$/i.test(topic)) {\n        return false;\n    }\n    else if (/^(0x)?[0-9a-f]{64}$/.test(topic) ||\n        /^(0x)?[0-9A-F]{64}$/.test(topic)) {\n        return true;\n    }\n    return false;\n}\nexports.isTopic = isTopic;\n/**\n * Is valid address\n * @param address The address\n */\nfunction isAddress(address) {\n    if (typeof address !== 'string') {\n        return false;\n    }\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n        return true;\n    }\n    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n        return true;\n    }\n    return false;\n}\nexports.isAddress = isAddress;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJldW0tYmxvb20tZmlsdGVyc0AxLjEuMC9ub2RlX21vZHVsZXMvZXRoZXJldW0tYmxvb20tZmlsdGVycy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixtQkFBTyxDQUFDLDBIQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsSUFBSTtBQUM3QjtBQUNBO0FBQ0Esd0JBQXdCLElBQUk7QUFDNUIsd0JBQXdCLElBQUk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxnQkFBZ0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxnQkFBZ0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLEdBQUc7QUFDNUI7QUFDQTtBQUNBLDZCQUE2QixHQUFHO0FBQ2hDLHdCQUF3QixHQUFHO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsR0FBRztBQUM1QztBQUNBO0FBQ0EsZ0NBQWdDLEVBQUUsWUFBWSxNQUFNO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8va2lja3N0YXJ0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2V0aGVyZXVtLWJsb29tLWZpbHRlcnNAMS4xLjAvbm9kZV9tb2R1bGVzL2V0aGVyZXVtLWJsb29tLWZpbHRlcnMvZGlzdC9pbmRleC5qcz85MzUxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGJsb29tIGlzIGEgdmFsaWQgYmxvb21cbiAqIEBwYXJhbSBibG9vbSBUaGUgYmxvb21cbiAqL1xuZnVuY3Rpb24gaXNCbG9vbShibG9vbSkge1xuICAgIGlmICh0eXBlb2YgYmxvb20gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCEvXigweCk/WzAtOWEtZl17NTEyfSQvaS50ZXN0KGJsb29tKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICgvXigweCk/WzAtOWEtZl17NTEyfSQvLnRlc3QoYmxvb20pIHx8XG4gICAgICAgIC9eKDB4KT9bMC05QS1GXXs1MTJ9JC8udGVzdChibG9vbSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuaXNCbG9vbSA9IGlzQmxvb207XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgcGFydCBvZiB0aGUgZ2l2ZW4gYmxvb21cbiAqIG5vdGU6IGZhbHNlIHBvc2l0aXZlcyBhcmUgcG9zc2libGUuXG4gKiBAcGFyYW0gYmxvb20gZW5jb2RlZCBibG9vbVxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZVxuICovXG5mdW5jdGlvbiBpc0luQmxvb20oYmxvb20sIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgdmFsdWUgPSB1dGlsc18xLmJ5dGVzVG9IZXgodmFsdWUpO1xuICAgIH1cbiAgICBjb25zdCBoYXNoID0gdXRpbHNfMS5rZWNjYWsyNTYodmFsdWUpLnJlcGxhY2UoJzB4JywgJycpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTI7IGkgKz0gNCkge1xuICAgICAgICAvLyBjYWxjdWxhdGUgYml0IHBvc2l0aW9uIGluIGJsb29tIGZpbHRlciB0aGF0IG11c3QgYmUgYWN0aXZlXG4gICAgICAgIGNvbnN0IGJpdHBvcyA9ICgocGFyc2VJbnQoaGFzaC5zdWJzdHIoaSwgMiksIDE2KSA8PCA4KSArXG4gICAgICAgICAgICBwYXJzZUludChoYXNoLnN1YnN0cihpICsgMiwgMiksIDE2KSkgJlxuICAgICAgICAgICAgMjA0NztcbiAgICAgICAgLy8gdGVzdCBpZiBiaXRwb3MgaW4gYmxvb20gaXMgYWN0aXZlXG4gICAgICAgIGNvbnN0IGNvZGUgPSBjb2RlUG9pbnRUb0ludChibG9vbS5jaGFyQ29kZUF0KGJsb29tLmxlbmd0aCAtIDEgLSBNYXRoLmZsb29yKGJpdHBvcyAvIDQpKSk7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IDEgPDwgYml0cG9zICUgNDtcbiAgICAgICAgaWYgKChjb2RlICYgb2Zmc2V0KSAhPT0gb2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmlzSW5CbG9vbSA9IGlzSW5CbG9vbTtcbi8qKlxuICogQ29kZSBwb2ludHMgdG8gaW50XG4gKiBAcGFyYW0gY29kZVBvaW50IFRoZSBjb2RlIHBvaW50XG4gKi9cbmZ1bmN0aW9uIGNvZGVQb2ludFRvSW50KGNvZGVQb2ludCkge1xuICAgIGlmIChjb2RlUG9pbnQgPj0gNDggJiYgY29kZVBvaW50IDw9IDU3KSB7XG4gICAgICAgIC8qIFsnMCcuLic5J10gLT4gWzAuLjldICovXG4gICAgICAgIHJldHVybiBjb2RlUG9pbnQgLSA0ODtcbiAgICB9XG4gICAgaWYgKGNvZGVQb2ludCA+PSA2NSAmJiBjb2RlUG9pbnQgPD0gNzApIHtcbiAgICAgICAgLyogWydBJy4uJ0YnXSAtPiBbMTAuLjE1XSAqL1xuICAgICAgICByZXR1cm4gY29kZVBvaW50IC0gNTU7XG4gICAgfVxuICAgIGlmIChjb2RlUG9pbnQgPj0gOTcgJiYgY29kZVBvaW50IDw9IDEwMikge1xuICAgICAgICAvKiBbJ2EnLi4nZiddIC0+IFsxMC4uMTVdICovXG4gICAgICAgIHJldHVybiBjb2RlUG9pbnQgLSA4NztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGJsb29tJyk7XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZXRoZXJldW0gdXNlcnMgYWRkcmVzcyBpcyBwYXJ0IG9mIHRoZSBnaXZlbiBibG9vbS5cbiAqIG5vdGU6IGZhbHNlIHBvc2l0aXZlcyBhcmUgcG9zc2libGUuXG4gKiBAcGFyYW0gYmxvb20gZW5jb2RlZCBibG9vbVxuICogQHBhcmFtIGFkZHJlc3MgdGhlIGFkZHJlc3MgdG8gdGVzdFxuICovXG5mdW5jdGlvbiBpc1VzZXJFdGhlcmV1bUFkZHJlc3NJbkJsb29tKGJsb29tLCBldGhlcmV1bUFkZHJlc3MpIHtcbiAgICBpZiAoIWlzQmxvb20oYmxvb20pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBibG9vbSBnaXZlbicpO1xuICAgIH1cbiAgICBpZiAoIWlzQWRkcmVzcyhldGhlcmV1bUFkZHJlc3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBldGhlcmV1bSBhZGRyZXNzIGdpdmVuOiBcIiR7ZXRoZXJldW1BZGRyZXNzfVwiYCk7XG4gICAgfVxuICAgIC8vIHlvdSBoYXZlIHRvIHBhZCB0aGUgZXRoZXJldW0gYWRkcmVzcyB0byAzMiBieXRlc1xuICAgIC8vIGVsc2UgdGhlIGJsb29tIGZpbHRlciBkb2VzIG5vdCB3b3JrXG4gICAgLy8gdGhpcyBpcyBvbmx5IGlmIHlvdXIgbWF0Y2hpbmcgdGhlIFVTRVJTXG4gICAgLy8gZXRoZXJldW0gYWRkcmVzcy4gQ29udHJhY3QgYWRkcmVzcyBkbyBub3QgbmVlZCB0aGlzXG4gICAgLy8gaGVuY2Ugd2h5IHdlIGhhdmUgMiBtZXRob2RzXG4gICAgLy8gKDB4IGlzIG5vdCBpbiB0aGUgMm5kIHBhcmFtZXRlciBvZiBwYWRsZWZ0IHNvIDY0IGNoYXJzIGlzIGZpbmUpXG4gICAgY29uc3QgYWRkcmVzcyA9IHV0aWxzXzEucGFkTGVmdChldGhlcmV1bUFkZHJlc3MsIDY0KTtcbiAgICByZXR1cm4gaXNJbkJsb29tKGJsb29tLCBhZGRyZXNzKTtcbn1cbmV4cG9ydHMuaXNVc2VyRXRoZXJldW1BZGRyZXNzSW5CbG9vbSA9IGlzVXNlckV0aGVyZXVtQWRkcmVzc0luQmxvb207XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY29udHJhY3QgYWRkcmVzcyBpcyBwYXJ0IG9mIHRoZSBnaXZlbiBibG9vbS5cbiAqIG5vdGU6IGZhbHNlIHBvc2l0aXZlcyBhcmUgcG9zc2libGUuXG4gKiBAcGFyYW0gYmxvb20gZW5jb2RlZCBibG9vbVxuICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyB0aGUgY29udHJhY3QgYWRkcmVzcyB0byB0ZXN0XG4gKi9cbmZ1bmN0aW9uIGlzQ29udHJhY3RBZGRyZXNzSW5CbG9vbShibG9vbSwgY29udHJhY3RBZGRyZXNzKSB7XG4gICAgaWYgKCFpc0Jsb29tKGJsb29tKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYmxvb20gZ2l2ZW4nKTtcbiAgICB9XG4gICAgaWYgKCFpc0FkZHJlc3MoY29udHJhY3RBZGRyZXNzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY29udHJhY3QgYWRkcmVzcyBnaXZlbjogXCIke2NvbnRyYWN0QWRkcmVzc31cImApO1xuICAgIH1cbiAgICByZXR1cm4gaXNJbkJsb29tKGJsb29tLCBjb250cmFjdEFkZHJlc3MpO1xufVxuZXhwb3J0cy5pc0NvbnRyYWN0QWRkcmVzc0luQmxvb20gPSBpc0NvbnRyYWN0QWRkcmVzc0luQmxvb207XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdG9waWMgaXMgcGFydCBvZiB0aGUgZ2l2ZW4gYmxvb20uXG4gKiBub3RlOiBmYWxzZSBwb3NpdGl2ZXMgYXJlIHBvc3NpYmxlLlxuICogQHBhcmFtIGJsb29tIGVuY29kZWQgYmxvb21cbiAqIEBwYXJhbSB0b3BpYyB0aGUgdG9waWMgZW5jb2RlZCBoZXhcbiAqL1xuZnVuY3Rpb24gaXNUb3BpY0luQmxvb20oYmxvb20sIHRvcGljKSB7XG4gICAgaWYgKCFpc0Jsb29tKGJsb29tKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYmxvb20gZ2l2ZW4nKTtcbiAgICB9XG4gICAgaWYgKCFpc1RvcGljKHRvcGljKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdG9waWMnKTtcbiAgICB9XG4gICAgcmV0dXJuIGlzSW5CbG9vbShibG9vbSwgdG9waWMpO1xufVxuZXhwb3J0cy5pc1RvcGljSW5CbG9vbSA9IGlzVG9waWNJbkJsb29tO1xuLyoqXG4gKiBDaGVja3MgaWYgaXRzIGEgdmFsaWQgdG9waWNcbiAqIEBwYXJhbSB0b3BpYyBlbmNvZGVkIGhleCB0b3BpY1xuICovXG5mdW5jdGlvbiBpc1RvcGljKHRvcGljKSB7XG4gICAgaWYgKHR5cGVvZiB0b3BpYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIS9eKDB4KT9bMC05YS1mXXs2NH0kL2kudGVzdCh0b3BpYykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIGlmICgvXigweCk/WzAtOWEtZl17NjR9JC8udGVzdCh0b3BpYykgfHxcbiAgICAgICAgL14oMHgpP1swLTlBLUZdezY0fSQvLnRlc3QodG9waWMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmlzVG9waWMgPSBpc1RvcGljO1xuLyoqXG4gKiBJcyB2YWxpZCBhZGRyZXNzXG4gKiBAcGFyYW0gYWRkcmVzcyBUaGUgYWRkcmVzc1xuICovXG5mdW5jdGlvbiBpc0FkZHJlc3MoYWRkcmVzcykge1xuICAgIGlmICh0eXBlb2YgYWRkcmVzcyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYWRkcmVzcy5tYXRjaCgvXigweCk/WzAtOWEtZkEtRl17NDB9JC8pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoYWRkcmVzcy5tYXRjaCgvXlhFWzAtOV17Mn1bMC05QS1aYS16XXszMCwzMX0kLykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuaXNBZGRyZXNzID0gaXNBZGRyZXNzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/ethereum-bloom-filters@1.1.0/node_modules/ethereum-bloom-filters/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/ethereum-bloom-filters@1.1.0/node_modules/ethereum-bloom-filters/dist/utils.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/ethereum-bloom-filters@1.1.0/node_modules/ethereum-bloom-filters/dist/utils.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst sha3_1 = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/./node_modules/.pnpm/@noble+hashes@1.4.0/node_modules/@noble/hashes/sha3.js\");\n/**\n * Keccak256 hash\n * @param data The data\n */\nfunction keccak256(data) {\n    return bytesToHex(sha3_1.keccak_256(toByteArray(data)));\n}\nexports.keccak256 = keccak256;\n/**\n * Adding padding to string on the left\n * @param value The value\n * @param chars The chars\n */\nexports.padLeft = (value, chars) => {\n    const hasPrefix = /^0x/i.test(value) || typeof value === 'number';\n    value = value.toString().replace(/^0x/i, '');\n    const padding = chars - value.length + 1 >= 0 ? chars - value.length + 1 : 0;\n    return (hasPrefix ? '0x' : '') + new Array(padding).join('0') + value;\n};\n/**\n * Convert bytes to hex\n * @param bytes The bytes\n */\nfunction bytesToHex(bytes) {\n    const hex = [];\n    for (let i = 0; i < bytes.length; i++) {\n        hex.push((bytes[i] >>> 4).toString(16));\n        hex.push((bytes[i] & 0xf).toString(16));\n    }\n    return `0x${hex.join('').replace(/^0+/, '')}`;\n}\nexports.bytesToHex = bytesToHex;\n/**\n * To byte array\n * @param value The value\n */\nfunction toByteArray(value) {\n    if (value == null) {\n        throw new Error('cannot convert null value to array');\n    }\n    if (typeof value === 'string') {\n        const match = value.match(/^(0x)?[0-9a-fA-F]*$/);\n        if (!match) {\n            throw new Error('invalid hexidecimal string');\n        }\n        if (match[1] !== '0x') {\n            throw new Error('hex string must have 0x prefix');\n        }\n        value = value.substring(2);\n        if (value.length % 2) {\n            value = '0' + value;\n        }\n        const result = [];\n        for (let i = 0; i < value.length; i += 2) {\n            result.push(parseInt(value.substr(i, 2), 16));\n        }\n        return addSlice(new Uint8Array(result));\n    }\n    if (isByteArray(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n    throw new Error('invalid arrayify value');\n}\nexports.toByteArray = toByteArray;\n/**\n * Is byte array\n * @param value The value\n */\nfunction isByteArray(value) {\n    if (!value ||\n        // tslint:disable-next-line: radix\n        parseInt(String(value.length)) != value.length ||\n        typeof value === 'string') {\n        return false;\n    }\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        // tslint:disable-next-line: radix\n        if (v < 0 || v >= 256 || parseInt(String(v)) != v) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Add slice to array\n * @param array The array\n */\nfunction addSlice(array) {\n    if (array.slice !== undefined) {\n        return array;\n    }\n    array.slice = () => {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    };\n    return array;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZXRoZXJldW0tYmxvb20tZmlsdGVyc0AxLjEuMC9ub2RlX21vZHVsZXMvZXRoZXJldW0tYmxvb20tZmlsdGVycy9kaXN0L3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWUsbUJBQU8sQ0FBQyw2R0FBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0NBQWdDO0FBQ2hEO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8va2lja3N0YXJ0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2V0aGVyZXVtLWJsb29tLWZpbHRlcnNAMS4xLjAvbm9kZV9tb2R1bGVzL2V0aGVyZXVtLWJsb29tLWZpbHRlcnMvZGlzdC91dGlscy5qcz8yYTVlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3Qgc2hhM18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2hhM1wiKTtcbi8qKlxuICogS2VjY2FrMjU2IGhhc2hcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhXG4gKi9cbmZ1bmN0aW9uIGtlY2NhazI1NihkYXRhKSB7XG4gICAgcmV0dXJuIGJ5dGVzVG9IZXgoc2hhM18xLmtlY2Nha18yNTYodG9CeXRlQXJyYXkoZGF0YSkpKTtcbn1cbmV4cG9ydHMua2VjY2FrMjU2ID0ga2VjY2FrMjU2O1xuLyoqXG4gKiBBZGRpbmcgcGFkZGluZyB0byBzdHJpbmcgb24gdGhlIGxlZnRcbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWVcbiAqIEBwYXJhbSBjaGFycyBUaGUgY2hhcnNcbiAqL1xuZXhwb3J0cy5wYWRMZWZ0ID0gKHZhbHVlLCBjaGFycykgPT4ge1xuICAgIGNvbnN0IGhhc1ByZWZpeCA9IC9eMHgvaS50ZXN0KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xuICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKS5yZXBsYWNlKC9eMHgvaSwgJycpO1xuICAgIGNvbnN0IHBhZGRpbmcgPSBjaGFycyAtIHZhbHVlLmxlbmd0aCArIDEgPj0gMCA/IGNoYXJzIC0gdmFsdWUubGVuZ3RoICsgMSA6IDA7XG4gICAgcmV0dXJuIChoYXNQcmVmaXggPyAnMHgnIDogJycpICsgbmV3IEFycmF5KHBhZGRpbmcpLmpvaW4oJzAnKSArIHZhbHVlO1xufTtcbi8qKlxuICogQ29udmVydCBieXRlcyB0byBoZXhcbiAqIEBwYXJhbSBieXRlcyBUaGUgYnl0ZXNcbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGNvbnN0IGhleCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4LnB1c2goKGJ5dGVzW2ldID4+PiA0KS50b1N0cmluZygxNikpO1xuICAgICAgICBoZXgucHVzaCgoYnl0ZXNbaV0gJiAweGYpLnRvU3RyaW5nKDE2KSk7XG4gICAgfVxuICAgIHJldHVybiBgMHgke2hleC5qb2luKCcnKS5yZXBsYWNlKC9eMCsvLCAnJyl9YDtcbn1cbmV4cG9ydHMuYnl0ZXNUb0hleCA9IGJ5dGVzVG9IZXg7XG4vKipcbiAqIFRvIGJ5dGUgYXJyYXlcbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdG9CeXRlQXJyYXkodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBjb252ZXJ0IG51bGwgdmFsdWUgdG8gYXJyYXknKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB2YWx1ZS5tYXRjaCgvXigweCk/WzAtOWEtZkEtRl0qJC8pO1xuICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaGV4aWRlY2ltYWwgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoWzFdICE9PSAnMHgnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgbXVzdCBoYXZlIDB4IHByZWZpeCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDIpO1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoICUgMikge1xuICAgICAgICAgICAgdmFsdWUgPSAnMCcgKyB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VJbnQodmFsdWUuc3Vic3RyKGksIDIpLCAxNikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZGRTbGljZShuZXcgVWludDhBcnJheShyZXN1bHQpKTtcbiAgICB9XG4gICAgaWYgKGlzQnl0ZUFycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gYWRkU2xpY2UobmV3IFVpbnQ4QXJyYXkodmFsdWUpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFycmF5aWZ5IHZhbHVlJyk7XG59XG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXk7XG4vKipcbiAqIElzIGJ5dGUgYXJyYXlcbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWVcbiAqL1xuZnVuY3Rpb24gaXNCeXRlQXJyYXkodmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlIHx8XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogcmFkaXhcbiAgICAgICAgcGFyc2VJbnQoU3RyaW5nKHZhbHVlLmxlbmd0aCkpICE9IHZhbHVlLmxlbmd0aCB8fFxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB2ID0gdmFsdWVbaV07XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogcmFkaXhcbiAgICAgICAgaWYgKHYgPCAwIHx8IHYgPj0gMjU2IHx8IHBhcnNlSW50KFN0cmluZyh2KSkgIT0gdikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBBZGQgc2xpY2UgdG8gYXJyYXlcbiAqIEBwYXJhbSBhcnJheSBUaGUgYXJyYXlcbiAqL1xuZnVuY3Rpb24gYWRkU2xpY2UoYXJyYXkpIHtcbiAgICBpZiAoYXJyYXkuc2xpY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICAgIGFycmF5LnNsaWNlID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIGFkZFNsaWNlKG5ldyBVaW50OEFycmF5KEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcnJheSwgYXJncykpKTtcbiAgICB9O1xuICAgIHJldHVybiBhcnJheTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/ethereum-bloom-filters@1.1.0/node_modules/ethereum-bloom-filters/dist/utils.js\n");

/***/ })

};
;