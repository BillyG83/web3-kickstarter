/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/abortcontroller-polyfill@1.7.5";
exports.ids = ["vendor-chunks/abortcontroller-polyfill@1.7.5"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/abortcontroller-polyfill@1.7.5/node_modules/abortcontroller-polyfill/dist/polyfill-patch-fetch.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/abortcontroller-polyfill@1.7.5/node_modules/abortcontroller-polyfill/dist/polyfill-patch-fetch.js ***!
  \******************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n   true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) :\n  0;\n})((function () { 'use strict';\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n      writable: false\n    });\n    return Constructor;\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        writable: true,\n        configurable: true\n      }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n      writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n  }\n\n  function _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n      return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n  }\n\n  function _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n    return _setPrototypeOf(o, p);\n  }\n\n  function _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n\n    try {\n      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return self;\n  }\n\n  function _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n      return call;\n    } else if (call !== void 0) {\n      throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n\n    return _assertThisInitialized(self);\n  }\n\n  function _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n    return function _createSuperInternal() {\n      var Super = _getPrototypeOf(Derived),\n          result;\n\n      if (hasNativeReflectConstruct) {\n        var NewTarget = _getPrototypeOf(this).constructor;\n\n        result = Reflect.construct(Super, arguments, NewTarget);\n      } else {\n        result = Super.apply(this, arguments);\n      }\n\n      return _possibleConstructorReturn(this, result);\n    };\n  }\n\n  function _superPropBase(object, property) {\n    while (!Object.prototype.hasOwnProperty.call(object, property)) {\n      object = _getPrototypeOf(object);\n      if (object === null) break;\n    }\n\n    return object;\n  }\n\n  function _get() {\n    if (typeof Reflect !== \"undefined\" && Reflect.get) {\n      _get = Reflect.get.bind();\n    } else {\n      _get = function _get(target, property, receiver) {\n        var base = _superPropBase(target, property);\n\n        if (!base) return;\n        var desc = Object.getOwnPropertyDescriptor(base, property);\n\n        if (desc.get) {\n          return desc.get.call(arguments.length < 3 ? target : receiver);\n        }\n\n        return desc.value;\n      };\n    }\n\n    return _get.apply(this, arguments);\n  }\n\n  var Emitter = /*#__PURE__*/function () {\n    function Emitter() {\n      _classCallCheck(this, Emitter);\n\n      Object.defineProperty(this, 'listeners', {\n        value: {},\n        writable: true,\n        configurable: true\n      });\n    }\n\n    _createClass(Emitter, [{\n      key: \"addEventListener\",\n      value: function addEventListener(type, callback, options) {\n        if (!(type in this.listeners)) {\n          this.listeners[type] = [];\n        }\n\n        this.listeners[type].push({\n          callback: callback,\n          options: options\n        });\n      }\n    }, {\n      key: \"removeEventListener\",\n      value: function removeEventListener(type, callback) {\n        if (!(type in this.listeners)) {\n          return;\n        }\n\n        var stack = this.listeners[type];\n\n        for (var i = 0, l = stack.length; i < l; i++) {\n          if (stack[i].callback === callback) {\n            stack.splice(i, 1);\n            return;\n          }\n        }\n      }\n    }, {\n      key: \"dispatchEvent\",\n      value: function dispatchEvent(event) {\n        if (!(event.type in this.listeners)) {\n          return;\n        }\n\n        var stack = this.listeners[event.type];\n        var stackToCall = stack.slice();\n\n        for (var i = 0, l = stackToCall.length; i < l; i++) {\n          var listener = stackToCall[i];\n\n          try {\n            listener.callback.call(this, event);\n          } catch (e) {\n            Promise.resolve().then(function () {\n              throw e;\n            });\n          }\n\n          if (listener.options && listener.options.once) {\n            this.removeEventListener(event.type, listener.callback);\n          }\n        }\n\n        return !event.defaultPrevented;\n      }\n    }]);\n\n    return Emitter;\n  }();\n\n  var AbortSignal = /*#__PURE__*/function (_Emitter) {\n    _inherits(AbortSignal, _Emitter);\n\n    var _super = _createSuper(AbortSignal);\n\n    function AbortSignal() {\n      var _this;\n\n      _classCallCheck(this, AbortSignal);\n\n      _this = _super.call(this); // Some versions of babel does not transpile super() correctly for IE <= 10, if the parent\n      // constructor has failed to run, then \"this.listeners\" will still be undefined and then we call\n      // the parent constructor directly instead as a workaround. For general details, see babel bug:\n      // https://github.com/babel/babel/issues/3041\n      // This hack was added as a fix for the issue described here:\n      // https://github.com/Financial-Times/polyfill-library/pull/59#issuecomment-477558042\n\n      if (!_this.listeners) {\n        Emitter.call(_assertThisInitialized(_this));\n      } // Compared to assignment, Object.defineProperty makes properties non-enumerable by default and\n      // we want Object.keys(new AbortController().signal) to be [] for compat with the native impl\n\n\n      Object.defineProperty(_assertThisInitialized(_this), 'aborted', {\n        value: false,\n        writable: true,\n        configurable: true\n      });\n      Object.defineProperty(_assertThisInitialized(_this), 'onabort', {\n        value: null,\n        writable: true,\n        configurable: true\n      });\n      Object.defineProperty(_assertThisInitialized(_this), 'reason', {\n        value: undefined,\n        writable: true,\n        configurable: true\n      });\n      return _this;\n    }\n\n    _createClass(AbortSignal, [{\n      key: \"toString\",\n      value: function toString() {\n        return '[object AbortSignal]';\n      }\n    }, {\n      key: \"dispatchEvent\",\n      value: function dispatchEvent(event) {\n        if (event.type === 'abort') {\n          this.aborted = true;\n\n          if (typeof this.onabort === 'function') {\n            this.onabort.call(this, event);\n          }\n        }\n\n        _get(_getPrototypeOf(AbortSignal.prototype), \"dispatchEvent\", this).call(this, event);\n      }\n    }]);\n\n    return AbortSignal;\n  }(Emitter);\n  var AbortController = /*#__PURE__*/function () {\n    function AbortController() {\n      _classCallCheck(this, AbortController);\n\n      // Compared to assignment, Object.defineProperty makes properties non-enumerable by default and\n      // we want Object.keys(new AbortController()) to be [] for compat with the native impl\n      Object.defineProperty(this, 'signal', {\n        value: new AbortSignal(),\n        writable: true,\n        configurable: true\n      });\n    }\n\n    _createClass(AbortController, [{\n      key: \"abort\",\n      value: function abort(reason) {\n        var event;\n\n        try {\n          event = new Event('abort');\n        } catch (e) {\n          if (typeof document !== 'undefined') {\n            if (!document.createEvent) {\n              // For Internet Explorer 8:\n              event = document.createEventObject();\n              event.type = 'abort';\n            } else {\n              // For Internet Explorer 11:\n              event = document.createEvent('Event');\n              event.initEvent('abort', false, false);\n            }\n          } else {\n            // Fallback where document isn't available:\n            event = {\n              type: 'abort',\n              bubbles: false,\n              cancelable: false\n            };\n          }\n        }\n\n        var signalReason = reason;\n\n        if (signalReason === undefined) {\n          if (typeof document === 'undefined') {\n            signalReason = new Error('This operation was aborted');\n            signalReason.name = 'AbortError';\n          } else {\n            try {\n              signalReason = new DOMException('signal is aborted without reason');\n            } catch (err) {\n              // IE 11 does not support calling the DOMException constructor, use a\n              // regular error object on it instead.\n              signalReason = new Error('This operation was aborted');\n              signalReason.name = 'AbortError';\n            }\n          }\n        }\n\n        this.signal.reason = signalReason;\n        this.signal.dispatchEvent(event);\n      }\n    }, {\n      key: \"toString\",\n      value: function toString() {\n        return '[object AbortController]';\n      }\n    }]);\n\n    return AbortController;\n  }();\n\n  if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n    // These are necessary to make sure that we get correct output for:\n    // Object.prototype.toString.call(new AbortController())\n    AbortController.prototype[Symbol.toStringTag] = 'AbortController';\n    AbortSignal.prototype[Symbol.toStringTag] = 'AbortSignal';\n  }\n\n  function polyfillNeeded(self) {\n    if (self.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL) {\n      console.log('__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL=true is set, will force install polyfill');\n      return true;\n    } // Note that the \"unfetch\" minimal fetch polyfill defines fetch() without\n    // defining window.Request, and this polyfill need to work on top of unfetch\n    // so the below feature detection needs the !self.AbortController part.\n    // The Request.prototype check is also needed because Safari versions 11.1.2\n    // up to and including 12.1.x has a window.AbortController present but still\n    // does NOT correctly implement abortable fetch:\n    // https://bugs.webkit.org/show_bug.cgi?id=174980#c2\n\n\n    return typeof self.Request === 'function' && !self.Request.prototype.hasOwnProperty('signal') || !self.AbortController;\n  }\n\n  /**\n   * Note: the \"fetch.Request\" default value is available for fetch imported from\n   * the \"node-fetch\" package and not in browsers. This is OK since browsers\n   * will be importing umd-polyfill.js from that path \"self\" is passed the\n   * decorator so the default value will not be used (because browsers that define\n   * fetch also has Request). One quirky setup where self.fetch exists but\n   * self.Request does not is when the \"unfetch\" minimal fetch polyfill is used\n   * on top of IE11; for this case the browser will try to use the fetch.Request\n   * default value which in turn will be undefined but then then \"if (Request)\"\n   * will ensure that you get a patched fetch but still no Request (as expected).\n   * @param {fetch, Request = fetch.Request}\n   * @returns {fetch: abortableFetch, Request: AbortableRequest}\n   */\n\n  function abortableFetchDecorator(patchTargets) {\n    if ('function' === typeof patchTargets) {\n      patchTargets = {\n        fetch: patchTargets\n      };\n    }\n\n    var _patchTargets = patchTargets,\n        fetch = _patchTargets.fetch,\n        _patchTargets$Request = _patchTargets.Request,\n        NativeRequest = _patchTargets$Request === void 0 ? fetch.Request : _patchTargets$Request,\n        NativeAbortController = _patchTargets.AbortController,\n        _patchTargets$__FORCE = _patchTargets.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL,\n        __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL = _patchTargets$__FORCE === void 0 ? false : _patchTargets$__FORCE;\n\n    if (!polyfillNeeded({\n      fetch: fetch,\n      Request: NativeRequest,\n      AbortController: NativeAbortController,\n      __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL: __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL\n    })) {\n      return {\n        fetch: fetch,\n        Request: Request\n      };\n    }\n\n    var Request = NativeRequest; // Note that the \"unfetch\" minimal fetch polyfill defines fetch() without\n    // defining window.Request, and this polyfill need to work on top of unfetch\n    // hence we only patch it if it's available. Also we don't patch it if signal\n    // is already available on the Request prototype because in this case support\n    // is present and the patching below can cause a crash since it assigns to\n    // request.signal which is technically a read-only property. This latter error\n    // happens when you run the main5.js node-fetch example in the repo\n    // \"abortcontroller-polyfill-examples\". The exact error is:\n    //   request.signal = init.signal;\n    //   ^\n    // TypeError: Cannot set property signal of #<Request> which has only a getter\n\n    if (Request && !Request.prototype.hasOwnProperty('signal') || __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL) {\n      Request = function Request(input, init) {\n        var signal;\n\n        if (init && init.signal) {\n          signal = init.signal; // Never pass init.signal to the native Request implementation when the polyfill has\n          // been installed because if we're running on top of a browser with a\n          // working native AbortController (i.e. the polyfill was installed due to\n          // __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL being set), then passing our\n          // fake AbortSignal to the native fetch will trigger:\n          // TypeError: Failed to construct 'Request': member signal is not of type AbortSignal.\n\n          delete init.signal;\n        }\n\n        var request = new NativeRequest(input, init);\n\n        if (signal) {\n          Object.defineProperty(request, 'signal', {\n            writable: false,\n            enumerable: false,\n            configurable: true,\n            value: signal\n          });\n        }\n\n        return request;\n      };\n\n      Request.prototype = NativeRequest.prototype;\n    }\n\n    var realFetch = fetch;\n\n    var abortableFetch = function abortableFetch(input, init) {\n      var signal = Request && Request.prototype.isPrototypeOf(input) ? input.signal : init ? init.signal : undefined;\n\n      if (signal) {\n        var abortError;\n\n        try {\n          abortError = new DOMException('Aborted', 'AbortError');\n        } catch (err) {\n          // IE 11 does not support calling the DOMException constructor, use a\n          // regular error object on it instead.\n          abortError = new Error('Aborted');\n          abortError.name = 'AbortError';\n        } // Return early if already aborted, thus avoiding making an HTTP request\n\n\n        if (signal.aborted) {\n          return Promise.reject(abortError);\n        } // Turn an event into a promise, reject it once `abort` is dispatched\n\n\n        var cancellation = new Promise(function (_, reject) {\n          signal.addEventListener('abort', function () {\n            return reject(abortError);\n          }, {\n            once: true\n          });\n        });\n\n        if (init && init.signal) {\n          // Never pass .signal to the native implementation when the polyfill has\n          // been installed because if we're running on top of a browser with a\n          // working native AbortController (i.e. the polyfill was installed due to\n          // __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL being set), then passing our\n          // fake AbortSignal to the native fetch will trigger:\n          // TypeError: Failed to execute 'fetch' on 'Window': member signal is not of type AbortSignal.\n          delete init.signal;\n        } // Return the fastest promise (don't need to wait for request to finish)\n\n\n        return Promise.race([cancellation, realFetch(input, init)]);\n      }\n\n      return realFetch(input, init);\n    };\n\n    return {\n      fetch: abortableFetch,\n      Request: Request\n    };\n  }\n\n  (function (self) {\n\n    if (!polyfillNeeded(self)) {\n      return;\n    }\n\n    if (!self.fetch) {\n      console.warn('fetch() is not available, cannot install abortcontroller-polyfill');\n      return;\n    }\n\n    var _abortableFetch = abortableFetchDecorator(self),\n        fetch = _abortableFetch.fetch,\n        Request = _abortableFetch.Request;\n\n    self.fetch = fetch;\n    self.Request = Request;\n    Object.defineProperty(self, 'AbortController', {\n      writable: true,\n      enumerable: false,\n      configurable: true,\n      value: AbortController\n    });\n    Object.defineProperty(self, 'AbortSignal', {\n      writable: true,\n      enumerable: false,\n      configurable: true,\n      value: AbortSignal\n    });\n  })(typeof self !== 'undefined' ? self : global);\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYWJvcnRjb250cm9sbGVyLXBvbHlmaWxsQDEuNy41L25vZGVfbW9kdWxlcy9hYm9ydGNvbnRyb2xsZXItcG9seWZpbGwvZGlzdC9wb2x5ZmlsbC1wYXRjaC1mZXRjaC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLEVBQUUsS0FBMEMsR0FBRyxvQ0FBTyxPQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUEsa0dBQUM7QUFDOUQsRUFBRSxDQUFTO0FBQ1gsQ0FBQyxpQkFBaUI7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdEQUFnRCxPQUFPO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVILENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9raWNrc3RhcnQvLi9ub2RlX21vZHVsZXMvLnBucG0vYWJvcnRjb250cm9sbGVyLXBvbHlmaWxsQDEuNy41L25vZGVfbW9kdWxlcy9hYm9ydGNvbnRyb2xsZXItcG9seWZpbGwvZGlzdC9wb2x5ZmlsbC1wYXRjaC1mZXRjaC5qcz9lYjdjIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICBmYWN0b3J5KCk7XG59KSgoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwge1xuICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgfSk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cblxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7XG4gICAgICB3cml0YWJsZTogZmFsc2VcbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG4gIH1cblxuICBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgICB0cnkge1xuICAgICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgIHJldHVybiBjYWxsO1xuICAgIH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICAgIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgICAgIHJlc3VsdDtcblxuICAgICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcblxuICAgICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgZnVuY3Rpb24gX2dldCgpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICAgIF9nZXQgPSBSZWZsZWN0LmdldC5iaW5kKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwoYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiByZWNlaXZlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9nZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHZhciBFbWl0dGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbWl0dGVyKCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVtaXR0ZXIpO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2xpc3RlbmVycycsIHtcbiAgICAgICAgdmFsdWU6IHt9LFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoRW1pdHRlciwgW3tcbiAgICAgIGtleTogXCJhZGRFdmVudExpc3RlbmVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgICBpZiAoISh0eXBlIGluIHRoaXMubGlzdGVuZXJzKSkge1xuICAgICAgICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdID0gW107XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXS5wdXNoKHtcbiAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCEodHlwZSBpbiB0aGlzLmxpc3RlbmVycykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhY2sgPSB0aGlzLmxpc3RlbmVyc1t0eXBlXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0YWNrLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmIChzdGFja1tpXS5jYWxsYmFjayA9PT0gY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHN0YWNrLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGlzcGF0Y2hFdmVudFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKCEoZXZlbnQudHlwZSBpbiB0aGlzLmxpc3RlbmVycykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhY2sgPSB0aGlzLmxpc3RlbmVyc1tldmVudC50eXBlXTtcbiAgICAgICAgdmFyIHN0YWNrVG9DYWxsID0gc3RhY2suc2xpY2UoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0YWNrVG9DYWxsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBsaXN0ZW5lciA9IHN0YWNrVG9DYWxsW2ldO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxpc3RlbmVyLmNhbGxiYWNrLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxpc3RlbmVyLm9wdGlvbnMgJiYgbGlzdGVuZXIub3B0aW9ucy5vbmNlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQudHlwZSwgbGlzdGVuZXIuY2FsbGJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRW1pdHRlcjtcbiAgfSgpO1xuXG4gIHZhciBBYm9ydFNpZ25hbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VtaXR0ZXIpIHtcbiAgICBfaW5oZXJpdHMoQWJvcnRTaWduYWwsIF9FbWl0dGVyKTtcblxuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQWJvcnRTaWduYWwpO1xuXG4gICAgZnVuY3Rpb24gQWJvcnRTaWduYWwoKSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBYm9ydFNpZ25hbCk7XG5cbiAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7IC8vIFNvbWUgdmVyc2lvbnMgb2YgYmFiZWwgZG9lcyBub3QgdHJhbnNwaWxlIHN1cGVyKCkgY29ycmVjdGx5IGZvciBJRSA8PSAxMCwgaWYgdGhlIHBhcmVudFxuICAgICAgLy8gY29uc3RydWN0b3IgaGFzIGZhaWxlZCB0byBydW4sIHRoZW4gXCJ0aGlzLmxpc3RlbmVyc1wiIHdpbGwgc3RpbGwgYmUgdW5kZWZpbmVkIGFuZCB0aGVuIHdlIGNhbGxcbiAgICAgIC8vIHRoZSBwYXJlbnQgY29uc3RydWN0b3IgZGlyZWN0bHkgaW5zdGVhZCBhcyBhIHdvcmthcm91bmQuIEZvciBnZW5lcmFsIGRldGFpbHMsIHNlZSBiYWJlbCBidWc6XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYmFiZWwvYmFiZWwvaXNzdWVzLzMwNDFcbiAgICAgIC8vIFRoaXMgaGFjayB3YXMgYWRkZWQgYXMgYSBmaXggZm9yIHRoZSBpc3N1ZSBkZXNjcmliZWQgaGVyZTpcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9GaW5hbmNpYWwtVGltZXMvcG9seWZpbGwtbGlicmFyeS9wdWxsLzU5I2lzc3VlY29tbWVudC00Nzc1NTgwNDJcblxuICAgICAgaWYgKCFfdGhpcy5saXN0ZW5lcnMpIHtcbiAgICAgICAgRW1pdHRlci5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICAgIH0gLy8gQ29tcGFyZWQgdG8gYXNzaWdubWVudCwgT2JqZWN0LmRlZmluZVByb3BlcnR5IG1ha2VzIHByb3BlcnRpZXMgbm9uLWVudW1lcmFibGUgYnkgZGVmYXVsdCBhbmRcbiAgICAgIC8vIHdlIHdhbnQgT2JqZWN0LmtleXMobmV3IEFib3J0Q29udHJvbGxlcigpLnNpZ25hbCkgdG8gYmUgW10gZm9yIGNvbXBhdCB3aXRoIHRoZSBuYXRpdmUgaW1wbFxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgJ2Fib3J0ZWQnLCB7XG4gICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksICdvbmFib3J0Jywge1xuICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksICdyZWFzb24nLCB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhBYm9ydFNpZ25hbCwgW3tcbiAgICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gJ1tvYmplY3QgQWJvcnRTaWduYWxdJztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGlzcGF0Y2hFdmVudFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdhYm9ydCcpIHtcbiAgICAgICAgICB0aGlzLmFib3J0ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9uYWJvcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMub25hYm9ydC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihBYm9ydFNpZ25hbC5wcm90b3R5cGUpLCBcImRpc3BhdGNoRXZlbnRcIiwgdGhpcykuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEFib3J0U2lnbmFsO1xuICB9KEVtaXR0ZXIpO1xuICB2YXIgQWJvcnRDb250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBYm9ydENvbnRyb2xsZXIoKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWJvcnRDb250cm9sbGVyKTtcblxuICAgICAgLy8gQ29tcGFyZWQgdG8gYXNzaWdubWVudCwgT2JqZWN0LmRlZmluZVByb3BlcnR5IG1ha2VzIHByb3BlcnRpZXMgbm9uLWVudW1lcmFibGUgYnkgZGVmYXVsdCBhbmRcbiAgICAgIC8vIHdlIHdhbnQgT2JqZWN0LmtleXMobmV3IEFib3J0Q29udHJvbGxlcigpKSB0byBiZSBbXSBmb3IgY29tcGF0IHdpdGggdGhlIG5hdGl2ZSBpbXBsXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3NpZ25hbCcsIHtcbiAgICAgICAgdmFsdWU6IG5ldyBBYm9ydFNpZ25hbCgpLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQWJvcnRDb250cm9sbGVyLCBbe1xuICAgICAga2V5OiBcImFib3J0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWJvcnQocmVhc29uKSB7XG4gICAgICAgIHZhciBldmVudDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGV2ZW50ID0gbmV3IEV2ZW50KCdhYm9ydCcpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmICghZG9jdW1lbnQuY3JlYXRlRXZlbnQpIHtcbiAgICAgICAgICAgICAgLy8gRm9yIEludGVybmV0IEV4cGxvcmVyIDg6XG4gICAgICAgICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QoKTtcbiAgICAgICAgICAgICAgZXZlbnQudHlwZSA9ICdhYm9ydCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBGb3IgSW50ZXJuZXQgRXhwbG9yZXIgMTE6XG4gICAgICAgICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICAgICAgICAgIGV2ZW50LmluaXRFdmVudCgnYWJvcnQnLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFjayB3aGVyZSBkb2N1bWVudCBpc24ndCBhdmFpbGFibGU6XG4gICAgICAgICAgICBldmVudCA9IHtcbiAgICAgICAgICAgICAgdHlwZTogJ2Fib3J0JyxcbiAgICAgICAgICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICAgICAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaWduYWxSZWFzb24gPSByZWFzb247XG5cbiAgICAgICAgaWYgKHNpZ25hbFJlYXNvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHNpZ25hbFJlYXNvbiA9IG5ldyBFcnJvcignVGhpcyBvcGVyYXRpb24gd2FzIGFib3J0ZWQnKTtcbiAgICAgICAgICAgIHNpZ25hbFJlYXNvbi5uYW1lID0gJ0Fib3J0RXJyb3InO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzaWduYWxSZWFzb24gPSBuZXcgRE9NRXhjZXB0aW9uKCdzaWduYWwgaXMgYWJvcnRlZCB3aXRob3V0IHJlYXNvbicpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIC8vIElFIDExIGRvZXMgbm90IHN1cHBvcnQgY2FsbGluZyB0aGUgRE9NRXhjZXB0aW9uIGNvbnN0cnVjdG9yLCB1c2UgYVxuICAgICAgICAgICAgICAvLyByZWd1bGFyIGVycm9yIG9iamVjdCBvbiBpdCBpbnN0ZWFkLlxuICAgICAgICAgICAgICBzaWduYWxSZWFzb24gPSBuZXcgRXJyb3IoJ1RoaXMgb3BlcmF0aW9uIHdhcyBhYm9ydGVkJyk7XG4gICAgICAgICAgICAgIHNpZ25hbFJlYXNvbi5uYW1lID0gJ0Fib3J0RXJyb3InO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2lnbmFsLnJlYXNvbiA9IHNpZ25hbFJlYXNvbjtcbiAgICAgICAgdGhpcy5zaWduYWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAnW29iamVjdCBBYm9ydENvbnRyb2xsZXJdJztcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQWJvcnRDb250cm9sbGVyO1xuICB9KCk7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuICAgIC8vIFRoZXNlIGFyZSBuZWNlc3NhcnkgdG8gbWFrZSBzdXJlIHRoYXQgd2UgZ2V0IGNvcnJlY3Qgb3V0cHV0IGZvcjpcbiAgICAvLyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3IEFib3J0Q29udHJvbGxlcigpKVxuICAgIEFib3J0Q29udHJvbGxlci5wcm90b3R5cGVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9ICdBYm9ydENvbnRyb2xsZXInO1xuICAgIEFib3J0U2lnbmFsLnByb3RvdHlwZVtTeW1ib2wudG9TdHJpbmdUYWddID0gJ0Fib3J0U2lnbmFsJztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvbHlmaWxsTmVlZGVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZi5fX0ZPUkNFX0lOU1RBTExfQUJPUlRDT05UUk9MTEVSX1BPTFlGSUxMKSB7XG4gICAgICBjb25zb2xlLmxvZygnX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTD10cnVlIGlzIHNldCwgd2lsbCBmb3JjZSBpbnN0YWxsIHBvbHlmaWxsJyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIE5vdGUgdGhhdCB0aGUgXCJ1bmZldGNoXCIgbWluaW1hbCBmZXRjaCBwb2x5ZmlsbCBkZWZpbmVzIGZldGNoKCkgd2l0aG91dFxuICAgIC8vIGRlZmluaW5nIHdpbmRvdy5SZXF1ZXN0LCBhbmQgdGhpcyBwb2x5ZmlsbCBuZWVkIHRvIHdvcmsgb24gdG9wIG9mIHVuZmV0Y2hcbiAgICAvLyBzbyB0aGUgYmVsb3cgZmVhdHVyZSBkZXRlY3Rpb24gbmVlZHMgdGhlICFzZWxmLkFib3J0Q29udHJvbGxlciBwYXJ0LlxuICAgIC8vIFRoZSBSZXF1ZXN0LnByb3RvdHlwZSBjaGVjayBpcyBhbHNvIG5lZWRlZCBiZWNhdXNlIFNhZmFyaSB2ZXJzaW9ucyAxMS4xLjJcbiAgICAvLyB1cCB0byBhbmQgaW5jbHVkaW5nIDEyLjEueCBoYXMgYSB3aW5kb3cuQWJvcnRDb250cm9sbGVyIHByZXNlbnQgYnV0IHN0aWxsXG4gICAgLy8gZG9lcyBOT1QgY29ycmVjdGx5IGltcGxlbWVudCBhYm9ydGFibGUgZmV0Y2g6XG4gICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE3NDk4MCNjMlxuXG5cbiAgICByZXR1cm4gdHlwZW9mIHNlbGYuUmVxdWVzdCA9PT0gJ2Z1bmN0aW9uJyAmJiAhc2VsZi5SZXF1ZXN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnc2lnbmFsJykgfHwgIXNlbGYuQWJvcnRDb250cm9sbGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vdGU6IHRoZSBcImZldGNoLlJlcXVlc3RcIiBkZWZhdWx0IHZhbHVlIGlzIGF2YWlsYWJsZSBmb3IgZmV0Y2ggaW1wb3J0ZWQgZnJvbVxuICAgKiB0aGUgXCJub2RlLWZldGNoXCIgcGFja2FnZSBhbmQgbm90IGluIGJyb3dzZXJzLiBUaGlzIGlzIE9LIHNpbmNlIGJyb3dzZXJzXG4gICAqIHdpbGwgYmUgaW1wb3J0aW5nIHVtZC1wb2x5ZmlsbC5qcyBmcm9tIHRoYXQgcGF0aCBcInNlbGZcIiBpcyBwYXNzZWQgdGhlXG4gICAqIGRlY29yYXRvciBzbyB0aGUgZGVmYXVsdCB2YWx1ZSB3aWxsIG5vdCBiZSB1c2VkIChiZWNhdXNlIGJyb3dzZXJzIHRoYXQgZGVmaW5lXG4gICAqIGZldGNoIGFsc28gaGFzIFJlcXVlc3QpLiBPbmUgcXVpcmt5IHNldHVwIHdoZXJlIHNlbGYuZmV0Y2ggZXhpc3RzIGJ1dFxuICAgKiBzZWxmLlJlcXVlc3QgZG9lcyBub3QgaXMgd2hlbiB0aGUgXCJ1bmZldGNoXCIgbWluaW1hbCBmZXRjaCBwb2x5ZmlsbCBpcyB1c2VkXG4gICAqIG9uIHRvcCBvZiBJRTExOyBmb3IgdGhpcyBjYXNlIHRoZSBicm93c2VyIHdpbGwgdHJ5IHRvIHVzZSB0aGUgZmV0Y2guUmVxdWVzdFxuICAgKiBkZWZhdWx0IHZhbHVlIHdoaWNoIGluIHR1cm4gd2lsbCBiZSB1bmRlZmluZWQgYnV0IHRoZW4gdGhlbiBcImlmIChSZXF1ZXN0KVwiXG4gICAqIHdpbGwgZW5zdXJlIHRoYXQgeW91IGdldCBhIHBhdGNoZWQgZmV0Y2ggYnV0IHN0aWxsIG5vIFJlcXVlc3QgKGFzIGV4cGVjdGVkKS5cbiAgICogQHBhcmFtIHtmZXRjaCwgUmVxdWVzdCA9IGZldGNoLlJlcXVlc3R9XG4gICAqIEByZXR1cm5zIHtmZXRjaDogYWJvcnRhYmxlRmV0Y2gsIFJlcXVlc3Q6IEFib3J0YWJsZVJlcXVlc3R9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFib3J0YWJsZUZldGNoRGVjb3JhdG9yKHBhdGNoVGFyZ2V0cykge1xuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgcGF0Y2hUYXJnZXRzKSB7XG4gICAgICBwYXRjaFRhcmdldHMgPSB7XG4gICAgICAgIGZldGNoOiBwYXRjaFRhcmdldHNcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIF9wYXRjaFRhcmdldHMgPSBwYXRjaFRhcmdldHMsXG4gICAgICAgIGZldGNoID0gX3BhdGNoVGFyZ2V0cy5mZXRjaCxcbiAgICAgICAgX3BhdGNoVGFyZ2V0cyRSZXF1ZXN0ID0gX3BhdGNoVGFyZ2V0cy5SZXF1ZXN0LFxuICAgICAgICBOYXRpdmVSZXF1ZXN0ID0gX3BhdGNoVGFyZ2V0cyRSZXF1ZXN0ID09PSB2b2lkIDAgPyBmZXRjaC5SZXF1ZXN0IDogX3BhdGNoVGFyZ2V0cyRSZXF1ZXN0LFxuICAgICAgICBOYXRpdmVBYm9ydENvbnRyb2xsZXIgPSBfcGF0Y2hUYXJnZXRzLkFib3J0Q29udHJvbGxlcixcbiAgICAgICAgX3BhdGNoVGFyZ2V0cyRfX0ZPUkNFID0gX3BhdGNoVGFyZ2V0cy5fX0ZPUkNFX0lOU1RBTExfQUJPUlRDT05UUk9MTEVSX1BPTFlGSUxMLFxuICAgICAgICBfX0ZPUkNFX0lOU1RBTExfQUJPUlRDT05UUk9MTEVSX1BPTFlGSUxMID0gX3BhdGNoVGFyZ2V0cyRfX0ZPUkNFID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wYXRjaFRhcmdldHMkX19GT1JDRTtcblxuICAgIGlmICghcG9seWZpbGxOZWVkZWQoe1xuICAgICAgZmV0Y2g6IGZldGNoLFxuICAgICAgUmVxdWVzdDogTmF0aXZlUmVxdWVzdCxcbiAgICAgIEFib3J0Q29udHJvbGxlcjogTmF0aXZlQWJvcnRDb250cm9sbGVyLFxuICAgICAgX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTDogX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTFxuICAgIH0pKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmZXRjaDogZmV0Y2gsXG4gICAgICAgIFJlcXVlc3Q6IFJlcXVlc3RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIFJlcXVlc3QgPSBOYXRpdmVSZXF1ZXN0OyAvLyBOb3RlIHRoYXQgdGhlIFwidW5mZXRjaFwiIG1pbmltYWwgZmV0Y2ggcG9seWZpbGwgZGVmaW5lcyBmZXRjaCgpIHdpdGhvdXRcbiAgICAvLyBkZWZpbmluZyB3aW5kb3cuUmVxdWVzdCwgYW5kIHRoaXMgcG9seWZpbGwgbmVlZCB0byB3b3JrIG9uIHRvcCBvZiB1bmZldGNoXG4gICAgLy8gaGVuY2Ugd2Ugb25seSBwYXRjaCBpdCBpZiBpdCdzIGF2YWlsYWJsZS4gQWxzbyB3ZSBkb24ndCBwYXRjaCBpdCBpZiBzaWduYWxcbiAgICAvLyBpcyBhbHJlYWR5IGF2YWlsYWJsZSBvbiB0aGUgUmVxdWVzdCBwcm90b3R5cGUgYmVjYXVzZSBpbiB0aGlzIGNhc2Ugc3VwcG9ydFxuICAgIC8vIGlzIHByZXNlbnQgYW5kIHRoZSBwYXRjaGluZyBiZWxvdyBjYW4gY2F1c2UgYSBjcmFzaCBzaW5jZSBpdCBhc3NpZ25zIHRvXG4gICAgLy8gcmVxdWVzdC5zaWduYWwgd2hpY2ggaXMgdGVjaG5pY2FsbHkgYSByZWFkLW9ubHkgcHJvcGVydHkuIFRoaXMgbGF0dGVyIGVycm9yXG4gICAgLy8gaGFwcGVucyB3aGVuIHlvdSBydW4gdGhlIG1haW41LmpzIG5vZGUtZmV0Y2ggZXhhbXBsZSBpbiB0aGUgcmVwb1xuICAgIC8vIFwiYWJvcnRjb250cm9sbGVyLXBvbHlmaWxsLWV4YW1wbGVzXCIuIFRoZSBleGFjdCBlcnJvciBpczpcbiAgICAvLyAgIHJlcXVlc3Quc2lnbmFsID0gaW5pdC5zaWduYWw7XG4gICAgLy8gICBeXG4gICAgLy8gVHlwZUVycm9yOiBDYW5ub3Qgc2V0IHByb3BlcnR5IHNpZ25hbCBvZiAjPFJlcXVlc3Q+IHdoaWNoIGhhcyBvbmx5IGEgZ2V0dGVyXG5cbiAgICBpZiAoUmVxdWVzdCAmJiAhUmVxdWVzdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ3NpZ25hbCcpIHx8IF9fRk9SQ0VfSU5TVEFMTF9BQk9SVENPTlRST0xMRVJfUE9MWUZJTEwpIHtcbiAgICAgIFJlcXVlc3QgPSBmdW5jdGlvbiBSZXF1ZXN0KGlucHV0LCBpbml0KSB7XG4gICAgICAgIHZhciBzaWduYWw7XG5cbiAgICAgICAgaWYgKGluaXQgJiYgaW5pdC5zaWduYWwpIHtcbiAgICAgICAgICBzaWduYWwgPSBpbml0LnNpZ25hbDsgLy8gTmV2ZXIgcGFzcyBpbml0LnNpZ25hbCB0byB0aGUgbmF0aXZlIFJlcXVlc3QgaW1wbGVtZW50YXRpb24gd2hlbiB0aGUgcG9seWZpbGwgaGFzXG4gICAgICAgICAgLy8gYmVlbiBpbnN0YWxsZWQgYmVjYXVzZSBpZiB3ZSdyZSBydW5uaW5nIG9uIHRvcCBvZiBhIGJyb3dzZXIgd2l0aCBhXG4gICAgICAgICAgLy8gd29ya2luZyBuYXRpdmUgQWJvcnRDb250cm9sbGVyIChpLmUuIHRoZSBwb2x5ZmlsbCB3YXMgaW5zdGFsbGVkIGR1ZSB0b1xuICAgICAgICAgIC8vIF9fRk9SQ0VfSU5TVEFMTF9BQk9SVENPTlRST0xMRVJfUE9MWUZJTEwgYmVpbmcgc2V0KSwgdGhlbiBwYXNzaW5nIG91clxuICAgICAgICAgIC8vIGZha2UgQWJvcnRTaWduYWwgdG8gdGhlIG5hdGl2ZSBmZXRjaCB3aWxsIHRyaWdnZXI6XG4gICAgICAgICAgLy8gVHlwZUVycm9yOiBGYWlsZWQgdG8gY29uc3RydWN0ICdSZXF1ZXN0JzogbWVtYmVyIHNpZ25hbCBpcyBub3Qgb2YgdHlwZSBBYm9ydFNpZ25hbC5cblxuICAgICAgICAgIGRlbGV0ZSBpbml0LnNpZ25hbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXF1ZXN0ID0gbmV3IE5hdGl2ZVJlcXVlc3QoaW5wdXQsIGluaXQpO1xuXG4gICAgICAgIGlmIChzaWduYWwpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWVzdCwgJ3NpZ25hbCcsIHtcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHNpZ25hbFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgICB9O1xuXG4gICAgICBSZXF1ZXN0LnByb3RvdHlwZSA9IE5hdGl2ZVJlcXVlc3QucHJvdG90eXBlO1xuICAgIH1cblxuICAgIHZhciByZWFsRmV0Y2ggPSBmZXRjaDtcblxuICAgIHZhciBhYm9ydGFibGVGZXRjaCA9IGZ1bmN0aW9uIGFib3J0YWJsZUZldGNoKGlucHV0LCBpbml0KSB7XG4gICAgICB2YXIgc2lnbmFsID0gUmVxdWVzdCAmJiBSZXF1ZXN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGlucHV0KSA/IGlucHV0LnNpZ25hbCA6IGluaXQgPyBpbml0LnNpZ25hbCA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHNpZ25hbCkge1xuICAgICAgICB2YXIgYWJvcnRFcnJvcjtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGFib3J0RXJyb3IgPSBuZXcgRE9NRXhjZXB0aW9uKCdBYm9ydGVkJywgJ0Fib3J0RXJyb3InKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgLy8gSUUgMTEgZG9lcyBub3Qgc3VwcG9ydCBjYWxsaW5nIHRoZSBET01FeGNlcHRpb24gY29uc3RydWN0b3IsIHVzZSBhXG4gICAgICAgICAgLy8gcmVndWxhciBlcnJvciBvYmplY3Qgb24gaXQgaW5zdGVhZC5cbiAgICAgICAgICBhYm9ydEVycm9yID0gbmV3IEVycm9yKCdBYm9ydGVkJyk7XG4gICAgICAgICAgYWJvcnRFcnJvci5uYW1lID0gJ0Fib3J0RXJyb3InO1xuICAgICAgICB9IC8vIFJldHVybiBlYXJseSBpZiBhbHJlYWR5IGFib3J0ZWQsIHRodXMgYXZvaWRpbmcgbWFraW5nIGFuIEhUVFAgcmVxdWVzdFxuXG5cbiAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGFib3J0RXJyb3IpO1xuICAgICAgICB9IC8vIFR1cm4gYW4gZXZlbnQgaW50byBhIHByb21pc2UsIHJlamVjdCBpdCBvbmNlIGBhYm9ydGAgaXMgZGlzcGF0Y2hlZFxuXG5cbiAgICAgICAgdmFyIGNhbmNlbGxhdGlvbiA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChfLCByZWplY3QpIHtcbiAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KGFib3J0RXJyb3IpO1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGluaXQgJiYgaW5pdC5zaWduYWwpIHtcbiAgICAgICAgICAvLyBOZXZlciBwYXNzIC5zaWduYWwgdG8gdGhlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiB3aGVuIHRoZSBwb2x5ZmlsbCBoYXNcbiAgICAgICAgICAvLyBiZWVuIGluc3RhbGxlZCBiZWNhdXNlIGlmIHdlJ3JlIHJ1bm5pbmcgb24gdG9wIG9mIGEgYnJvd3NlciB3aXRoIGFcbiAgICAgICAgICAvLyB3b3JraW5nIG5hdGl2ZSBBYm9ydENvbnRyb2xsZXIgKGkuZS4gdGhlIHBvbHlmaWxsIHdhcyBpbnN0YWxsZWQgZHVlIHRvXG4gICAgICAgICAgLy8gX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTCBiZWluZyBzZXQpLCB0aGVuIHBhc3Npbmcgb3VyXG4gICAgICAgICAgLy8gZmFrZSBBYm9ydFNpZ25hbCB0byB0aGUgbmF0aXZlIGZldGNoIHdpbGwgdHJpZ2dlcjpcbiAgICAgICAgICAvLyBUeXBlRXJyb3I6IEZhaWxlZCB0byBleGVjdXRlICdmZXRjaCcgb24gJ1dpbmRvdyc6IG1lbWJlciBzaWduYWwgaXMgbm90IG9mIHR5cGUgQWJvcnRTaWduYWwuXG4gICAgICAgICAgZGVsZXRlIGluaXQuc2lnbmFsO1xuICAgICAgICB9IC8vIFJldHVybiB0aGUgZmFzdGVzdCBwcm9taXNlIChkb24ndCBuZWVkIHRvIHdhaXQgZm9yIHJlcXVlc3QgdG8gZmluaXNoKVxuXG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbY2FuY2VsbGF0aW9uLCByZWFsRmV0Y2goaW5wdXQsIGluaXQpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZWFsRmV0Y2goaW5wdXQsIGluaXQpO1xuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgZmV0Y2g6IGFib3J0YWJsZUZldGNoLFxuICAgICAgUmVxdWVzdDogUmVxdWVzdFxuICAgIH07XG4gIH1cblxuICAoZnVuY3Rpb24gKHNlbGYpIHtcblxuICAgIGlmICghcG9seWZpbGxOZWVkZWQoc2VsZikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXNlbGYuZmV0Y2gpIHtcbiAgICAgIGNvbnNvbGUud2FybignZmV0Y2goKSBpcyBub3QgYXZhaWxhYmxlLCBjYW5ub3QgaW5zdGFsbCBhYm9ydGNvbnRyb2xsZXItcG9seWZpbGwnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgX2Fib3J0YWJsZUZldGNoID0gYWJvcnRhYmxlRmV0Y2hEZWNvcmF0b3Ioc2VsZiksXG4gICAgICAgIGZldGNoID0gX2Fib3J0YWJsZUZldGNoLmZldGNoLFxuICAgICAgICBSZXF1ZXN0ID0gX2Fib3J0YWJsZUZldGNoLlJlcXVlc3Q7XG5cbiAgICBzZWxmLmZldGNoID0gZmV0Y2g7XG4gICAgc2VsZi5SZXF1ZXN0ID0gUmVxdWVzdDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgJ0Fib3J0Q29udHJvbGxlcicsIHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogQWJvcnRDb250cm9sbGVyXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsICdBYm9ydFNpZ25hbCcsIHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogQWJvcnRTaWduYWxcbiAgICB9KTtcbiAgfSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IGdsb2JhbCk7XG5cbn0pKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/abortcontroller-polyfill@1.7.5/node_modules/abortcontroller-polyfill/dist/polyfill-patch-fetch.js\n");

/***/ })

};
;