/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/minizlib@1.3.3";
exports.ids = ["vendor-chunks/minizlib@1.3.3"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/minizlib@1.3.3/node_modules/minizlib/constants.js":
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/minizlib@1.3.3/node_modules/minizlib/constants.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Update with any zlib constants that are added or changed in the future.\n// Node v6 didn't export this, so we just hard code the version and rely\n// on all the other hard-coded values from zlib v4736.  When node v6\n// support drops, we can just export the realZlibConstants object.\nconst realZlibConstants = (__webpack_require__(/*! zlib */ \"zlib\").constants) ||\n  /* istanbul ignore next */ { ZLIB_VERNUM: 4736 }\n\nmodule.exports = Object.freeze(Object.assign(Object.create(null), {\n  Z_NO_FLUSH: 0,\n  Z_PARTIAL_FLUSH: 1,\n  Z_SYNC_FLUSH: 2,\n  Z_FULL_FLUSH: 3,\n  Z_FINISH: 4,\n  Z_BLOCK: 5,\n  Z_OK: 0,\n  Z_STREAM_END: 1,\n  Z_NEED_DICT: 2,\n  Z_ERRNO: -1,\n  Z_STREAM_ERROR: -2,\n  Z_DATA_ERROR: -3,\n  Z_MEM_ERROR: -4,\n  Z_BUF_ERROR: -5,\n  Z_VERSION_ERROR: -6,\n  Z_NO_COMPRESSION: 0,\n  Z_BEST_SPEED: 1,\n  Z_BEST_COMPRESSION: 9,\n  Z_DEFAULT_COMPRESSION: -1,\n  Z_FILTERED: 1,\n  Z_HUFFMAN_ONLY: 2,\n  Z_RLE: 3,\n  Z_FIXED: 4,\n  Z_DEFAULT_STRATEGY: 0,\n  DEFLATE: 1,\n  INFLATE: 2,\n  GZIP: 3,\n  GUNZIP: 4,\n  DEFLATERAW: 5,\n  INFLATERAW: 6,\n  UNZIP: 7,\n  BROTLI_DECODE: 8,\n  BROTLI_ENCODE: 9,\n  Z_MIN_WINDOWBITS: 8,\n  Z_MAX_WINDOWBITS: 15,\n  Z_DEFAULT_WINDOWBITS: 15,\n  Z_MIN_CHUNK: 64,\n  Z_MAX_CHUNK: Infinity,\n  Z_DEFAULT_CHUNK: 16384,\n  Z_MIN_MEMLEVEL: 1,\n  Z_MAX_MEMLEVEL: 9,\n  Z_DEFAULT_MEMLEVEL: 8,\n  Z_MIN_LEVEL: -1,\n  Z_MAX_LEVEL: 9,\n  Z_DEFAULT_LEVEL: -1,\n  BROTLI_OPERATION_PROCESS: 0,\n  BROTLI_OPERATION_FLUSH: 1,\n  BROTLI_OPERATION_FINISH: 2,\n  BROTLI_OPERATION_EMIT_METADATA: 3,\n  BROTLI_MODE_GENERIC: 0,\n  BROTLI_MODE_TEXT: 1,\n  BROTLI_MODE_FONT: 2,\n  BROTLI_DEFAULT_MODE: 0,\n  BROTLI_MIN_QUALITY: 0,\n  BROTLI_MAX_QUALITY: 11,\n  BROTLI_DEFAULT_QUALITY: 11,\n  BROTLI_MIN_WINDOW_BITS: 10,\n  BROTLI_MAX_WINDOW_BITS: 24,\n  BROTLI_LARGE_MAX_WINDOW_BITS: 30,\n  BROTLI_DEFAULT_WINDOW: 22,\n  BROTLI_MIN_INPUT_BLOCK_BITS: 16,\n  BROTLI_MAX_INPUT_BLOCK_BITS: 24,\n  BROTLI_PARAM_MODE: 0,\n  BROTLI_PARAM_QUALITY: 1,\n  BROTLI_PARAM_LGWIN: 2,\n  BROTLI_PARAM_LGBLOCK: 3,\n  BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,\n  BROTLI_PARAM_SIZE_HINT: 5,\n  BROTLI_PARAM_LARGE_WINDOW: 6,\n  BROTLI_PARAM_NPOSTFIX: 7,\n  BROTLI_PARAM_NDIRECT: 8,\n  BROTLI_DECODER_RESULT_ERROR: 0,\n  BROTLI_DECODER_RESULT_SUCCESS: 1,\n  BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,\n  BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,\n  BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,\n  BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,\n  BROTLI_DECODER_NO_ERROR: 0,\n  BROTLI_DECODER_SUCCESS: 1,\n  BROTLI_DECODER_NEEDS_MORE_INPUT: 2,\n  BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,\n  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,\n  BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,\n  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,\n  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,\n  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,\n  BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,\n  BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,\n  BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,\n  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,\n  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,\n  BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,\n  BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,\n  BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,\n  BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,\n  BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,\n  BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,\n  BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,\n  BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,\n  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,\n  BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,\n  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,\n  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,\n  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,\n  BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,\n  BROTLI_DECODER_ERROR_UNREACHABLE: -31,\n}, realZlibConstants))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vbWluaXpsaWJAMS4zLjMvbm9kZV9tb2R1bGVzL21pbml6bGliL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtREFBeUI7QUFDbkQsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2tpY2tzdGFydC8uL25vZGVfbW9kdWxlcy8ucG5wbS9taW5pemxpYkAxLjMuMy9ub2RlX21vZHVsZXMvbWluaXpsaWIvY29uc3RhbnRzLmpzP2MyNDQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVXBkYXRlIHdpdGggYW55IHpsaWIgY29uc3RhbnRzIHRoYXQgYXJlIGFkZGVkIG9yIGNoYW5nZWQgaW4gdGhlIGZ1dHVyZS5cbi8vIE5vZGUgdjYgZGlkbid0IGV4cG9ydCB0aGlzLCBzbyB3ZSBqdXN0IGhhcmQgY29kZSB0aGUgdmVyc2lvbiBhbmQgcmVseVxuLy8gb24gYWxsIHRoZSBvdGhlciBoYXJkLWNvZGVkIHZhbHVlcyBmcm9tIHpsaWIgdjQ3MzYuICBXaGVuIG5vZGUgdjZcbi8vIHN1cHBvcnQgZHJvcHMsIHdlIGNhbiBqdXN0IGV4cG9ydCB0aGUgcmVhbFpsaWJDb25zdGFudHMgb2JqZWN0LlxuY29uc3QgcmVhbFpsaWJDb25zdGFudHMgPSByZXF1aXJlKCd6bGliJykuY29uc3RhbnRzIHx8XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHsgWkxJQl9WRVJOVU06IDQ3MzYgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5mcmVlemUoT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gIFpfTk9fRkxVU0g6IDAsXG4gIFpfUEFSVElBTF9GTFVTSDogMSxcbiAgWl9TWU5DX0ZMVVNIOiAyLFxuICBaX0ZVTExfRkxVU0g6IDMsXG4gIFpfRklOSVNIOiA0LFxuICBaX0JMT0NLOiA1LFxuICBaX09LOiAwLFxuICBaX1NUUkVBTV9FTkQ6IDEsXG4gIFpfTkVFRF9ESUNUOiAyLFxuICBaX0VSUk5POiAtMSxcbiAgWl9TVFJFQU1fRVJST1I6IC0yLFxuICBaX0RBVEFfRVJST1I6IC0zLFxuICBaX01FTV9FUlJPUjogLTQsXG4gIFpfQlVGX0VSUk9SOiAtNSxcbiAgWl9WRVJTSU9OX0VSUk9SOiAtNixcbiAgWl9OT19DT01QUkVTU0lPTjogMCxcbiAgWl9CRVNUX1NQRUVEOiAxLFxuICBaX0JFU1RfQ09NUFJFU1NJT046IDksXG4gIFpfREVGQVVMVF9DT01QUkVTU0lPTjogLTEsXG4gIFpfRklMVEVSRUQ6IDEsXG4gIFpfSFVGRk1BTl9PTkxZOiAyLFxuICBaX1JMRTogMyxcbiAgWl9GSVhFRDogNCxcbiAgWl9ERUZBVUxUX1NUUkFURUdZOiAwLFxuICBERUZMQVRFOiAxLFxuICBJTkZMQVRFOiAyLFxuICBHWklQOiAzLFxuICBHVU5aSVA6IDQsXG4gIERFRkxBVEVSQVc6IDUsXG4gIElORkxBVEVSQVc6IDYsXG4gIFVOWklQOiA3LFxuICBCUk9UTElfREVDT0RFOiA4LFxuICBCUk9UTElfRU5DT0RFOiA5LFxuICBaX01JTl9XSU5ET1dCSVRTOiA4LFxuICBaX01BWF9XSU5ET1dCSVRTOiAxNSxcbiAgWl9ERUZBVUxUX1dJTkRPV0JJVFM6IDE1LFxuICBaX01JTl9DSFVOSzogNjQsXG4gIFpfTUFYX0NIVU5LOiBJbmZpbml0eSxcbiAgWl9ERUZBVUxUX0NIVU5LOiAxNjM4NCxcbiAgWl9NSU5fTUVNTEVWRUw6IDEsXG4gIFpfTUFYX01FTUxFVkVMOiA5LFxuICBaX0RFRkFVTFRfTUVNTEVWRUw6IDgsXG4gIFpfTUlOX0xFVkVMOiAtMSxcbiAgWl9NQVhfTEVWRUw6IDksXG4gIFpfREVGQVVMVF9MRVZFTDogLTEsXG4gIEJST1RMSV9PUEVSQVRJT05fUFJPQ0VTUzogMCxcbiAgQlJPVExJX09QRVJBVElPTl9GTFVTSDogMSxcbiAgQlJPVExJX09QRVJBVElPTl9GSU5JU0g6IDIsXG4gIEJST1RMSV9PUEVSQVRJT05fRU1JVF9NRVRBREFUQTogMyxcbiAgQlJPVExJX01PREVfR0VORVJJQzogMCxcbiAgQlJPVExJX01PREVfVEVYVDogMSxcbiAgQlJPVExJX01PREVfRk9OVDogMixcbiAgQlJPVExJX0RFRkFVTFRfTU9ERTogMCxcbiAgQlJPVExJX01JTl9RVUFMSVRZOiAwLFxuICBCUk9UTElfTUFYX1FVQUxJVFk6IDExLFxuICBCUk9UTElfREVGQVVMVF9RVUFMSVRZOiAxMSxcbiAgQlJPVExJX01JTl9XSU5ET1dfQklUUzogMTAsXG4gIEJST1RMSV9NQVhfV0lORE9XX0JJVFM6IDI0LFxuICBCUk9UTElfTEFSR0VfTUFYX1dJTkRPV19CSVRTOiAzMCxcbiAgQlJPVExJX0RFRkFVTFRfV0lORE9XOiAyMixcbiAgQlJPVExJX01JTl9JTlBVVF9CTE9DS19CSVRTOiAxNixcbiAgQlJPVExJX01BWF9JTlBVVF9CTE9DS19CSVRTOiAyNCxcbiAgQlJPVExJX1BBUkFNX01PREU6IDAsXG4gIEJST1RMSV9QQVJBTV9RVUFMSVRZOiAxLFxuICBCUk9UTElfUEFSQU1fTEdXSU46IDIsXG4gIEJST1RMSV9QQVJBTV9MR0JMT0NLOiAzLFxuICBCUk9UTElfUEFSQU1fRElTQUJMRV9MSVRFUkFMX0NPTlRFWFRfTU9ERUxJTkc6IDQsXG4gIEJST1RMSV9QQVJBTV9TSVpFX0hJTlQ6IDUsXG4gIEJST1RMSV9QQVJBTV9MQVJHRV9XSU5ET1c6IDYsXG4gIEJST1RMSV9QQVJBTV9OUE9TVEZJWDogNyxcbiAgQlJPVExJX1BBUkFNX05ESVJFQ1Q6IDgsXG4gIEJST1RMSV9ERUNPREVSX1JFU1VMVF9FUlJPUjogMCxcbiAgQlJPVExJX0RFQ09ERVJfUkVTVUxUX1NVQ0NFU1M6IDEsXG4gIEJST1RMSV9ERUNPREVSX1JFU1VMVF9ORUVEU19NT1JFX0lOUFVUOiAyLFxuICBCUk9UTElfREVDT0RFUl9SRVNVTFRfTkVFRFNfTU9SRV9PVVRQVVQ6IDMsXG4gIEJST1RMSV9ERUNPREVSX1BBUkFNX0RJU0FCTEVfUklOR19CVUZGRVJfUkVBTExPQ0FUSU9OOiAwLFxuICBCUk9UTElfREVDT0RFUl9QQVJBTV9MQVJHRV9XSU5ET1c6IDEsXG4gIEJST1RMSV9ERUNPREVSX05PX0VSUk9SOiAwLFxuICBCUk9UTElfREVDT0RFUl9TVUNDRVNTOiAxLFxuICBCUk9UTElfREVDT0RFUl9ORUVEU19NT1JFX0lOUFVUOiAyLFxuICBCUk9UTElfREVDT0RFUl9ORUVEU19NT1JFX09VVFBVVDogMyxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX0VYVUJFUkFOVF9OSUJCTEU6IC0xLFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfUkVTRVJWRUQ6IC0yLFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfRVhVQkVSQU5UX01FVEFfTklCQkxFOiAtMyxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX1NJTVBMRV9IVUZGTUFOX0FMUEhBQkVUOiAtNCxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX1NJTVBMRV9IVUZGTUFOX1NBTUU6IC01LFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfQ0xfU1BBQ0U6IC02LFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfSFVGRk1BTl9TUEFDRTogLTcsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9DT05URVhUX01BUF9SRVBFQVQ6IC04LFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfQkxPQ0tfTEVOR1RIXzE6IC05LFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfQkxPQ0tfTEVOR1RIXzI6IC0xMCxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX1RSQU5TRk9STTogLTExLFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfRElDVElPTkFSWTogLTEyLFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfV0lORE9XX0JJVFM6IC0xMyxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX1BBRERJTkdfMTogLTE0LFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfUEFERElOR18yOiAtMTUsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9ESVNUQU5DRTogLTE2LFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9ESUNUSU9OQVJZX05PVF9TRVQ6IC0xOSxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfSU5WQUxJRF9BUkdVTUVOVFM6IC0yMCxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfQUxMT0NfQ09OVEVYVF9NT0RFUzogLTIxLFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9BTExPQ19UUkVFX0dST1VQUzogLTIyLFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9BTExPQ19DT05URVhUX01BUDogLTI1LFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9BTExPQ19SSU5HX0JVRkZFUl8xOiAtMjYsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0FMTE9DX1JJTkdfQlVGRkVSXzI6IC0yNyxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfQUxMT0NfQkxPQ0tfVFlQRV9UUkVFUzogLTMwLFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9VTlJFQUNIQUJMRTogLTMxLFxufSwgcmVhbFpsaWJDb25zdGFudHMpKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/minizlib@1.3.3/node_modules/minizlib/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/minizlib@1.3.3/node_modules/minizlib/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/.pnpm/minizlib@1.3.3/node_modules/minizlib/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst Buffer = (__webpack_require__(/*! buffer */ \"buffer\").Buffer)\nconst realZlib = __webpack_require__(/*! zlib */ \"zlib\")\n\nconst constants = exports.constants = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/.pnpm/minizlib@1.3.3/node_modules/minizlib/constants.js\")\nconst Minipass = __webpack_require__(/*! minipass */ \"(ssr)/./node_modules/.pnpm/minipass@2.9.0/node_modules/minipass/index.js\")\n\nconst OriginalBufferConcat = Buffer.concat\n\nclass ZlibError extends Error {\n  constructor (err) {\n    super('zlib: ' + err.message)\n    this.code = err.code\n    this.errno = err.errno\n    /* istanbul ignore if */\n    if (!this.code)\n      this.code = 'ZLIB_ERROR'\n\n    this.message = 'zlib: ' + err.message\n    Error.captureStackTrace(this, this.constructor)\n  }\n\n  get name () {\n    return 'ZlibError'\n  }\n}\n\n// the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\nconst _opts = Symbol('opts')\nconst _flushFlag = Symbol('flushFlag')\nconst _finishFlushFlag = Symbol('finishFlushFlag')\nconst _fullFlushFlag = Symbol('fullFlushFlag')\nconst _handle = Symbol('handle')\nconst _onError = Symbol('onError')\nconst _sawError = Symbol('sawError')\nconst _level = Symbol('level')\nconst _strategy = Symbol('strategy')\nconst _ended = Symbol('ended')\nconst _defaultFullFlush = Symbol('_defaultFullFlush')\n\nclass ZlibBase extends Minipass {\n  constructor (opts, mode) {\n    if (!opts || typeof opts !== 'object')\n      throw new TypeError('invalid options for ZlibBase constructor')\n\n    super(opts)\n    this[_ended] = false\n    this[_opts] = opts\n\n    this[_flushFlag] = opts.flush\n    this[_finishFlushFlag] = opts.finishFlush\n    // this will throw if any options are invalid for the class selected\n    try {\n      this[_handle] = new realZlib[mode](opts)\n    } catch (er) {\n      // make sure that all errors get decorated properly\n      throw new ZlibError(er)\n    }\n\n    this[_onError] = (err) => {\n      this[_sawError] = true\n      // there is no way to cleanly recover.\n      // continuing only obscures problems.\n      this.close()\n      this.emit('error', err)\n    }\n\n    this[_handle].on('error', er => this[_onError](new ZlibError(er)))\n    this.once('end', () => this.close)\n  }\n\n  close () {\n    if (this[_handle]) {\n      this[_handle].close()\n      this[_handle] = null\n      this.emit('close')\n    }\n  }\n\n  reset () {\n    if (!this[_sawError]) {\n      assert(this[_handle], 'zlib binding closed')\n      return this[_handle].reset()\n    }\n  }\n\n  flush (flushFlag) {\n    if (this.ended)\n      return\n\n    if (typeof flushFlag !== 'number')\n      flushFlag = this[_fullFlushFlag]\n    this.write(Object.assign(Buffer.alloc(0), { [_flushFlag]: flushFlag }))\n  }\n\n  end (chunk, encoding, cb) {\n    if (chunk)\n      this.write(chunk, encoding)\n    this.flush(this[_finishFlushFlag])\n    this[_ended] = true\n    return super.end(null, null, cb)\n  }\n\n  get ended () {\n    return this[_ended]\n  }\n\n  write (chunk, encoding, cb) {\n    // process the chunk using the sync process\n    // then super.write() all the outputted chunks\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (typeof chunk === 'string')\n      chunk = Buffer.from(chunk, encoding)\n\n    if (this[_sawError])\n      return\n    assert(this[_handle], 'zlib binding closed')\n\n    // _processChunk tries to .close() the native handle after it's done, so we\n    // intercept that by temporarily making it a no-op.\n    const nativeHandle = this[_handle]._handle\n    const originalNativeClose = nativeHandle.close\n    nativeHandle.close = () => {}\n    const originalClose = this[_handle].close\n    this[_handle].close = () => {}\n    // It also calls `Buffer.concat()` at the end, which may be convenient\n    // for some, but which we are not interested in as it slows us down.\n    Buffer.concat = (args) => args\n    let result\n    try {\n      const flushFlag = typeof chunk[_flushFlag] === 'number'\n        ? chunk[_flushFlag] : this[_flushFlag]\n      result = this[_handle]._processChunk(chunk, flushFlag)\n      // if we don't throw, reset it back how it was\n      Buffer.concat = OriginalBufferConcat\n    } catch (err) {\n      // or if we do, put Buffer.concat() back before we emit error\n      // Error events call into user code, which may call Buffer.concat()\n      Buffer.concat = OriginalBufferConcat\n      this[_onError](new ZlibError(err))\n    } finally {\n      if (this[_handle]) {\n        // Core zlib resets `_handle` to null after attempting to close the\n        // native handle. Our no-op handler prevented actual closure, but we\n        // need to restore the `._handle` property.\n        this[_handle]._handle = nativeHandle\n        nativeHandle.close = originalNativeClose\n        this[_handle].close = originalClose\n        // `_processChunk()` adds an 'error' listener. If we don't remove it\n        // after each call, these handlers start piling up.\n        this[_handle].removeAllListeners('error')\n      }\n    }\n\n    let writeReturn\n    if (result) {\n      if (Array.isArray(result) && result.length > 0) {\n        // The first buffer is always `handle._outBuffer`, which would be\n        // re-used for later invocations; so, we always have to copy that one.\n        writeReturn = super.write(Buffer.from(result[0]))\n        for (let i = 1; i < result.length; i++) {\n          writeReturn = super.write(result[i])\n        }\n      } else {\n        writeReturn = super.write(Buffer.from(result))\n      }\n    }\n\n    if (cb)\n      cb()\n    return writeReturn\n  }\n}\n\nclass Zlib extends ZlibBase {\n  constructor (opts, mode) {\n    opts = opts || {}\n\n    opts.flush = opts.flush || constants.Z_NO_FLUSH\n    opts.finishFlush = opts.finishFlush || constants.Z_FINISH\n    super(opts, mode)\n\n    this[_fullFlushFlag] = constants.Z_FULL_FLUSH\n    this[_level] = opts.level\n    this[_strategy] = opts.strategy\n  }\n\n  params (level, strategy) {\n    if (this[_sawError])\n      return\n\n    if (!this[_handle])\n      throw new Error('cannot switch params when binding is closed')\n\n    // no way to test this without also not supporting params at all\n    /* istanbul ignore if */\n    if (!this[_handle].params)\n      throw new Error('not supported in this implementation')\n\n    if (this[_level] !== level || this[_strategy] !== strategy) {\n      this.flush(constants.Z_SYNC_FLUSH)\n      assert(this[_handle], 'zlib binding closed')\n      // .params() calls .flush(), but the latter is always async in the\n      // core zlib. We override .flush() temporarily to intercept that and\n      // flush synchronously.\n      const origFlush = this[_handle].flush\n      this[_handle].flush = (flushFlag, cb) => {\n        this.flush(flushFlag)\n        cb()\n      }\n      try {\n        this[_handle].params(level, strategy)\n      } finally {\n        this[_handle].flush = origFlush\n      }\n      /* istanbul ignore else */\n      if (this[_handle]) {\n        this[_level] = level\n        this[_strategy] = strategy\n      }\n    }\n  }\n}\n\n// minimal 2-byte header\nclass Deflate extends Zlib {\n  constructor (opts) {\n    super(opts, 'Deflate')\n  }\n}\n\nclass Inflate extends Zlib {\n  constructor (opts) {\n    super(opts, 'Inflate')\n  }\n}\n\n// gzip - bigger header, same deflate compression\nclass Gzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Gzip')\n  }\n}\n\nclass Gunzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Gunzip')\n  }\n}\n\n// raw - no header\nclass DeflateRaw extends Zlib {\n  constructor (opts) {\n    super(opts, 'DeflateRaw')\n  }\n}\n\nclass InflateRaw extends Zlib {\n  constructor (opts) {\n    super(opts, 'InflateRaw')\n  }\n}\n\n// auto-detect header.\nclass Unzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Unzip')\n  }\n}\n\nclass Brotli extends ZlibBase {\n  constructor (opts, mode) {\n    opts = opts || {}\n\n    opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS\n    opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH\n\n    super(opts, mode)\n\n    this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH\n  }\n}\n\nclass BrotliCompress extends Brotli {\n  constructor (opts) {\n    super(opts, 'BrotliCompress')\n  }\n}\n\nclass BrotliDecompress extends Brotli {\n  constructor (opts) {\n    super(opts, 'BrotliDecompress')\n  }\n}\n\nexports.Deflate = Deflate\nexports.Inflate = Inflate\nexports.Gzip = Gzip\nexports.Gunzip = Gunzip\nexports.DeflateRaw = DeflateRaw\nexports.InflateRaw = InflateRaw\nexports.Unzip = Unzip\n/* istanbul ignore else */\nif (typeof realZlib.BrotliCompress === 'function') {\n  exports.BrotliCompress = BrotliCompress\n  exports.BrotliDecompress = BrotliDecompress\n} else {\n  exports.BrotliCompress = exports.BrotliDecompress = class {\n    constructor () {\n      throw new Error('Brotli is not supported in this version of Node.js')\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vbWluaXpsaWJAMS4zLjMvbm9kZV9tb2R1bGVzL21pbml6bGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixlQUFlLG9EQUF3QjtBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFL0Isa0JBQWtCLDZJQUE2QztBQUMvRCxpQkFBaUIsbUJBQU8sQ0FBQywwRkFBVTs7QUFFbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELHlCQUF5QjtBQUN6RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7QUFDZixlQUFlO0FBQ2YsWUFBWTtBQUNaLGNBQWM7QUFDZCxrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsRUFBRSxzQkFBc0I7QUFDeEIsRUFBRSx3QkFBd0I7QUFDMUIsRUFBRTtBQUNGLEVBQUUsc0JBQXNCLEdBQUcsd0JBQXdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9raWNrc3RhcnQvLi9ub2RlX21vZHVsZXMvLnBucG0vbWluaXpsaWJAMS4zLjMvbm9kZV9tb2R1bGVzL21pbml6bGliL2luZGV4LmpzPzg1ZWMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5jb25zdCBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXJcbmNvbnN0IHJlYWxabGliID0gcmVxdWlyZSgnemxpYicpXG5cbmNvbnN0IGNvbnN0YW50cyA9IGV4cG9ydHMuY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMuanMnKVxuY29uc3QgTWluaXBhc3MgPSByZXF1aXJlKCdtaW5pcGFzcycpXG5cbmNvbnN0IE9yaWdpbmFsQnVmZmVyQ29uY2F0ID0gQnVmZmVyLmNvbmNhdFxuXG5jbGFzcyBabGliRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChlcnIpIHtcbiAgICBzdXBlcignemxpYjogJyArIGVyci5tZXNzYWdlKVxuICAgIHRoaXMuY29kZSA9IGVyci5jb2RlXG4gICAgdGhpcy5lcnJubyA9IGVyci5lcnJub1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghdGhpcy5jb2RlKVxuICAgICAgdGhpcy5jb2RlID0gJ1pMSUJfRVJST1InXG5cbiAgICB0aGlzLm1lc3NhZ2UgPSAnemxpYjogJyArIGVyci5tZXNzYWdlXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3RvcilcbiAgfVxuXG4gIGdldCBuYW1lICgpIHtcbiAgICByZXR1cm4gJ1psaWJFcnJvcidcbiAgfVxufVxuXG4vLyB0aGUgWmxpYiBjbGFzcyB0aGV5IGFsbCBpbmhlcml0IGZyb21cbi8vIFRoaXMgdGhpbmcgbWFuYWdlcyB0aGUgcXVldWUgb2YgcmVxdWVzdHMsIGFuZCByZXR1cm5zXG4vLyB0cnVlIG9yIGZhbHNlIGlmIHRoZXJlIGlzIGFueXRoaW5nIGluIHRoZSBxdWV1ZSB3aGVuXG4vLyB5b3UgY2FsbCB0aGUgLndyaXRlKCkgbWV0aG9kLlxuY29uc3QgX29wdHMgPSBTeW1ib2woJ29wdHMnKVxuY29uc3QgX2ZsdXNoRmxhZyA9IFN5bWJvbCgnZmx1c2hGbGFnJylcbmNvbnN0IF9maW5pc2hGbHVzaEZsYWcgPSBTeW1ib2woJ2ZpbmlzaEZsdXNoRmxhZycpXG5jb25zdCBfZnVsbEZsdXNoRmxhZyA9IFN5bWJvbCgnZnVsbEZsdXNoRmxhZycpXG5jb25zdCBfaGFuZGxlID0gU3ltYm9sKCdoYW5kbGUnKVxuY29uc3QgX29uRXJyb3IgPSBTeW1ib2woJ29uRXJyb3InKVxuY29uc3QgX3Nhd0Vycm9yID0gU3ltYm9sKCdzYXdFcnJvcicpXG5jb25zdCBfbGV2ZWwgPSBTeW1ib2woJ2xldmVsJylcbmNvbnN0IF9zdHJhdGVneSA9IFN5bWJvbCgnc3RyYXRlZ3knKVxuY29uc3QgX2VuZGVkID0gU3ltYm9sKCdlbmRlZCcpXG5jb25zdCBfZGVmYXVsdEZ1bGxGbHVzaCA9IFN5bWJvbCgnX2RlZmF1bHRGdWxsRmx1c2gnKVxuXG5jbGFzcyBabGliQmFzZSBleHRlbmRzIE1pbmlwYXNzIHtcbiAgY29uc3RydWN0b3IgKG9wdHMsIG1vZGUpIHtcbiAgICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBvcHRpb25zIGZvciBabGliQmFzZSBjb25zdHJ1Y3RvcicpXG5cbiAgICBzdXBlcihvcHRzKVxuICAgIHRoaXNbX2VuZGVkXSA9IGZhbHNlXG4gICAgdGhpc1tfb3B0c10gPSBvcHRzXG5cbiAgICB0aGlzW19mbHVzaEZsYWddID0gb3B0cy5mbHVzaFxuICAgIHRoaXNbX2ZpbmlzaEZsdXNoRmxhZ10gPSBvcHRzLmZpbmlzaEZsdXNoXG4gICAgLy8gdGhpcyB3aWxsIHRocm93IGlmIGFueSBvcHRpb25zIGFyZSBpbnZhbGlkIGZvciB0aGUgY2xhc3Mgc2VsZWN0ZWRcbiAgICB0cnkge1xuICAgICAgdGhpc1tfaGFuZGxlXSA9IG5ldyByZWFsWmxpYlttb2RlXShvcHRzKVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgdGhhdCBhbGwgZXJyb3JzIGdldCBkZWNvcmF0ZWQgcHJvcGVybHlcbiAgICAgIHRocm93IG5ldyBabGliRXJyb3IoZXIpXG4gICAgfVxuXG4gICAgdGhpc1tfb25FcnJvcl0gPSAoZXJyKSA9PiB7XG4gICAgICB0aGlzW19zYXdFcnJvcl0gPSB0cnVlXG4gICAgICAvLyB0aGVyZSBpcyBubyB3YXkgdG8gY2xlYW5seSByZWNvdmVyLlxuICAgICAgLy8gY29udGludWluZyBvbmx5IG9ic2N1cmVzIHByb2JsZW1zLlxuICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgIH1cblxuICAgIHRoaXNbX2hhbmRsZV0ub24oJ2Vycm9yJywgZXIgPT4gdGhpc1tfb25FcnJvcl0obmV3IFpsaWJFcnJvcihlcikpKVxuICAgIHRoaXMub25jZSgnZW5kJywgKCkgPT4gdGhpcy5jbG9zZSlcbiAgfVxuXG4gIGNsb3NlICgpIHtcbiAgICBpZiAodGhpc1tfaGFuZGxlXSkge1xuICAgICAgdGhpc1tfaGFuZGxlXS5jbG9zZSgpXG4gICAgICB0aGlzW19oYW5kbGVdID0gbnVsbFxuICAgICAgdGhpcy5lbWl0KCdjbG9zZScpXG4gICAgfVxuICB9XG5cbiAgcmVzZXQgKCkge1xuICAgIGlmICghdGhpc1tfc2F3RXJyb3JdKSB7XG4gICAgICBhc3NlcnQodGhpc1tfaGFuZGxlXSwgJ3psaWIgYmluZGluZyBjbG9zZWQnKVxuICAgICAgcmV0dXJuIHRoaXNbX2hhbmRsZV0ucmVzZXQoKVxuICAgIH1cbiAgfVxuXG4gIGZsdXNoIChmbHVzaEZsYWcpIHtcbiAgICBpZiAodGhpcy5lbmRlZClcbiAgICAgIHJldHVyblxuXG4gICAgaWYgKHR5cGVvZiBmbHVzaEZsYWcgIT09ICdudW1iZXInKVxuICAgICAgZmx1c2hGbGFnID0gdGhpc1tfZnVsbEZsdXNoRmxhZ11cbiAgICB0aGlzLndyaXRlKE9iamVjdC5hc3NpZ24oQnVmZmVyLmFsbG9jKDApLCB7IFtfZmx1c2hGbGFnXTogZmx1c2hGbGFnIH0pKVxuICB9XG5cbiAgZW5kIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgaWYgKGNodW5rKVxuICAgICAgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpXG4gICAgdGhpcy5mbHVzaCh0aGlzW19maW5pc2hGbHVzaEZsYWddKVxuICAgIHRoaXNbX2VuZGVkXSA9IHRydWVcbiAgICByZXR1cm4gc3VwZXIuZW5kKG51bGwsIG51bGwsIGNiKVxuICB9XG5cbiAgZ2V0IGVuZGVkICgpIHtcbiAgICByZXR1cm4gdGhpc1tfZW5kZWRdXG4gIH1cblxuICB3cml0ZSAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIC8vIHByb2Nlc3MgdGhlIGNodW5rIHVzaW5nIHRoZSBzeW5jIHByb2Nlc3NcbiAgICAvLyB0aGVuIHN1cGVyLndyaXRlKCkgYWxsIHRoZSBvdXRwdXR0ZWQgY2h1bmtzXG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNiID0gZW5jb2RpbmcsIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJylcbiAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKVxuXG4gICAgaWYgKHRoaXNbX3Nhd0Vycm9yXSlcbiAgICAgIHJldHVyblxuICAgIGFzc2VydCh0aGlzW19oYW5kbGVdLCAnemxpYiBiaW5kaW5nIGNsb3NlZCcpXG5cbiAgICAvLyBfcHJvY2Vzc0NodW5rIHRyaWVzIHRvIC5jbG9zZSgpIHRoZSBuYXRpdmUgaGFuZGxlIGFmdGVyIGl0J3MgZG9uZSwgc28gd2VcbiAgICAvLyBpbnRlcmNlcHQgdGhhdCBieSB0ZW1wb3JhcmlseSBtYWtpbmcgaXQgYSBuby1vcC5cbiAgICBjb25zdCBuYXRpdmVIYW5kbGUgPSB0aGlzW19oYW5kbGVdLl9oYW5kbGVcbiAgICBjb25zdCBvcmlnaW5hbE5hdGl2ZUNsb3NlID0gbmF0aXZlSGFuZGxlLmNsb3NlXG4gICAgbmF0aXZlSGFuZGxlLmNsb3NlID0gKCkgPT4ge31cbiAgICBjb25zdCBvcmlnaW5hbENsb3NlID0gdGhpc1tfaGFuZGxlXS5jbG9zZVxuICAgIHRoaXNbX2hhbmRsZV0uY2xvc2UgPSAoKSA9PiB7fVxuICAgIC8vIEl0IGFsc28gY2FsbHMgYEJ1ZmZlci5jb25jYXQoKWAgYXQgdGhlIGVuZCwgd2hpY2ggbWF5IGJlIGNvbnZlbmllbnRcbiAgICAvLyBmb3Igc29tZSwgYnV0IHdoaWNoIHdlIGFyZSBub3QgaW50ZXJlc3RlZCBpbiBhcyBpdCBzbG93cyB1cyBkb3duLlxuICAgIEJ1ZmZlci5jb25jYXQgPSAoYXJncykgPT4gYXJnc1xuICAgIGxldCByZXN1bHRcbiAgICB0cnkge1xuICAgICAgY29uc3QgZmx1c2hGbGFnID0gdHlwZW9mIGNodW5rW19mbHVzaEZsYWddID09PSAnbnVtYmVyJ1xuICAgICAgICA/IGNodW5rW19mbHVzaEZsYWddIDogdGhpc1tfZmx1c2hGbGFnXVxuICAgICAgcmVzdWx0ID0gdGhpc1tfaGFuZGxlXS5fcHJvY2Vzc0NodW5rKGNodW5rLCBmbHVzaEZsYWcpXG4gICAgICAvLyBpZiB3ZSBkb24ndCB0aHJvdywgcmVzZXQgaXQgYmFjayBob3cgaXQgd2FzXG4gICAgICBCdWZmZXIuY29uY2F0ID0gT3JpZ2luYWxCdWZmZXJDb25jYXRcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIG9yIGlmIHdlIGRvLCBwdXQgQnVmZmVyLmNvbmNhdCgpIGJhY2sgYmVmb3JlIHdlIGVtaXQgZXJyb3JcbiAgICAgIC8vIEVycm9yIGV2ZW50cyBjYWxsIGludG8gdXNlciBjb2RlLCB3aGljaCBtYXkgY2FsbCBCdWZmZXIuY29uY2F0KClcbiAgICAgIEJ1ZmZlci5jb25jYXQgPSBPcmlnaW5hbEJ1ZmZlckNvbmNhdFxuICAgICAgdGhpc1tfb25FcnJvcl0obmV3IFpsaWJFcnJvcihlcnIpKVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAodGhpc1tfaGFuZGxlXSkge1xuICAgICAgICAvLyBDb3JlIHpsaWIgcmVzZXRzIGBfaGFuZGxlYCB0byBudWxsIGFmdGVyIGF0dGVtcHRpbmcgdG8gY2xvc2UgdGhlXG4gICAgICAgIC8vIG5hdGl2ZSBoYW5kbGUuIE91ciBuby1vcCBoYW5kbGVyIHByZXZlbnRlZCBhY3R1YWwgY2xvc3VyZSwgYnV0IHdlXG4gICAgICAgIC8vIG5lZWQgdG8gcmVzdG9yZSB0aGUgYC5faGFuZGxlYCBwcm9wZXJ0eS5cbiAgICAgICAgdGhpc1tfaGFuZGxlXS5faGFuZGxlID0gbmF0aXZlSGFuZGxlXG4gICAgICAgIG5hdGl2ZUhhbmRsZS5jbG9zZSA9IG9yaWdpbmFsTmF0aXZlQ2xvc2VcbiAgICAgICAgdGhpc1tfaGFuZGxlXS5jbG9zZSA9IG9yaWdpbmFsQ2xvc2VcbiAgICAgICAgLy8gYF9wcm9jZXNzQ2h1bmsoKWAgYWRkcyBhbiAnZXJyb3InIGxpc3RlbmVyLiBJZiB3ZSBkb24ndCByZW1vdmUgaXRcbiAgICAgICAgLy8gYWZ0ZXIgZWFjaCBjYWxsLCB0aGVzZSBoYW5kbGVycyBzdGFydCBwaWxpbmcgdXAuXG4gICAgICAgIHRoaXNbX2hhbmRsZV0ucmVtb3ZlQWxsTGlzdGVuZXJzKCdlcnJvcicpXG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHdyaXRlUmV0dXJuXG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSAmJiByZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBUaGUgZmlyc3QgYnVmZmVyIGlzIGFsd2F5cyBgaGFuZGxlLl9vdXRCdWZmZXJgLCB3aGljaCB3b3VsZCBiZVxuICAgICAgICAvLyByZS11c2VkIGZvciBsYXRlciBpbnZvY2F0aW9uczsgc28sIHdlIGFsd2F5cyBoYXZlIHRvIGNvcHkgdGhhdCBvbmUuXG4gICAgICAgIHdyaXRlUmV0dXJuID0gc3VwZXIud3JpdGUoQnVmZmVyLmZyb20ocmVzdWx0WzBdKSlcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB3cml0ZVJldHVybiA9IHN1cGVyLndyaXRlKHJlc3VsdFtpXSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVSZXR1cm4gPSBzdXBlci53cml0ZShCdWZmZXIuZnJvbShyZXN1bHQpKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjYilcbiAgICAgIGNiKClcbiAgICByZXR1cm4gd3JpdGVSZXR1cm5cbiAgfVxufVxuXG5jbGFzcyBabGliIGV4dGVuZHMgWmxpYkJhc2Uge1xuICBjb25zdHJ1Y3RvciAob3B0cywgbW9kZSkge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgICBvcHRzLmZsdXNoID0gb3B0cy5mbHVzaCB8fCBjb25zdGFudHMuWl9OT19GTFVTSFxuICAgIG9wdHMuZmluaXNoRmx1c2ggPSBvcHRzLmZpbmlzaEZsdXNoIHx8IGNvbnN0YW50cy5aX0ZJTklTSFxuICAgIHN1cGVyKG9wdHMsIG1vZGUpXG5cbiAgICB0aGlzW19mdWxsRmx1c2hGbGFnXSA9IGNvbnN0YW50cy5aX0ZVTExfRkxVU0hcbiAgICB0aGlzW19sZXZlbF0gPSBvcHRzLmxldmVsXG4gICAgdGhpc1tfc3RyYXRlZ3ldID0gb3B0cy5zdHJhdGVneVxuICB9XG5cbiAgcGFyYW1zIChsZXZlbCwgc3RyYXRlZ3kpIHtcbiAgICBpZiAodGhpc1tfc2F3RXJyb3JdKVxuICAgICAgcmV0dXJuXG5cbiAgICBpZiAoIXRoaXNbX2hhbmRsZV0pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBzd2l0Y2ggcGFyYW1zIHdoZW4gYmluZGluZyBpcyBjbG9zZWQnKVxuXG4gICAgLy8gbm8gd2F5IHRvIHRlc3QgdGhpcyB3aXRob3V0IGFsc28gbm90IHN1cHBvcnRpbmcgcGFyYW1zIGF0IGFsbFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghdGhpc1tfaGFuZGxlXS5wYXJhbXMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBzdXBwb3J0ZWQgaW4gdGhpcyBpbXBsZW1lbnRhdGlvbicpXG5cbiAgICBpZiAodGhpc1tfbGV2ZWxdICE9PSBsZXZlbCB8fCB0aGlzW19zdHJhdGVneV0gIT09IHN0cmF0ZWd5KSB7XG4gICAgICB0aGlzLmZsdXNoKGNvbnN0YW50cy5aX1NZTkNfRkxVU0gpXG4gICAgICBhc3NlcnQodGhpc1tfaGFuZGxlXSwgJ3psaWIgYmluZGluZyBjbG9zZWQnKVxuICAgICAgLy8gLnBhcmFtcygpIGNhbGxzIC5mbHVzaCgpLCBidXQgdGhlIGxhdHRlciBpcyBhbHdheXMgYXN5bmMgaW4gdGhlXG4gICAgICAvLyBjb3JlIHpsaWIuIFdlIG92ZXJyaWRlIC5mbHVzaCgpIHRlbXBvcmFyaWx5IHRvIGludGVyY2VwdCB0aGF0IGFuZFxuICAgICAgLy8gZmx1c2ggc3luY2hyb25vdXNseS5cbiAgICAgIGNvbnN0IG9yaWdGbHVzaCA9IHRoaXNbX2hhbmRsZV0uZmx1c2hcbiAgICAgIHRoaXNbX2hhbmRsZV0uZmx1c2ggPSAoZmx1c2hGbGFnLCBjYikgPT4ge1xuICAgICAgICB0aGlzLmZsdXNoKGZsdXNoRmxhZylcbiAgICAgICAgY2IoKVxuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpc1tfaGFuZGxlXS5wYXJhbXMobGV2ZWwsIHN0cmF0ZWd5KVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpc1tfaGFuZGxlXS5mbHVzaCA9IG9yaWdGbHVzaFxuICAgICAgfVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmICh0aGlzW19oYW5kbGVdKSB7XG4gICAgICAgIHRoaXNbX2xldmVsXSA9IGxldmVsXG4gICAgICAgIHRoaXNbX3N0cmF0ZWd5XSA9IHN0cmF0ZWd5XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIG1pbmltYWwgMi1ieXRlIGhlYWRlclxuY2xhc3MgRGVmbGF0ZSBleHRlbmRzIFpsaWIge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMsICdEZWZsYXRlJylcbiAgfVxufVxuXG5jbGFzcyBJbmZsYXRlIGV4dGVuZHMgWmxpYiB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgc3VwZXIob3B0cywgJ0luZmxhdGUnKVxuICB9XG59XG5cbi8vIGd6aXAgLSBiaWdnZXIgaGVhZGVyLCBzYW1lIGRlZmxhdGUgY29tcHJlc3Npb25cbmNsYXNzIEd6aXAgZXh0ZW5kcyBabGliIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzLCAnR3ppcCcpXG4gIH1cbn1cblxuY2xhc3MgR3VuemlwIGV4dGVuZHMgWmxpYiB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgc3VwZXIob3B0cywgJ0d1bnppcCcpXG4gIH1cbn1cblxuLy8gcmF3IC0gbm8gaGVhZGVyXG5jbGFzcyBEZWZsYXRlUmF3IGV4dGVuZHMgWmxpYiB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgc3VwZXIob3B0cywgJ0RlZmxhdGVSYXcnKVxuICB9XG59XG5cbmNsYXNzIEluZmxhdGVSYXcgZXh0ZW5kcyBabGliIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzLCAnSW5mbGF0ZVJhdycpXG4gIH1cbn1cblxuLy8gYXV0by1kZXRlY3QgaGVhZGVyLlxuY2xhc3MgVW56aXAgZXh0ZW5kcyBabGliIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzLCAnVW56aXAnKVxuICB9XG59XG5cbmNsYXNzIEJyb3RsaSBleHRlbmRzIFpsaWJCYXNlIHtcbiAgY29uc3RydWN0b3IgKG9wdHMsIG1vZGUpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgb3B0cy5mbHVzaCA9IG9wdHMuZmx1c2ggfHwgY29uc3RhbnRzLkJST1RMSV9PUEVSQVRJT05fUFJPQ0VTU1xuICAgIG9wdHMuZmluaXNoRmx1c2ggPSBvcHRzLmZpbmlzaEZsdXNoIHx8IGNvbnN0YW50cy5CUk9UTElfT1BFUkFUSU9OX0ZJTklTSFxuXG4gICAgc3VwZXIob3B0cywgbW9kZSlcblxuICAgIHRoaXNbX2Z1bGxGbHVzaEZsYWddID0gY29uc3RhbnRzLkJST1RMSV9PUEVSQVRJT05fRkxVU0hcbiAgfVxufVxuXG5jbGFzcyBCcm90bGlDb21wcmVzcyBleHRlbmRzIEJyb3RsaSB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgc3VwZXIob3B0cywgJ0Jyb3RsaUNvbXByZXNzJylcbiAgfVxufVxuXG5jbGFzcyBCcm90bGlEZWNvbXByZXNzIGV4dGVuZHMgQnJvdGxpIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzLCAnQnJvdGxpRGVjb21wcmVzcycpXG4gIH1cbn1cblxuZXhwb3J0cy5EZWZsYXRlID0gRGVmbGF0ZVxuZXhwb3J0cy5JbmZsYXRlID0gSW5mbGF0ZVxuZXhwb3J0cy5HemlwID0gR3ppcFxuZXhwb3J0cy5HdW56aXAgPSBHdW56aXBcbmV4cG9ydHMuRGVmbGF0ZVJhdyA9IERlZmxhdGVSYXdcbmV4cG9ydHMuSW5mbGF0ZVJhdyA9IEluZmxhdGVSYXdcbmV4cG9ydHMuVW56aXAgPSBVbnppcFxuLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbmlmICh0eXBlb2YgcmVhbFpsaWIuQnJvdGxpQ29tcHJlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgZXhwb3J0cy5Ccm90bGlDb21wcmVzcyA9IEJyb3RsaUNvbXByZXNzXG4gIGV4cG9ydHMuQnJvdGxpRGVjb21wcmVzcyA9IEJyb3RsaURlY29tcHJlc3Ncbn0gZWxzZSB7XG4gIGV4cG9ydHMuQnJvdGxpQ29tcHJlc3MgPSBleHBvcnRzLkJyb3RsaURlY29tcHJlc3MgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IgKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCcm90bGkgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIHZlcnNpb24gb2YgTm9kZS5qcycpXG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/minizlib@1.3.3/node_modules/minizlib/index.js\n");

/***/ })

};
;